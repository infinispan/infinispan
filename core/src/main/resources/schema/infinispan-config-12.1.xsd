<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified"
           version="1.1" targetNamespace="urn:infinispan:config:12.1"
           xmlns:tns="urn:infinispan:config:12.1"
           xmlns:jgroups="urn:org:jgroups"
           xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:import namespace="urn:org:jgroups" schemaLocation="http://www.jgroups.org/schema/jgroups-4.2.xsd"/>

  <xs:element name="infinispan" type="tns:infinispan">
    <xs:annotation>
      <xs:documentation>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="infinispan">
    <xs:sequence>
      <xs:element name="jgroups" type="tns:jgroups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines JGroups stacks.</xs:documentation>
        </xs:annotation>
        <xs:unique name="stack_id_unique">
          <xs:selector xpath="./tns:stack|./tns:stack-file" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:element name="threads" type="tns:threads" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the threading subsystem.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="cache-container" type="tns:cache-container">
        <xs:annotation>
          <xs:documentation>Defines an embedded cache container.</xs:documentation>
        </xs:annotation>
        <xs:unique name="cache_id_unique">
          <xs:selector xpath="./tns:local-cache|./tns:local-cache-configuration|./tns:invalidation-cache|./tns:invalidation-cache-configuration|./tns:replicated-cache|./tns:replicated-cache-configuration|./tns:distributed-cache|./tns:distributed-cache-configuration" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="jgroups">
    <xs:annotation>
      <xs:documentation>
        Defines JGroups transport stacks.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="stack-file" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              Defines an individual JGroups stack, pointing to the file containing its definition.
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation><xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation><xs:documentation>Path of JGroups configuration file containing stack definition.</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="stack" type="tns:jgroups-stack" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="transport" type="xs:string" default="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
      <xs:annotation>
        <xs:documentation>Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jgroups-stack">
    <xs:complexContent>
      <xs:extension base="jgroups:ConfigType">
        <xs:sequence>
          <xs:element name="remote-sites" type="tns:jgroups-remote-sites" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Defines the relay configuration.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="extends" type="xs:string">
          <xs:annotation>
            <xs:documentation>The base stack to extend.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jgroups-remote-sites">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="remote-site" type="tns:jgroups-stack-relay-remote-site" />
    </xs:sequence>
    <xs:attribute name="default-stack" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="jgroups-stack-relay-remote-site">
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="stack" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="threads">
    <xs:annotation>
      <xs:documentation>
        The threading subsystem, used to declare manageable thread pools and resources.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="thread-factory" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread factory (implementing java.util.concurrent.ThreadFactory).  The "name" attribute is
                the bean name of the created thread factory.  The optional "priority" attribute may be used to specify
                the thread priority of created threads.  The optional "group-name" attribute specifies the name of a the
                thread group to create for this thread factory.

                The "thread-name-pattern" is the template used to create names for threads.  The following patterns
                may be used:

                 %% - emit a percent sign
                 %t - emit the per-factory thread sequence number
                 %g - emit the global thread sequence number
                 %f - emit the factory sequence number
                 %i - emit the thread ID
                 %G - emit the thread group name
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string" use="required" />
          <xs:attribute name="group-name" type="xs:string" use="optional"/>
          <xs:attribute name="thread-name-pattern" type="xs:string" use="optional" />
          <xs:attribute name="priority" type="xs:string" use="optional" />
        </xs:complexType>
      </xs:element>
      <xs:element name="blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue which can run blocking operations.
                Such a thread pool has a core size and a queue with an upper bound.
                When a task is submitted, if the number of running threads is less than the core size, a new thread is created.
                Otherwise, the task is placed in queue.
                If too many tasks are allowed to be submitted to this type of executor, an out of memory condition may occur.
                If the queue is too small it may cause a CacheBackpressureFullException to be thrown if a non-blocking thread cannot submit a task.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The "keepalive-time" attribute may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string" use="optional"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="non-blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue which should only run non blocking operations.
                Such a thread pool has a core size and a queue with an upper bound.
                When a task is submitted, if the number of running threads is less than the core size, a new thread is created.
                Otherwise, the task is placed in queue.
                If too many tasks are allowed to be submitted to this type of executor, an out of memory condition may occur.
                If the queue is too small it may cause blocking thread pool tasks to build up waiting to submit.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The "keepalive-time" attribute may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string" use="optional"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="cached-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates new threads as needed, but
                will reuse previously constructed threads when they are available.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="scheduled-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates a single-threaded executor
                that can schedule commands to run after a given delay, or to
                execute periodically.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-container">
    <xs:sequence>
      <xs:element name="transport" type="tns:transport" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Overrides the transport characteristics for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:global-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures security for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serialization" type="tns:serialization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Specifies how data serialization will be performed by the cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="metrics" type="tns:metrics" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures MicroProfile metrics.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="jmx" type="tns:jmx" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables and configures JMX monitoring and management.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="global-state" type="tns:global-state" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the global state persistence configuration. If this element is not present, global state persistence will be disabled.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="local-cache" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="local-cache-configuration" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache-configuration" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache-configuration" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache-configuration" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache-configuration" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache configuration. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:any namespace="##other"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="default-cache" type="xs:string">
      <xs:annotation>
        <xs:documentation>Indicates the default cache for this cache container</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zero-capacity-node" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If 'true' then no data is stored in this node. Defaults to 'false'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="listener-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache listener notifications.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiration-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the scheduled executor used for expirations.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="non-blocking-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the executor used for non-blocking operations. Must be non-blocking and must have a queue.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blocking-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the executor used for blocking operations. Must be blocking and must have a queue.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string" default="org.jboss.as.clustering.infinispan">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shutdown-hook" type="tns:shutdown-hook-behavior">
      <xs:annotation>
        <xs:documentation>
          Behavior of the JVM shutdown hook registered by the cache
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transport">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A transport property with name and value to be passed to the Transport instance.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="stack" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the jgroups stack used by the transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the name for the underlying group communication cluster.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote-command-executor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used to execute remote commands. Use org.infinispan.executors.WithinThreadExecutorFactory to disable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lock-timeout" type="xs:long" default="240000">
      <xs:annotation>
        <xs:documentation>
          Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
          This constraint is in place because more than one cache could be involved in a transaction.
          This timeout controls the time to wait to acquire a distributed lock.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="node-name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Name of the current node. This is a friendly name to make logs, etc. make more sense. Defaults to a combination of host name and a random number (to differentiate multiple nodes on the same host)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="machine" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the machine where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rack" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the rack where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="site" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the site where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The minimum number of nodes that must join the cluster for the cache manager to start
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
              <xs:element name="identity-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the identity role mapper where principal names are converted as-is into role names.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="common-name-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="cluster-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the cluster role mapper which stores the principal to role mappings within the cluster registry.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="custom-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses a custom role mapper.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="class" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Class of the custom principal to role mapper
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:element name="roles" type="tns:roles" minOccurs="0" />
          </xs:sequence>
          <xs:attribute name="audit-logger" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the audit logger.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="cache-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The ACL cache size. The default is 1000 entries. A value of 0 disables the cache.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cache-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The ACL cache timeout in milliseconds. The default is 300000 (5 minutes). A value of 0 disables the cache.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="roles">
    <xs:sequence>
      <xs:element name="role" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Defines a new role name and assigns permissions to it.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="name" use="required" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Defines the name of the role.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="permissions" use="required" type="tns:permission-list">
            <xs:annotation>
              <xs:documentation>
                Defines the list of permissions for the role.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="serialization">
    <xs:sequence>
      <xs:element name="advanced-externalizer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0. Please utilise ProtoStream based marshalling for your Java objects by
            configuring one or more context-initializer elements. Alternatively, it's possible to configure a custom
            org.infinispan.commons.marshall.Marshaller implementation for user types, via the "marshaller" attribute.
            AdvancedExternalizer implementations allow users to have fine grained control over how Java objects are
            serialized. Providing smaller payloads than traditional Serialization or Externalizer implementations by
            writing a class ID value instead of the classes FQN.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="id" type="xs:int">
            <xs:annotation>
              <xs:documentation>
                Id of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="context-initializer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            SerializationContextInitializer implementation which is used to initialize a ProtoStream based marshaller
            for user types. If no &lt;context-initializer&gt; elements are present then the java.util.ServiceLoader
            mechanism will be used to automatically discover all SerializationContextInitializer implementations present
            in classpath and load them.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the SerializationContextInitializer implementation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="allow-list" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables individual classes or regular expressions to be added to the EmbeddedCacheManager allow list.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="class" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  FQN of the class to be added to the allowlist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="regex" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Regex pattern used to determine if a class is a member of the allowlist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="marshaller" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string" default="71">
      <xs:annotation>
        <xs:documentation>
          Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="metrics">
    <xs:attribute name="gauges" type="xs:boolean" default="${GlobalMetrics.gauges}">
      <xs:annotation>
        <xs:documentation>
          Exports gauge metrics. Gauges are enabled by default but you must
          enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="histograms" type="xs:boolean" default="${GlobalMetrics.histograms}">
      <xs:annotation>
        <xs:documentation>
          Exports histogram metrics. Histograms are not enabled by default
          because they require additional computation. If you enable histograms
          you must also enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies a global name prefix for metrics.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namesAsTags" type="xs:boolean" default="${GlobalMetrics.namesAsTags}">
      <xs:annotation>
        <xs:documentation>
          Put the cache manager and cache name in tags rather then include them in the metric name.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jmx">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Specifies a JMX property with a name and value that is passed to
            the MBean Server lookup instance.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="domain" type="xs:string" default="${GlobalJmx.domain}">
      <xs:annotation>
        <xs:documentation>
          If JMX statistics are enabled then all 'published' JMX objects appear
          under this domain. Optional, if not specified it defaults to
          "org.infinispan".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mbean-server-lookup" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Class that attempts to locate a JMX MBean server to bind to. Defaults
          to the platform MBean server.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${GlobalJmx.enabled}">
      <xs:annotation>
        <xs:documentation>
          Enables exporting of JMX MBeans.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-state">
    <xs:sequence>
      <xs:element name="persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where persistent state data which needs to survive container restarts
            should be stored. The data stored at this location is required for graceful
            shutdown and restore. This path must NOT be shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="shared-persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where shared persistent state data which needs to survive container restarts
            should be stored. This path can be safely shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="temporary-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where temporary state should be stored. Defaults to the value of the
            java.io.tmpdir system property.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0">
        <xs:element name="immutable-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              An immutable configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="volatile-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A non-persistent configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="overlay-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage which saves runtime configurations to the persistent-location.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="managed-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage for managed environments. This doesn't work in embedded mode.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="custom-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              Uses a custom configuration storage implementation.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="class" type="xs:string">
              <xs:annotation>
                <xs:documentation>
                  Class of the custom configuration storage implementation.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="global-state-path">
    <xs:attribute name="relative-to" type="xs:string" default="jboss.server.data.dir">
        <xs:annotation>
            <xs:documentation>A property name whose value will be used as the root path for storing global state</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Defines the path where global state for this cache-container will be stored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cache" abstract="true">
    <xs:sequence>
      <xs:element name="backups" type="tns:backups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines backup locations for cache data and modifies state transfer properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="backup-for" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Defines the local cache as a backup for a remote cache with a different name.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="remote-cache" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote cache that uses the local cache as a backup.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remote-site" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote site that backs up data to the local cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="encoding" type="tns:encoding" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache encoding configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="locking" type="tns:locking" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The locking configuration of the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="transaction" type="tns:transaction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache transaction configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expiration" type="tns:expiration" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache expiration configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store-as-binary" type="tns:store-as-binary" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures the cache to store data in binary format.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="persistence" type="tns:persistence" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the persistence layer for caches.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="memory" type="tns:memory" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls how the entries are stored in memory
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="indexing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines indexing options for cache
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="index-reader" type="tns:index-reader" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Controls index reading parameters.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="index-writer" type="tns:index-writer" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Controls index writing parameters</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="key-transformers" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>Defines the Transformers used to stringify keys for indexing with Lucene</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="key-transformer" minOccurs="0" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:annotation>
                        <xs:documentation>Defines the Transformer to use for the specified key class</xs:documentation>
                      </xs:annotation>
                      <xs:attribute name="key" type="xs:string" use="required" />
                      <xs:attribute name="transformer" type="xs:string" use="required"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="indexed-entities" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>Defines the set of indexed type names (fully qualified). If values of types that are not included in this set are put in the cache they will not be indexed.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="indexed-entity" type="xs:string" minOccurs="1" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>Indexed entity type name. Must be either a fully qualified Java class name or a protobuf type name.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Property to pass on to the indexing system</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="enabled" type="xs:boolean" default="${Indexing.enabled}">
            <xs:annotation>
              <xs:documentation>
                Specify whether indexing is enabled or not. Defaults to false, but it auto-activates if the
                indexing element is present and indexing is not explicitly disabled. It also auto-activates if 'auto-config' is set to 'true'.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storage" type="tns:index-storage" default="filesystem">
            <xs:annotation>
              <xs:documentation>Specify index storage options.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Specifies a filesystem path for the index when storage is 'filesystem'.
                The value can be a relative or absolute path. Relative paths are created
                relative to the configured global persistent location, or to the current
                working directory when global state is disabled.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="auto-config" type="xs:boolean" default="${Indexing.autoConfig}">
            <xs:annotation>
              <xs:documentation>Deprecated since 11.0, with no replacement. Whether or not to apply automatic index configuration based on cache type</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="custom-interceptors" type="tns:custom-interceptors" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.
             Configures custom interceptors to be added to the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:cache-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures cache-level security.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:ID" use="required">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache within its cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configuration" type="xs:IDREF">
      <xs:annotation>
        <xs:documentation>The name of the cache configuration which this configuration inherits from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="${Statistics.enabled}">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics-available" type="xs:boolean" default="${Statistics.available}">
      <xs:annotation>
        <xs:documentation>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unreliable-return-values" type="xs:boolean" default="${Unsafe.unreliable-return-values}">
      <xs:annotation>
        <xs:documentation>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="local-cache">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:attribute name="simple-cache" default="${Configuration.simpleCache}">
          <xs:annotation>
            <xs:documentation>
                This cache will be using optimized (faster) implementation that does not support transactions/invocation
                batching, persistence, custom interceptors, indexing, store-as-binary or transcoding. Also, this type of
                cache does not support Map-Reduce jobs or Distributed Executor framework.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="locking">
    <xs:attribute name="isolation" type="tns:isolation" default="${Locking.isolationLevel}">
      <xs:annotation>
        <xs:documentation>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="striping" type="xs:boolean" default="${Locking.striping}">
      <xs:annotation>
        <xs:documentation>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquire-timeout" type="xs:long" default="${Locking.lockAcquisitionTimeout}">
      <xs:annotation>
        <xs:documentation>Maximum time to attempt a particular lock acquisition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="concurrency-level" type="xs:int" default="${Locking.concurrencyLevel}">
      <xs:annotation>
        <xs:documentation>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transaction">
    <xs:attribute name="mode" type="tns:transaction-mode" default="NONE">
      <xs:annotation>
        <xs:documentation>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stop-timeout" type="xs:long" default="${Transaction.stop-timeout}">
      <xs:annotation>
        <xs:documentation>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="locking" type="tns:locking-mode" default="${Transaction.locking}">
      <xs:annotation>
        <xs:documentation>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transaction-manager-lookup" type="xs:string" default="${Transaction.transaction-manager-lookup}">
      <xs:annotation>
        <xs:documentation>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="complete-timeout" type="xs:long" default="${Transaction.complete-timeout}">
      <xs:annotation>
        <xs:documentation>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reaper-interval" type="xs:long" default="${Transaction.reaper-wake-up-interval}">
      <xs:annotation>
        <xs:documentation>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto-commit" type="xs:boolean" default="${Transaction.auto-commit}">
      <xs:annotation>
        <xs:documentation>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recovery-cache" type="xs:string" default="${Recovery.recoveryInfoCacheName}">
      <xs:annotation>
        <xs:documentation>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notifications" type="xs:boolean" default="${Transaction.notifications}">
      <xs:annotation>
        <xs:documentation>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="encodingType" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Describes the content-type and encoding.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="media-type" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="keyEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="valueEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="encoding">
    <xs:annotation>
      <xs:documentation>
        Defines content type and encoding for keys and values of the cache.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="key" type="tns:keyEncodingType" minOccurs="0" maxOccurs="1"/>
      <xs:element name="value" type="tns:valueEncodingType" minOccurs="0" maxOccurs="1"/>
    </xs:sequence>
    <xs:attribute name="media-type" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The media type for both keys and values. When present, takes precedence over the
          individual configurations for keys and values.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="expiration">
    <xs:attribute name="max-idle" type="xs:long" default="${Expiration.maxIdle}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can remain idle. If no operations are performed on entries
          within the maximum idle time, the entries expire across the cluster.
          A value of 0 or -1 disables expiration.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lifespan" type="xs:long" default="${Expiration.lifespan}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can exist. After reaching their lifespan, cache entries
          expire across the cluster. A value of 0 or -1 disables expiration.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="xs:long" default="${Expiration.wakeUpInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the interval, in milliseconds, between expiration runs. A
          value of 0 or -1 disables the expiration reaper.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="touch" type="tns:touch-mode" default="${Expiration.touch}">
      <xs:annotation>
        <xs:documentation>
          Control how the timestamp of read entries with max-idle are updated on all the key owners in a cluster.
          Default is SYNC.
          If the cache mode is ASYNC this attribute is ignored, and timestamps are updated asynchronously.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="store-as-binary">
    <xs:annotation>
      <xs:documentation>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
        DEPRECATED: please use memory element instead
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="keys" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="values" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="persistence">
    <xs:choice minOccurs="0">
      <xs:element name="cluster-loader" type="tns:cluster-loader">
        <xs:annotation>
          <xs:documentation>Defines a cluster cache loader.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store" type="tns:custom-store">
        <xs:annotation>
          <xs:documentation>Defines a custom cache store.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="file-store" type="tns:file-store">
        <xs:annotation>
          <xs:documentation>
            Defines a filesystem-based cache store.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" />
    </xs:choice>
    <xs:attribute name="passivation" type="xs:boolean" default="${Persistence.passivation}">
      <xs:annotation>
        <xs:documentation>
          Enables passivation so that data is written to cache stores only if
          it is evicted from memory. Subsequent requests for passivated entries
          restore them to memory and remove them from persistent storage.
          If you do not enable passivation, writes to entries in memory result
          in writes to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connection-attempts" type="xs:int" default="${Persistence.connectionAttempts}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum number of attempts to start each configured
          `CacheWriter` or `CacheLoader`. An exception is thrown and the cache
          does not start if the number of connection attempts exceeds the
          maximum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connection-interval" type="xs:int" default="${Persistence.connectionInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the time, in milliseconds, to wait between connection
          attempts on startup. A negative or zero value means no wait between
          connection attempts.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="availability-interval" type="xs:int" default="${Persistence.availabilityInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the time, in milliseconds, between availability checks to
          determine if the PersistenceManager is available. In other words,
          this interval sets how often stores and loaders are polled via their
          `org.infinispan.persistence.spi.CacheWriter#isAvailable` or
          `org.infinispan.persistence.spi.CacheLoader#isAvailable`
          implementation. If a single store or loader is not available, an
          exception is thrown during cache operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-interceptors">
    <xs:sequence>
      <xs:element name="interceptor" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="property" type="tns:property" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="after" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="before" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation><xs:documentation>A fully qualified class name of the new custom interceptor to add to the configuration.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="index" type="xs:int">
            <xs:annotation><xs:documentation>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="xs:string">
            <xs:annotation><xs:documentation>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures authorization for this cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="${Authorization.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roles" type="tns:role-list">
            <xs:annotation>
              <xs:documentation>
                Sets the valid roles required to access this cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="memory">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element name="object" type="tns:memory-object">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 11.0. Use instead the 'encoding' element to specify the media type of keys
              and values, plus the storage attribute as 'HEAP'.
              Store keys and values as instance variables in the Java heap.
              Instances of byte[] are wrapped to ensure equality. This is the
              default storage format.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="binary" type="tns:memory-binary">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 11.0. Use instead the 'encoding' element to specify the media type of keys
              and values, plus the storage attribute as 'HEAP'.
              Store keys and values as bytes in the Java heap. Cache
              entries are serialized to binary representations. Note that
              binary storage violates object equality. This occurs because
              equality is determined by the equivalence of the resulting
              byte[] instead of the object instances.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="off-heap" type="tns:memory-off-heap">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 11.0. Use instead the 'encoding' element to specify the media type of keys
              and values, plus the storage attribute as 'OFF_HEAP'.
              Store keys and values as bytes in native memory. Cache
              entries are serialized to binary representations. Temporary
              objects are stored in the Java heap space until processing
              completes. Note that off-heap storage violates object equality.
              This occurs because equality is determined by the equivalence of
              the resulting byte[] instead of the object instances.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="max-size" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container in bytes. The default unit is
          B (bytes). You can optionally set one of the following units: KB
          (kilobytes), MB (megabytes), GB (gigabytes), TB (terabytes), KiB
          (kibibytes), MiB (mebibytes), GiB (gibibytes) and TiB (tebibytes).
          Eviction occurs when the approximate memory usage of the data
          container exceeds the maximum size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-count" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container by number of entries. Eviction occurs after the container size exceeds the maximum count.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="when-full" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define either the max-size or the max-count
          (but not both) for the data container. If no strategy is defined,
          but max-count or max-size is configured, REMOVE is used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="storage" type="tns:memory-storage" default="HEAP">
      <xs:annotation>
        <xs:documentation>
          Defines the type of memory that the data container uses as storage.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="memory-storage">
    <xs:restriction base="xs:token">
      <xs:enumeration value="HEAP">
        <xs:annotation>
          <xs:documentation>
            Stores cache entries in JVM heap memory.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OFF_HEAP">
        <xs:annotation>
          <xs:documentation>
            Stores cache entries as bytes in native memory outside the Java
            heap.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OBJECT">
        <xs:annotation>
          <xs:documentation>
            Deprecated, only added in 11.0 to simplify the transition from the &lt;object/&gt; element.
            Please use HEAP instead.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BINARY">
        <xs:annotation>
          <xs:documentation>
            Deprecated, only added in 11.0 to simplify the transition from the &lt;binary/&gt; element.
            Please use HEAP and set the encoding media type instead.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="memory-object">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Eviction occurs when the number of entries exceeds the size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-binary">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container as a long. Eviction occurs
          either when the number of entries or amount of memory exceeds the
          size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>
          Specifies whether eviction is based on the number of entries or the
          amount of memory used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-off-heap">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container as a long. Eviction occurs
          either when the number of entries or amount of memory exceeds the
          size.
      </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>
          Specifies whether eviction is based on the number of entries or the
          amount of memory used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="clustered-cache" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:sequence>
          <xs:element name="partition-handling" minOccurs="0" maxOccurs="1">
             <xs:annotation>
                <xs:documentation>
                   Configures the way this cache reacts to node crashes and split brains.
                </xs:documentation>
             </xs:annotation>
             <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean" use="optional">
                   <xs:annotation>
                      <xs:documentation>
                         Deprecated, use type instead. Enable/disable the partition handling functionality. Defaults to false.
                      </xs:documentation>
                   </xs:annotation>
                </xs:attribute>
               <xs:attribute name="when-split" type="tns:partition-handling-type" default="${PartitionHandling.whenSplit}">
                 <xs:annotation>
                   <xs:documentation>The type of actions that are possible when a split brain scenario is encountered.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
               <xs:attribute name="merge-policy" type="tns:merge-policy" default="${PartitionHandling.mergePolicy}">
                 <xs:annotation>
                   <xs:documentation>The entry merge policy which should be applied on partition merges.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
             </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="mode" type="tns:mode" default="SYNC">
          <xs:annotation>
            <xs:documentation>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="remote-timeout" type="xs:long" default="${Clustering.remoteTimeout}">
          <xs:annotation>
            <xs:documentation>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="invalidation-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="replicated-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>
              Sets the number of hash space segments per cluster. The default
              value is 256. The value should be at least 20 * the cluster size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 11.0. Will be removed in 14.0, the segment allocation will no longer be customizable.
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="distributed-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="owners" type="xs:int" default="${Hash.numOwners}">
          <xs:annotation>
            <xs:documentation>Number of cluster-wide replicas for each cache entry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>Sets the number of hash space segments per cluster. The default value is 256. The value should be at least 20 * the cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity-factor" type="xs:double" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>Controls the proportion of entries that will reside on the local node,
              compared to the other nodes in the cluster. Value must be positive. The default is 1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-lifespan" type="xs:long">
          <xs:annotation>
            <xs:documentation>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
               By default L1 is disabled unless a positive value is configured for this attribute.
               If the attribute is not present, L1 is disabled.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-cleanup-interval" type="xs:long" default="${L1.cleanupTaskFrequency}">
          <xs:annotation>
            <xs:documentation>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="scattered-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="256">
          <xs:annotation>
            <xs:documentation>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="1">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="invalidation-batch-size" type="xs:integer" default="${Clustering.invalidationBatchSize}">
          <xs:annotation>
            <xs:documentation>
              Threshold for sending batch invalidations. Once a node registers more updated keys,
              it sends a batch invalidation to all nodes requesting to remove old versions of the entries.
              The threshold is also used for second batch invalidation of tombstones for removed entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bias-acquisition" type="tns:bias-acquisition" default="${Clustering.biasAcquisition}">
          <xs:annotation>
            <xs:documentation>
              Specifies when is a node allowed to acquire a bias on an entry, serving further reads
              to the same key locally (despite not being an owner). Acquired bias allows reading data on non-owner,
              but slows down further writes from other nodes.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bias-lifespan" type="xs:long" default="${Clustering.biasLifespan}">
          <xs:annotation>
            <xs:documentation>
              Specifies the duration (in Milliseconds) that acquired bias can be held; while the reads will never be stale,
              tracking that information consumes memory on the primary owner.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loader" abstract="true">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A cache loader property with name and value.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>
          Determines if a cache loader is shared between cache instances.
          Values are true / false (default). This property prevents duplicate
          writes of data to the cache loader by different cache instances. An
          example is where all cache instances in a cluster use the same JDBC
          settings for the same remote, shared database. If true, only the
          nodes where modifications originate write to the cache store. If
          false, each cache reacts to potential remote updates by storing the
          data to the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>
          Pre-loads data into memory from the cache loader when the cache
          starts. Values are true / false (default). This property is useful
          when data in the cache loader is required immediately after startup
          to prevent delays with cache operations when the data is loaded
          lazily. This property can provide a "warm cache" on startup but it
          impacts performance because it affects start time. Pre-loading data
          is done locally, so any data loaded is stored locally in the node
          only. Pre-loaded data is not replicated or distributed. Likewise,
          data is pre-loaded only up to the maximum configured number of
          entries in eviction.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cluster-loader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="remote-timeout" type="xs:long" default="${ClusterLoader.remoteCallTimeout}">
          <xs:annotation>
            <xs:documentation>The timeout when performing remote calls.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="store" abstract="true">
    <xs:sequence>
      <xs:element name="write-behind" type="tns:write-behind" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Configures cache stores as write-behind instead of write-through.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Defines a cache store property with name and value.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactional" type="xs:boolean" default="${AbstractStore.transactional}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and cache's transactions rollingback.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process. Likewise in some cases you cannot pre-load data in caches stores, such as when using shared remote stores.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fetch-state" type="xs:boolean" default="${AbstractStore.fetchPersistentState}">
      <xs:annotation>
        <xs:documentation>Fetches the persistent state of a cache when joining
          a cluster. Values are true / false (default). The purpose of this
          property is to retrieve the persistent state of a cache and apply it to the local cache store of a node when it joins a cluster. Fetching
          the persistent state does not apply if a cache store is shared because it accesses the same data as the other stores. This property can be `true` for one configured cache loader only. If more than
          one cache loader fetches the persistent state, a configuration exception is thrown when the cache service starts.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="purge" type="xs:boolean" default="${AbstractStore.purgeOnStartup}">
      <xs:annotation>
        <xs:documentation>
          Empties the specified cache loader at startup. Values are true /
          false (default). This property takes effect only if read-only is
          false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="read-only" type="xs:boolean" default="${AbstractStore.ignoreModifications}">
      <xs:annotation>
        <xs:documentation>
          Prevents data from being persisted to cache stores. Values are true /
          false (default). If true, cache stores load entries only. Any
          modifications to data in the cache do not apply to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="write-only" type="xs:boolean" default="${AbstractStore.writeOnly}">
      <xs:annotation>
        <xs:documentation>
          Prevents data from being loaded from cache stores. Values are true /
          false (default). If true, cache stores write entries only. Any
          retrievals of data in the cache do not read from the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-batch-size" type="xs:int" default="${AbstractStore.maxBatchSize}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum size of a batch to insert or delete from the cache
          store. If the value is less than one, no upper limit applies to the
          number of operations in a batch.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segmented" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Configures cache stores to store data in hash space segments, with the cache's
          "segments" attribute defining the number of segments.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="write-behind">
    <xs:attribute name="modification-queue-size" type="xs:int" default="${AsyncStore.modificationQueueSize}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum number of entries in the asynchronous
          modification queue. When the queue is full, write-through mode is
          used until the queue can accept new entries.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="${AsyncStore.threadPoolSize}">
      <xs:annotation>
        <xs:documentation>
          Specifies the number of threads to apply modifications to the cache
          store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fail-silently" type="xs:boolean" default="${AsyncStore.failSilently}">
      <xs:annotation>
        <xs:documentation>
          Controls how asynchronous write operations take place when cache
          stores become unavailable. If "true", asynchronous write operations
          that fail are re-attempted with the number of times specified in the
          "connection-attempts" parameter. If all attempts fail, errors are
          ignored and write operations are not executed on the cache store. If
          "false", asynchronous write operations that fail are re-attempted
          when the underlying store becomes available. If the modification
          queue becomes full before the underlying store becomes available, an
          error is thrown on all future write operations to the store until the
          modification queue is flushed. The modification queue is not
          persisted. If the underlying store does not become available before
          the asynchronous store is stopped, queued modifications are lost.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="class" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the class name of a cache store that
              implements either `CacheLoader`, `CacheWriter`, or both.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="file-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="max-entries" type="xs:int">
          <xs:annotation>
            <xs:documentation>
              Specifies the maximum number of entries that the file store can
              hold. To increase the speed of lookups, Single File cache stores
              index keys and their locations in the file. To avoid excessive
              memory usage, you can configure the maximum number of entries so
              that entries are removed permanently from both memory and the
              cache store when the maximum is exceeded. However, this can lead
              to data loss. You should only set a maximum number of entries if
              data can be recomputed or retrieved from an authoritative data
              store. By default, the value is `-1` which means that there is no
              maximum number of entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Specifies a filesystem directory for data. The value can be a
              relative or absolute path. Relative paths are created relative to
              the configured global persistent location. Absolute paths must be
              subdirectories of the global persistent location, otherwise an
              exception is thrown.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="remote-server">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The hostname or ip address of a remote Hot Rod server
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:int" default="11222">
      <xs:annotation>
        <xs:documentation>
          The port on which the server is listening (default 11222)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outbound-socket-binding" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="state-transfer">
    <xs:attribute name="enabled" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${StateTransfer.timeout}">
      <xs:annotation>
        <xs:documentation>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunk-size" type="xs:integer" default="${StateTransfer.chunkSize}">
      <xs:annotation>
        <xs:documentation>The number of cache entries to batch in each transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="await-initial-transfer" type="xs:boolean" default="${StateTransfer.awaitInitialTransfer}">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="groups">
    <xs:sequence>
      <xs:element name="grouper" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="enabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Enables or disables grouping.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backups">
    <xs:sequence>
      <xs:element name="backup" type="tns:backup" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Configures a remote site as a backup location for cache data.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="merge-policy" type="tns:xsite-merge-policy" default="${Sites.merge-policy}">
      <xs:annotation>
        <xs:documentation>
          Specifies the fully qualified name of a class that implements the XSiteEntryMergePolicy interface or any of
          the alias. Use if for ASYNC strategy backup.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backup">
    <xs:sequence>
      <xs:element name="take-offline" type="tns:take-offline" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Specifies the number of failures that can occur before backup locations go offline.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="state-transfer" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Modifies state transfer operations.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="chunk-size" type="xs:int" default="${XSiteStateTransfer.chunkSize}">
            <xs:annotation>
               <xs:documentation>
                 Specifies how many cache entries are batched in each transfer request.
               </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="xs:long" default="${XSiteStateTransfer.timeout}">
            <xs:annotation>
              <xs:documentation>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max-retries" type="xs:int" default="${XSiteStateTransfer.maxRetries}">
            <xs:annotation>
              <xs:documentation>
                Sets the maximum number of retry attempts for push state failures. Specify a value of 0 (zero) to disable retry attempts. The default value is 30.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wait-time" type="xs:long" default="${XSiteStateTransfer.waitTime}">
            <xs:annotation>
              <xs:documentation>
                Sets the amount of time, in milliseconds, to wait between retry attempts for push state failures. You must specify a value of 1 or more. The default value is 2000.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mode" type="tns:xsite-state-transfer-mode" default="${XSiteStateTransfer.mode}">
            <xs:annotation>
              <xs:documentation>
                Controls whether cross-site state transfer happens manually on user action, which is the default, or automatically when backup locations come online.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="site" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Names the remote site to which the cache backs up data.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:mode" default="${Backup.strategy}">
      <xs:annotation>
        <xs:documentation>
          Sets the strategy for backing up to a remote site.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy" type="tns:backup-failure-policy" default="${Backup.backupFailurePolicy}">
      <xs:annotation>
        <xs:documentation>
          Controls how local writes to caches are handled if synchronous backup operations fail.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${Backup.replicationTimeout}">
      <xs:annotation>
        <xs:documentation>
          Specifies timeout, in milliseconds, for synchronous and asynchronous backup operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${Backup.enabled}">
      <xs:annotation>
        <xs:documentation>
          Enables backup locations. Set the value to "false" to disable backups.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="two-phase-commit" use="optional" type="xs:boolean" default="${Backup.useTwoPhaseCommit}">
      <xs:annotation>
        <xs:documentation>
          Enables two-phase commits for optimistic transactional caches with
          the synchronous backup strategy only.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy-class" use="optional" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the fully qualified name of a class that implements the
          CustomFailurePolicy interface. Use if failure-policy="CUSTOM".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="take-offline">
    <xs:attribute name="after-failures" type="xs:int" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the number of consecutive failures that can occur for backup
          operations before sites go offline. Specify a negative or zero value
          to ignore this attribute and use minimum wait time only ("min-wait").
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-wait" type="xs:long" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the minimum time to wait, in milliseconds, before sites go
          offline when backup operations fail. If subsequent operations are
          successful, the minimum wait time is reset. If you set
          "after-failures", sites go offline when the wait time is reached and
          the number of failures occur.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="property">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the name of a property.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="isolation">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_UNCOMMITTED">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures READ_COMMITTED</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_COMMITTED">
        <xs:annotation>
          <xs:documentation>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REPEATABLE_READ">
        <xs:annotation>
          <xs:documentation>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SERIALIZABLE">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures REPEATABLE_READ</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Cache will not enlist within transactions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BATCH">
        <xs:annotation>
          <xs:documentation>Uses batching to group cache operations together.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.Synchronization</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_DURABLE_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FULL_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="indexing">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not index data. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LOCAL">
        <xs:annotation>
          <xs:documentation>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>Index all data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PRIMARY_OWNER">
        <xs:annotation>
          <xs:documentation>Only index changes on the primary owner, regardless of it's local or remote.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="index-storage">
    <xs:restriction base="xs:token">
      <xs:enumeration value="filesystem">
        <xs:annotation>
          <xs:documentation>Local filesystem index storage. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="local-heap">
        <xs:annotation>
          <xs:documentation>JVM heap index storage, not persisted between restarts. Only suitable for small datasets with low concurrency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="index-reader">
    <xs:attribute name="refresh-interval" type="xs:long" default="0">
      <xs:annotation>
        <xs:documentation>
          Interval, in milliseconds, to reopen the index reader.
          By default, the index reader is refreshed on-demand during searches, if new entries were indexed since the last refresh. Configuring with a value larger than zero will make some queries results stale, but query throughput will increase substantially, specially in write heavy scenarios.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-merge">
    <xs:attribute name="max-entries" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Maximum number of entries that an index segment can have before merging. Segments with more than this number of entries are not merged. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="factor" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Number of segments that are merged at once. With smaller values, merging happens more often, which uses more resources, but the total number of segments will be lower on average, increasing search performance. Larger values (greater than 10) are best for heavy writing scenarios.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Minimum target size of segments, in MB, for background merges. Segments smaller than this size are merged more aggressively. Setting a value that is too large might result in expensive merge operations, even though they are less frequent.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Maximum size of segments, in MB, for background merges. Segments larger than this size are never merged in the background. Settings this to a lower value helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. This attribute is ignored when forcefully merging an index and `max-forced-size` applies instead.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-forced-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          maximum size of segments, in MB, for forced merges and overrides the `max-size` attribute. Set this to the same value as `max-size` or lower. However setting the value too low degrades search performance because documents are deleted.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="calibrate-by-deletes" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Whether the number of deleted entries in an index should be taken into account when counting the entries in the segment. Setting `false` will lead to more frequent merges caused by `max-entries`, but will more aggressively merge segments with many deleted documents, improving search performance.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-writer">
    <xs:sequence>
      <xs:element name="index-merge" type="tns:index-merge" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines properties to control the merge of index segments. An index segment is
            not related to an Infinispan segment, but represents a section of index in the storage.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="commit-interval" type="xs:int" default="1000">
      <xs:annotation>
        <xs:documentation>
          Amount of time, in milliseconds, that index changes that are buffered in memory are flushed to the index storage and a commit is performed. Because operation is costly, small values should be avoided. The default is 1000 ms (1 second).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ram-buffer-size" type="xs:int" default="32">
      <xs:annotation>
        <xs:documentation>
          Maximum amount of memory that can be used for buffering added entries and deletions before they are flushed to the index storage. Large values result in faster indexing but use more memory. For faster indexing performance you should set this attribute instead of `max-buffered-entries`. When used in combination with the `max-buffered-entries` attribute, a flush occurs for whichever event happens first.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-buffered-entries" type="xs:int" default="32">
      <xs:annotation>
        <xs:documentation>
          Maximum number of entries that can be buffered in-memory before they are flushed to the index storage. Large values result in faster indexing but use more memory. When used in combination with the `ram-buffer-size` attribute, a flush occurs for whichever event happens first.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Number of threads that execute write operations to the index.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue-count" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Number of internal queues to use for each indexed type. Each queue holds a batch of modifications that is applied to the index and queues are processed in parallel. Increasing the number of queues will lead to an increase of indexing throughput, but only if the bottleneck is CPU. For optimum results, do not set a value for `queue-count` that is larger than the value for `thread-pool-size`.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue-size" type="xs:int" default="1000">
      <xs:annotation>
        <xs:documentation>
          Maximum number of elements each queue can hold. Increasing the `queue-size` value increases the amount of memory that is used during indexing operations. Setting a value that is too small can block indexing operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="low-level-trace" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          Enables low-level trace information for indexing operations. Enabling this attribute substantially degrades performance. You should use this low-level tracing only as a last resource for troubleshooting.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="eviction-strategy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If you define a size for the data container,
            you should specify either the REMOVE or EXCEPTION exiction strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>
            Manually evict entries. This strategy is the same as NONE but does
            not log errors if you enable passivation without eviction.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE">
        <xs:annotation>
          <xs:documentation>
            Automatically evict older entries to make space for new entries. By
            default REMOVE is always used when you define a size for the data
            container unless you configure the EXCEPTION strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXCEPTION">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If the data container reaches the maximum
            size, exceptions occur for requests to create new entries. You can
            use this eviction strategy only with transactional caches that use
            two phase commit.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNORDERED">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIFO">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LRU">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIRS">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>
            Enables asynchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>
            Enables synchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="locking-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="OPTIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Optimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PESSIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Pessimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="backup-failure-policy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="IGNORE">
        <xs:annotation>
          <xs:documentation>
            Ignore failed backup operations and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARN">
        <xs:annotation>
          <xs:documentation>
            Log exceptions when backup operations fail and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FAIL">
        <xs:annotation>
          <xs:documentation>
            Throw exceptions when backup operations fail and attempt to stop writes to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CUSTOM">
        <xs:annotation>
          <xs:documentation>
            Use a custom failure policy. Requires the "failure-policy-class" attribute.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdown-hook-behavior">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REGISTER">
        <xs:annotation>
          <xs:documentation>Register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DONT_REGISTER">
        <xs:annotation>
          <xs:documentation>Don't register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="COUNT">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the number of entries reaches the
            configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MEMORY">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the amount of memory in use
            reaches the configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="versioning-scheme">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIMPLE">
        <xs:annotation>
          <xs:documentation>
            A simple versioning scheme that is cluster-aware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Don't version entries
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="permission-list">
    <xs:list itemType="tns:permission"/>
  </xs:simpleType>

  <xs:simpleType name="permission">
    <xs:restriction base="xs:string">
      <xs:enumeration value="LIFECYCLE">
        <xs:annotation>
          <xs:documentation>
            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ">
        <xs:annotation>
          <xs:documentation>
            Allows reading data from a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows writing data to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXEC">
        <xs:annotation>
          <xs:documentation>
            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LISTEN">
        <xs:annotation>
          <xs:documentation>
            Allows attaching listeners to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_READ">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-read operations (e.g. obtaining all the keys in a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-write operations (e.g. clearing a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ADMIN">
        <xs:annotation>
          <xs:documentation>
            Allows performing "administrative" operations on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all of the others
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_READ">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all read permissions (READ and BULK_READ)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_WRITE">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Permission which means no permissions
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="role-list">
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="partition-handling-type">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DENY_READ_WRITES">
        <xs:annotation>
          <xs:documentation>If the partition does not have all owners for a given segment, both reads and writes are denied for all keys in that segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READS">
        <xs:annotation>
          <xs:documentation>Allows reads for a given key if it exists in this partition, but only allows writes if this partition contains all owners of a segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READ_WRITES">
        <xs:annotation>
          <xs:documentation>Allow entries on each partition to diverge, with conflicts resolved during merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="merge-policy">
    <xs:union memberTypes="tns:merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not attempt to resolve conflicts on merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_ALWAYS">
        <xs:annotation>
          <xs:documentation>Always utilise the entry located in the preferred partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_NON_NULL">
        <xs:annotation>
          <xs:documentation>Utilise entries from the preferred partition if non-null, otherwise utilise entries from the other partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE_ALL">
        <xs:annotation>
          <xs:documentation>If a conflict is encountered for a given key, remove all versions of that key.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- JGroups extension attributes -->
  <xs:attribute name="stack.combine" default="COMBINE">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="COMBINE">
          <xs:annotation>
            <xs:documentation>Combines the protocol attributes, overriding any that have been set in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_AFTER">
          <xs:annotation>
            <xs:documentation>Inserts the protocol after/above an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_ABOVE">
          <xs:annotation>
            <xs:documentation>Inserts the protocol after/above an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_BEFORE">
          <xs:annotation>
            <xs:documentation>Inserts the protocol before/below an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_BELOW">
          <xs:annotation>
            <xs:documentation>Inserts the protocol before/below an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REPLACE">
          <xs:annotation>
            <xs:documentation>Replaces the protocol in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REMOVE">
          <xs:annotation>
            <xs:documentation>Removes the protocol from the stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>

  <xs:attribute name="stack.position" type="xs:string" />

  <xs:simpleType name="bias-acquisition">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NEVER">
        <xs:annotation>
          <xs:documentation>The bias is never acquired.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ON_WRITE">
        <xs:annotation>
          <xs:documentation>Bias is acquired by the writing entry.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="touch-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>Delay read operations until the other owners confirm updating the timestamp of the
            entry.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>
            Send touch commands to other owners, but do not wait for their confirmation.
            This allows read operations to return the value of a key even if another node has started
            expiring it.
            When that happens, the read won't extend the lifespan of the key.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="xsite-merge-policy">
    <xs:union memberTypes="tns:xsite-merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="xsite-merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>In case of conflict, it chooses the entry for the site's name with lower lexicographically
            order.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFER_NON_NULL">
        <xs:annotation>
          <xs:documentation>In case of conflict and one of the entries is null, it chooses the non-null entry. If both
            non-null, it uses the DEFAULT.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFER_NULL">
        <xs:annotation>
          <xs:documentation>In case of conflict and one of the entries is null, it chooses the null entry. If both
            non-null, it uses the DEFAULT.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALWAYS_REMOVE">
        <xs:annotation>
          <xs:documentation>In case of any conflict, the entry is removed from both sites.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="xsite-state-transfer-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>
            Users must bring backup locations online and initiate state
            transfer between remote sites.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AUTO">
        <xs:annotation>
          <xs:documentation>
            Backup locations that use the asynchronous backup strategy can
            automatically come back online. State transfer operations begin
            when the remote site connections are stable.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>
