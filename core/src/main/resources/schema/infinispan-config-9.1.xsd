<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified"
           version="1.0" targetNamespace="urn:infinispan:config:9.1"
           xmlns:tns="urn:infinispan:config:9.1" xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:element name="infinispan" type="tns:infinispan">
    <xs:annotation>
      <xs:documentation>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="infinispan">
    <xs:all>
      <xs:element name="jgroups" type="tns:jgroups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines JGroups stacks.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="threads" type="tns:threads" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the threading subsystem.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="cache-container" type="tns:cache-container" minOccurs="1">
        <xs:annotation>
          <xs:documentation>Defines an embedded cache container.</xs:documentation>
        </xs:annotation>
        <xs:unique name="cache_id_unique">
          <xs:selector xpath="./tns:local-cache|./tns:local-cache-configuration|./tns:invalidation-cache|./tns:invalidation-cache-configuration|./tns:replicated-cache|./tns:replicated-cache-configuration|./tns:distributed-cache|./tns:distributed-cache-configuration" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
    </xs:all>
  </xs:complexType>
  <xs:complexType name="jgroups">
    <xs:annotation>
      <xs:documentation>
        Defines JGroups transport stacks.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="stack-file" minOccurs="1" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              Defines an individual JGroups stack, pointing to the file containing its definition.
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation><xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation><xs:documentation>Path of JGroups configuration file containing stack definition.</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="transport" type="xs:string" default="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
      <xs:annotation>
        <xs:documentation>Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="threads">
    <xs:annotation>
      <xs:documentation>
        The threading subsystem, used to declare manageable thread pools and resources.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="thread-factory" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread factory (implementing java.util.concurrent.ThreadFactory).  The "name" attribute is
                the bean name of the created thread factory.  The optional "priority" attribute may be used to specify
                the thread priority of created threads.  The optional "group-name" attribute specifies the name of a the
                thread group to create for this thread factory.

                The "thread-name-pattern" is the template used to create names for threads.  The following patterns
                may be used:

                 %% - emit a percent sign
                 %t - emit the per-factory thread sequence number
                 %g - emit the global thread sequence number
                 %f - emit the factory sequence number
                 %i - emit the thread ID
                 %G - emit the thread group name
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string" use="required" />
          <xs:attribute name="group-name" type="xs:string" use="optional"/>
          <xs:attribute name="thread-name-pattern" type="xs:string" use="optional" />
          <xs:attribute name="priority" type="xs:string" use="optional" />
        </xs:complexType>
      </xs:element>
      <xs:element name="blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue.  Such a thread pool has a core size and a queue with an
                upper bound.  When a task is submitted, if the number of running threads is less than the core size,
                a new thread is created.  Otherwise, the task is placed in queue.  If too many tasks are allowed to be
                submitted to this type of executor, an out of memory condition may occur.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The nested "keepalive-time" element may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string" use="optional"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="cached-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates new threads as needed, but
                will reuse previously constructed threads when they are available.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="scheduled-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates a single-threaded executor
                that can schedule commands to run after a given delay, or to
                execute periodically.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-container">
    <xs:sequence>
      <xs:element name="transport" type="tns:transport" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Overrides the transport characteristics for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:global-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures security for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serialization" type="tns:serialization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Specifies how data serialization will be performed by the cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="jmx" type="tns:jmx" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines JMX management details.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="global-state" type="tns:global-state" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the global state persistence configuration. If this element is not present, global state persistence will be disabled.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="local-cache" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="local-cache-configuration" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache-configuration" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache-configuration" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache-configuration" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache-configuration" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache configuration. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:any namespace="##other"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="aliases" type="tns:aliases">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="default-cache" type="xs:string">
      <xs:annotation>
        <xs:documentation>Indicates the default cache for this cache container</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="async-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="listener-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache listener notifications.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>DEPRECATED Defines the scheduled executor used for evictions.  The expiration-executor type should be used instead.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiration-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the scheduled executor used for expirations.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistence-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used when interacting with the persistent store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state-transfer-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used when applying state from other nodes during the state transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string" default="org.jboss.as.clustering.infinispan">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shutdown-hook" type="tns:shutdown-hook-behavior">
      <xs:annotation>
        <xs:documentation>
          Behavior of the JVM shutdown hook registered by the cache
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transport">
    <xs:attribute name="stack" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the jgroups stack used by the transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the name for the underlying group communication cluster.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="executor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous transport communication.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote-command-executor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used to execute remote commands. Use org.infinispan.executors.WithinThreadExecutorFactory to disable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lock-timeout" type="xs:long" default="240000">
      <xs:annotation>
        <xs:documentation>
          Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
          This constraint is in place because more than one cache could be involved in a transaction.
          This timeout controls the time to wait to acquire a distributed lock.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="node-name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Name of the current node. This is a friendly name to make logs, etc. make more sense. Defaults to a combination of host name and a random number (to differentiate multiple nodes on the same host)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="machine" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the machine where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rack" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the rack where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="site" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the site where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The minimum number of nodes that must join the cluster for the cache manager to start
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
              <xs:element name="identity-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the identity role mapper where principal names are converted as-is into role names.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="common-name-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="cluster-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the cluster role mapper which stores the principal to role mappings within the cluster registry.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="custom-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses a custom role mapper.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="class" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Class of the custom principal to role mapper
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:element name="role" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Defines a new role name and assigns permissions to it.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" use="required" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>
                      Defines the name of the role.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="permissions" use="required" type="tns:permission-list">
                  <xs:annotation>
                    <xs:documentation>
                      Defines the list of permissions for the role.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="audit-logger" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the audit logger.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="serialization">
    <xs:sequence>
      <xs:element name="advanced-externalizer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            AdvancedExternalizer provides an alternative way to provide externalizers for marshalling/unmarshalling user defined classes that overcome the deficiencies of the more user-friendly externalizer definition  model explained in Externalizer.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="id" type="xs:int">
            <xs:annotation>
              <xs:documentation>
                Id of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="marshaller" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string" default="71">
      <xs:annotation>
        <xs:documentation>
          Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jmx">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A jmx property with name and value to be passed to the MBean Server lookup instance.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="domain" type="xs:string" default="${GlobalJmxStatistics.jmxDomain}">
      <xs:annotation>
        <xs:documentation>
          If JMX statistics are enabled then all 'published' JMX objects will appear under this name. This is optional, if not specified an object name will be created for you by default.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mbean-server-lookup" type="xs:string" default="${GlobalJmxStatistics.mBeanServerLookup}">
      <xs:annotation>
        <xs:documentation>
          Class that will attempt to locate a JMX MBean server to bind to. Defaults to using the platform MBean server.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="duplicate-domains" type="xs:boolean" default="${GlobalJmxStatistics.allowDuplicateDomains}">
      <xs:annotation>
        <xs:documentation>
          If true, multiple cache manager instances could be configured under the same configured JMX domain. Each cache manager will in practice use a different JMX domain that has been calculated based on the configured one by adding an incrementing index to it.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-state">
    <xs:sequence>
      <xs:element name="persistent-location" type="tns:global-state-path" minOccurs="1" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where persistent state data which needs to survive container restarts
            should be stored. The data stored at this location is required for graceful
            shutdown and restore. Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="temporary-location" type="tns:global-state-path" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where temporary state should be stored. Defaults to the value of the
            java.io.tmpdir system property.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="global-state-path">
    <xs:attribute name="relative-to" type="xs:string" default="jboss.server.data.dir">
        <xs:annotation>
            <xs:documentation>Ignored in embedded mode.</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Defines the path where global state for this cache-container will be stored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cache" abstract="true">
    <xs:sequence>
      <xs:element name="backups" type="tns:backups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="backup-for" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Configures this cache as a backup for a remote cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="remote-cache" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                The name of the remote cache that backups data here.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remote-site" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                The name of the remote site containing the cache that backups data here.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="locking" type="tns:locking" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The locking configuration of the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="transaction" type="tns:transaction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache transaction configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="eviction" type="tns:eviction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache eviction configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expiration" type="tns:expiration" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache expiration configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="compatibility" type="tns:compatibility" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache compatibility mode configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store-as-binary" type="tns:store-as-binary" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures the cache to store data in binary format.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="persistence" type="tns:persistence" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures the cache's persistence layer.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="versioning" type="tns:versioning" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="data-container" type="tns:data-container" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls the data container for the cache.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="memory" type="tns:memory" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls how the entries are stored in memory
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="indexing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines indexing options for cache
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="indexed-entities" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>Defines the indexed entity classes</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="indexed-entity" type="xs:string" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>Indexed entity class name</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Property to pass on to the indexing system</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="index" type="tns:indexing" default="${Indexing.index}">
            <xs:annotation>
              <xs:documentation>The indexing mode of the cache. Defaults to NONE.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="auto-config" type="xs:boolean" default="${Indexing.autoConfig}" use="optional">
            <xs:annotation>
              <xs:documentation>Whether or not to apply automatic index configuration based on cache type</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="custom-interceptors" type="tns:custom-interceptors" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures custom interceptors to be added to the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:cache-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures cache-level security.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:ID" use="required">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache within its cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configuration" type="xs:IDREF">
      <xs:annotation>
        <xs:documentation>The name of the cache configuration which this configuration inherits from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="${JMXStatistics.enabled}">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics-available" type="xs:boolean" default="${JMXStatistics.available}">
      <xs:annotation>
        <xs:documentation>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="deadlock-detection-spin" type="xs:long" default="${DeadlockDetection.spinDuration}">
      <xs:annotation>
        <xs:documentation>
          Deprecated since 9.0, deadlock detection is always disabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unreliable-return-values" type="xs:boolean" default="${Unsafe.unreliable-return-values}">
      <xs:annotation>
        <xs:documentation>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="local-cache">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:attribute name="simple-cache" default="${Configuration.simpleCache}">
          <xs:annotation>
            <xs:documentation>
              This cache will be using optimized (faster) implementation that does not support transactions/invocation batching, persistence, custom interceptors, indexing, store-as-binary or compatibility. Also, this type of cache does not support Map-Reduce jobs or Distributed Executor framework.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="locking">
    <xs:attribute name="isolation" type="tns:isolation" default="${Locking.isolationLevel}">
      <xs:annotation>
        <xs:documentation>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="striping" type="xs:boolean" default="${Locking.striping}">
      <xs:annotation>
        <xs:documentation>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquire-timeout" type="xs:long" default="${Locking.lockAcquisitionTimeout}">
      <xs:annotation>
        <xs:documentation>Maximum time to attempt a particular lock acquisition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="concurrency-level" type="xs:int" default="${Locking.concurrencyLevel}">
      <xs:annotation>
        <xs:documentation>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="write-skew" type="xs:boolean" default="${Locking.writeSkewCheck}">
      <xs:annotation>
        <xs:documentation>
          (Deprecated) This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transaction">
    <xs:attribute name="mode" type="tns:transaction-mode" default="NONE">
      <xs:annotation>
        <xs:documentation>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stop-timeout" type="xs:long" default="${Transaction.stop-timeout}">
      <xs:annotation>
        <xs:documentation>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="locking" type="tns:locking-mode" default="${Transaction.locking}">
      <xs:annotation>
        <xs:documentation>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transaction-manager-lookup" type="xs:string" default="${Transaction.transaction-manager-lookup}">
      <xs:annotation>
        <xs:documentation>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="complete-timeout" type="xs:long" default="${Transaction.complete-timeout}">
      <xs:annotation>
        <xs:documentation>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reaper-interval" type="xs:long" default="${Transaction.reaper-wake-up-interval}">
      <xs:annotation>
        <xs:documentation>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto-commit" type="xs:boolean" default="${Transaction.auto-commit}">
      <xs:annotation>
        <xs:documentation>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="tns:transaction-protocol">
      <xs:annotation>
        <xs:documentation>
          Configures the commit protocol to use.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recovery-cache" type="xs:string" default="${Recovery.recoveryInfoCacheName}">
      <xs:annotation>
        <xs:documentation>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notifications" type="xs:boolean" default="${Transaction.notifications}">
      <xs:annotation>
        <xs:documentation>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="eviction">
    <xs:annotation>
      <xs:documentation>
        DEPRECATED: please use memory element instead
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="strategy" type="tns:eviction-strategy" default="${Eviction.strategy}">
      <xs:annotation>
        <xs:documentation>Sets the cache eviction strategy. Available options are 'UNORDERED', 'FIFO', 'LRU', 'LIRS' and 'NONE' (to disable eviction).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-entries" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>Deprecated since 8.1. Use the size attribute instead.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-policy" type="tns:eviction-thread-policy" default="${Eviction.threadPolicy}">
      <xs:annotation>
        <xs:documentation>
          Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="tns:eviction-type" default="${Eviction.type}">
      <xs:annotation>
        <xs:documentation>Specifies whether to use entry count or memory-based approximation to decide when to evict entries.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:long" default="${Eviction.size}">
      <xs:annotation>
        <xs:documentation>Maximum size to use for eviction. When using the COUNT type, this is the maximum number of entries in a cache instance. When using the MEMORY threshold policy, this is the maximum number of allocated bytes used by a cache's datacontainer. A value of -1 means no limit. This is currently limited to 2^48 - 1 in size.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="expiration">
    <xs:attribute name="max-idle" type="xs:long" default="${Expiration.maxIdle}">
      <xs:annotation>
        <xs:documentation>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lifespan" type="xs:long" default="${Eviction.size}">
      <xs:annotation>
        <xs:documentation>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="xs:long" default="${Expiration.wakeUpInterval}">
      <xs:annotation>
        <xs:documentation>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="compatibility">
    <xs:attribute name="marshaller" type="xs:string">
      <xs:annotation>
        <xs:documentation>A marshaller to use for compatibility conversions.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="store-as-binary">
    <xs:annotation>
      <xs:documentation>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
        DEPRECATED: please use memory element instead
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="keys" type="xs:boolean" default="${StoreAsBinary.keys}">
      <xs:annotation>
        <xs:documentation>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="values" type="xs:boolean" default="${StoreAsBinary.values}">
      <xs:annotation>
        <xs:documentation>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="persistence">
    <xs:choice minOccurs="0">
      <xs:element name="cluster-loader" type="tns:cluster-loader">
        <xs:annotation>
          <xs:documentation>Defines a cluster cache loader.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store" type="tns:custom-store">
        <xs:annotation>
          <xs:documentation>Defines a custom cache store.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="file-store" type="tns:file-store">
        <xs:annotation>
          <xs:documentation>Defines a file-based cache store.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" />
    </xs:choice>
    <xs:attribute name="passivation" type="xs:boolean" default="${Persistence.passivation}">
      <xs:annotation>
        <xs:documentation>
          If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-interceptors">
    <xs:sequence>
      <xs:element name="interceptor" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:sequence>
            <xs:element name="property" type="tns:property" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="after" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="before" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation><xs:documentation>A fully qualified class name of the new custom interceptor to add to the configuration.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="index" type="xs:int">
            <xs:annotation><xs:documentation>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="xs:string">
            <xs:annotation><xs:documentation>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures authorization for this cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="${Authorization.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roles" type="tns:role-list">
            <xs:annotation>
              <xs:documentation>
                Sets the valid roles required to access this cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="versioning">
    <xs:attribute name="scheme" type="tns:versioning-scheme" default="${Versioning.scheme}">
      <xs:annotation>
        <xs:documentation>
          (Deprecated) The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="data-container">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Properties passed to the data container</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="class" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the data container to use
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="key-equivalence" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the Equivalence class to use
          for keys stored in the cache, which provides with custom
          ways to compare cached keys
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value-equivalence" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          DEPRECATED: this is to be removed in a future release
          Fully qualified class name of the Equivalence class to use
          for values stored in the cache, which provides with custom
          ways to compare cached values
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element name="object" type="tns:memory-object">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as instance variables.  Instances of byte[] will be wrapped to ensure equality.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="binary" type="tns:memory-binary">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as byte[] instances.  Key and value will be serialized to binary representations.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="off-heap" type="tns:memory-off-heap">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as byte[] off of the Java heap.  Key and value will be serialized to binary
              representations and stored in native memory as to not take up Java heap.  Temporary objects will be
              put onto Java heap temporarily until processing is completed.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="memory-object">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>The size of the eviction cache as a long.  Limits the cache to this normal by the amount of
        entries in the cache.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-binary">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be
          how many entries can be stored.  If the configured type is MEMORY, this will be how much memory
          in bytes can be stored.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on
        the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-off-heap">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be
          how many entries can be stored.  If the configured type is MEMORY, this will be how much memory
          in bytes can be stored.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on
          the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="address-count" type="xs:int" default="1048576">
      <xs:annotation>
        <xs:documentation>How many address pointers to use. This number will be rounded up to a power of two.
          For optimal performance you will want more address pointers than you expect to have entries.  This is similar
          to the size of an array backing a hash map.  Without collisions lookups and writes will be constant time.
          Each pointer will take up 8 bytes of memory thus the default will use 8 MB of off-heap memory.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="clustered-cache" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:sequence>
          <xs:element name="partition-handling" minOccurs="0" maxOccurs="1">
             <xs:annotation>
                <xs:documentation>
                   Configures the way this cache reacts to node crashes and split brains.
                </xs:documentation>
             </xs:annotation>
             <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean" use="optional">
                   <xs:annotation>
                      <xs:documentation>
                         Deprecated, use type instead. Enable/disable the partition handling functionality. Defaults to false.
                      </xs:documentation>
                   </xs:annotation>
                </xs:attribute>
               <xs:attribute name="when-split" type="tns:partition-handling-type" default="${PartitionHandling.whenSplit}">
                 <xs:annotation>
                   <xs:documentation>The type of actions that are possible when a split brain scenario is encountered.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
               <xs:attribute name="merge-policy" type="tns:merge-policy" default="NONE">
                 <xs:annotation>
                   <xs:documentation>The entry merge policy which should be applied on partition merges.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
             </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="mode" type="tns:mode" default="SYNC">
          <xs:annotation>
            <xs:documentation>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="remote-timeout" type="xs:long" default="${Clustering.remoteTimeout}">
          <xs:annotation>
            <xs:documentation>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="invalidation-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="replicated-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="distributed-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="owners" type="xs:int" default="${Hash.numOwners}">
          <xs:annotation>
            <xs:documentation>Number of cluster-wide replicas for each cache entry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity-factor" type="xs:double" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>Controls the proportion of entries that will reside on the local node,
              compared to the other nodes in the cluster. Value must be positive. The default is 1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-lifespan" type="xs:long">
          <xs:annotation>
            <xs:documentation>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
               By default L1 is disabled unless a positive value is configured for this attribute.
               If the attribute is not present, L1 is disabled.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-cleanup-interval" type="xs:long" default="${L1.cleanupTaskFrequency}">
          <xs:annotation>
            <xs:documentation>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="scattered-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="256">
          <xs:annotation>
            <xs:documentation>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="1">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="invalidation-batch-size" type="xs:integer" default="128">
          <xs:annotation>
            <xs:documentation>
              Threshold for sending batch invalidations. Once a node registers more updated keys,
              it sends a batch invalidation to all nodes requesting to remove old versions of the entries.
              The threshold is also used for second batch invalidation of tombstones for removed entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loader" abstract="true">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A cache loader property with name and value.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cluster-loader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="remote-timeout" type="xs:long" default="${ClusterLoader.remoteCallTimeout}">
          <xs:annotation>
            <xs:documentation>The timeout when performing remote calls.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="store" abstract="true">
    <xs:sequence>
      <xs:element name="write-behind" type="tns:write-behind" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>Configures a cache store as write-behind instead of write-through.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A cache store property with name and value.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactional" type="xs:boolean" default="${AbstractStore.transactional}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and cache's transactions rollingback.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fetch-state" type="xs:boolean" default="${AbstractStore.fetchPersistentState}">
      <xs:annotation>
        <xs:documentation>If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="purge" type="xs:boolean" default="${AbstractStore.purgeOnStartup}">
      <xs:annotation>
        <xs:documentation>If true, purges this cache store when it starts up.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="singleton" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If true, the singleton store cache store is enabled. SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. Deprecated: A shared store should be used instead, as this limits store writes to the primary owner of a key</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="read-only" type="xs:boolean" default="${AbstractStore.ignoreModifications}">
      <xs:annotation>
        <xs:documentation>If true, the cache store will only be used to load entries. Any modifications made to the caches will not be applied to the store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-batch-size" type="xs:int" default="${AbstractStore.maxBatchSize}">
      <xs:annotation>
        <xs:documentation>The maximum size of a batch to be inserted/deleted from the store. If the value is less than one, then no upper limit is placed on the number of operations in a batch.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="write-behind">
    <xs:attribute name="modification-queue-size" type="xs:int" default="${AsyncStore.modificationQueueSize}">
      <xs:annotation>
        <xs:documentation>
          Maximum number of entries in the asynchronous queue. When the queue is full, the store becomes write-through.
          until it can accept new entries
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="${AsyncStore.threadPoolSize}">
      <xs:annotation>
        <xs:documentation>
          Size of the thread pool whose threads are responsible for applying the modifications to the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="class" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>The class name of the cache store implementation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="file-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="max-entries" type="xs:int">
          <xs:annotation>
            <xs:documentation>
              Sets the maximum number of in-memory mappings between keys and their position in the store.
              Normally this is unlimited, but to avoid excess memory usage, an upper bound can be configured.
              If this limit is exceeded, entries are removed permanently using the LRU algorithm both from
              the in-memory index and the underlying file based cache store. Warning: setting this value
              may cause data loss.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="relative-to" type="xs:string">
          <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The path within "relative-to" in which to store the cache state.
              If undefined, the path defaults to the cache container name.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="remote-server">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The hostname or ip address of a remote Hot Rod server
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:int" default="11222">
      <xs:annotation>
        <xs:documentation>
          The port on which the server is listening (default 11222)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outbound-socket-binding" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="state-transfer">
    <xs:attribute name="enabled" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${StateTransfer.timeout}">
      <xs:annotation>
        <xs:documentation>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunk-size" type="xs:integer" default="${StateTransfer.chunkSize}">
      <xs:annotation>
        <xs:documentation>The number of cache entries to batch in each transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="await-initial-transfer" type="xs:boolean" default="${StateTransfer.awaitInitialTransfer}">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="groups">
    <xs:sequence>
      <xs:element name="grouper" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="enabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Enables or disables grouping.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backups">
    <xs:sequence>
      <xs:element name="backup" type="tns:backup" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Configures a specific site where this cache backups data.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="backup">
    <xs:sequence>
      <xs:element name="take-offline" type="tns:take-offline" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Determines whether this backup is taken offline (ignored) after a certain number of tries.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="state-transfer" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the properties needed to transfer the state for this site.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="chunk-size" type="xs:int" default="512">
            <xs:annotation>
              <xs:documentation>
                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="xs:long" default="1200000">
            <xs:annotation>
              <xs:documentation>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max-retries" type="xs:int" default="30">
            <xs:annotation>
              <xs:documentation>
                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                the command will not retry. Default value is 30.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wait-time" type="xs:long" default="2000">
            <xs:annotation>
              <xs:documentation>
                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                value is 2 seconds.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="site" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Name of the remote site where this cache backups data.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:mode" default="${Backup.strategy}">
      <xs:annotation>
        <xs:documentation>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy" type="tns:backup-failure-policy" default="${Backup.backupFailurePolicy}">
      <xs:annotation>
        <xs:documentation>Decides what the system would do in case of failure during backup. Defaults to "WARN"</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${Backup.replicationTimeout}">
      <xs:annotation>
        <xs:documentation>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${Backup.enabled}">
      <xs:annotation>
        <xs:documentation>If 'false' then no data is backed up to this site. Defaults to 'true'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="two-phase-commit" use="optional" type="xs:boolean" default="${Backup.useTwoPhaseCommit}">
      <xs:annotation>
        <xs:documentation>
          Configures whether the replication happens in a 1PC or 2PC when using SYNC backup strategy. Defaults to "${Backup.useTwoPhaseCommit}".
          CacheConfigurationException is thrown when used with ASYNC backup strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy-class" use="optional" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
          required and should
          contain the fully qualified name of a class implementing
          org.infinispan.xsite.CustomFailurePolicy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="take-offline">
    <xs:attribute name="after-failures" type="xs:int" default="0">
      <xs:annotation>
        <xs:documentation>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-wait" type="xs:long" default="0">
      <xs:annotation>
        <xs:documentation>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="property">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the name of a property.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="isolation">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_UNCOMMITTED">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures READ_COMMITTED</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_COMMITTED">
        <xs:annotation>
          <xs:documentation>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REPEATABLE_READ">
        <xs:annotation>
          <xs:documentation>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SERIALIZABLE">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures REPEATABLE_READ</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Cache will not enlist within transactions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BATCH">
        <xs:annotation>
          <xs:documentation>Uses batching to group cache operations together.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.Synchronization</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_DURABLE_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FULL_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="indexing">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not index data. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LOCAL">
        <xs:annotation>
          <xs:documentation>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>Index all data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PRIMARY_OWNER">
        <xs:annotation>
          <xs:documentation>Only index changes on the primary owner, regardless of it's local or remote.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-strategy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Never evict entries. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNORDERED">
        <xs:annotation>
          <xs:documentation>Actually activates LRU.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIFO">
        <xs:annotation>
          <xs:documentation>Deprecated. Actually activates LRU.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LRU">
        <xs:annotation>
          <xs:documentation>Least-Recently Used policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIRS">
        <xs:annotation>
          <xs:documentation>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>Eviction will be performed manually. Equivalent internally to NONE.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>Enables asynchronous mode.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>Enables synchronous mode.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="locking-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="OPTIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Optimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PESSIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Pessimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="aliases">
    <xs:annotation>
      <xs:documentation>A list of aliases.</xs:documentation>
    </xs:annotation>
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="backup-failure-policy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="IGNORE">
        <xs:annotation>
          <xs:documentation>Ignore backup failures.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARN">
        <xs:annotation>
          <xs:documentation>Warn of backup failures.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FAIL">
        <xs:annotation>
          <xs:documentation>Fail local operations when a backup failure occurs.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CUSTOM">
        <xs:annotation>
          <xs:documentation>Invoke a user-specified failure policy (set via the failure-policy-class attribute)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdown-hook-behavior">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REGISTER">
        <xs:annotation>
          <xs:documentation>Register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DONT_REGISTER">
        <xs:annotation>
          <xs:documentation>Don't register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-protocol">
    <xs:annotation>
      <xs:documentation>
        Enumeration containing the available commit protocols
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT" />
      <xs:enumeration value="TOTAL_ORDER" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-thread-policy">
    <xs:restriction base="xs:string">
      <xs:enumeration value="PIGGYBACK">
        <xs:annotation>
          <xs:documentation>Fires the eviction events from the same thread which is performing the eviction </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>Use the default eviction listener thread policy (PIGGYBACK)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="COUNT">
        <xs:annotation>
          <xs:documentation>Evicts entries from the cache when a specified count has been set</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MEMORY">
        <xs:annotation>
          <xs:documentation>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="versioning-scheme">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIMPLE">
        <xs:annotation>
          <xs:documentation>
            A simple versioning scheme that is cluster-aware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Don't version entries
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="permission-list">
    <xs:list itemType="tns:permission"/>
  </xs:simpleType>

  <xs:simpleType name="permission">
    <xs:restriction base="xs:string">
      <xs:enumeration value="LIFECYCLE">
        <xs:annotation>
          <xs:documentation>
            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ">
        <xs:annotation>
          <xs:documentation>
            Allows reading data from a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows writing data to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXEC">
        <xs:annotation>
          <xs:documentation>
            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LISTEN">
        <xs:annotation>
          <xs:documentation>
            Allows attaching listeners to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_READ">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-read operations (e.g. obtaining all the keys in a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-write operations (e.g. clearing a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ADMIN">
        <xs:annotation>
          <xs:documentation>
            Allows performing "administrative" operations on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all of the others
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_READ">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all read permissions (READ and BULK_READ)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_WRITE">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Permission which means no permissions
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="role-list">
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="partition-handling-type">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DENY_READ_WRITES">
        <xs:annotation>
          <xs:documentation>If the partition does not have all owners for a given segment, both reads and writes are denied for all keys in that segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READS">
        <xs:annotation>
          <xs:documentation>Allows reads for a given key if it exists in this partition, but only allows writes if this partition contains all owners of a segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READ_WRITES">
        <xs:annotation>
          <xs:documentation>Allow entries on each partition to diverge, with conflicts resolved during merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="merge-policy">
    <xs:union memberTypes="tns:merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not attempt to resolve conflicts on merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_ALWAYS">
        <xs:annotation>
          <xs:documentation>Always utilise the entry located in the preferred partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_NON_NULL">
        <xs:annotation>
          <xs:documentation>Utilise entries from the preferred partition if non-null, otherwise utilise entries from the other partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE_ALL">
        <xs:annotation>
          <xs:documentation>If a conflict is encountered for a given key, remove all versions of that key.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

</xs:schema>

