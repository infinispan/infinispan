<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified"
           version="1.1" targetNamespace="urn:infinispan:config:15.2"
           xmlns:tns="urn:infinispan:config:15.2"
           xmlns:jgroups="urn:org:jgroups"
           xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:import namespace="urn:org:jgroups" schemaLocation="http://www.jgroups.org/schema/jgroups-5.3.xsd"/>

  <xs:element name="infinispan" type="tns:infinispan">
    <xs:annotation>
      <xs:documentation>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="infinispan">
    <xs:sequence>
      <xs:element name="jgroups" type="tns:jgroups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines JGroups stacks.</xs:documentation>
        </xs:annotation>
        <xs:unique name="stack_id_unique">
          <xs:selector xpath="./tns:stack|./tns:stack-file" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:element name="threads" type="tns:threads" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the threading subsystem.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="cache-container" type="tns:cache-container">
        <xs:annotation>
          <xs:documentation>Defines an embedded cache container.</xs:documentation>
        </xs:annotation>
        <xs:unique name="cache_id_unique">
          <xs:selector xpath="./tns:local-cache|./tns:local-cache-configuration|./tns:invalidation-cache|./tns:invalidation-cache-configuration|./tns:replicated-cache|./tns:replicated-cache-configuration|./tns:distributed-cache|./tns:distributed-cache-configuration" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="jgroups">
    <xs:annotation>
      <xs:documentation>
        Defines JGroups transport stacks.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="stack-file" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              Defines an individual JGroups stack, pointing to the file containing its definition.
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Name of the stack, to be referenced by transport's stack attribute.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Path of JGroups configuration file containing stack definition.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="stack" type="tns:jgroups-stack" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="transport" type="xs:string" default="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
      <xs:annotation>
        <xs:documentation>Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jgroups-stack">
    <xs:complexContent>
      <xs:extension base="jgroups:ConfigType">
        <xs:sequence>
          <xs:element name="remote-sites" type="tns:jgroups-remote-sites" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Defines the relay configuration.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="extends" type="xs:string">
          <xs:annotation>
            <xs:documentation>The base stack to extend.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jgroups-remote-sites">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="remote-site" type="tns:jgroups-stack-relay-remote-site" />
    </xs:sequence>
    <xs:attribute name="default-stack" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Defines the name of the JGroups stack to be used by default when connecting to remote sites.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string" default="xsite">
      <xs:annotation>
        <xs:documentation>Defines the default cluster name for remote clusters.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jgroups-stack-relay-remote-site">
    <xs:attribute name="name" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Defines the name of the remote site.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stack" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the name of the JGroups stack to use to connect to the remote site. If unspecified, the default-stack will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the name for the underlying group communication cluster. If unspecified, the remote-sites.cluster name will be used.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="threads">
    <xs:annotation>
      <xs:documentation>
        The threading subsystem, used to declare manageable thread pools and resources.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="thread-factory" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread factory (implementing java.util.concurrent.ThreadFactory).  The "name" attribute is
                the bean name of the created thread factory.  The optional "priority" attribute may be used to specify
                the thread priority of created threads.  The optional "group-name" attribute specifies the name of a the
                thread group to create for this thread factory.

                The "thread-name-pattern" is the template used to create names for threads.  The following patterns
                may be used:

                 %% - emit a percent sign
                 %t - emit the per-factory thread sequence number
                 %g - emit the global thread sequence number
                 %f - emit the factory sequence number
                 %i - emit the thread ID
                 %G - emit the thread group name
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string" use="required"/>
          <xs:attribute name="group-name" type="xs:string"/>
          <xs:attribute name="thread-name-pattern" type="xs:string"/>
          <xs:attribute name="priority" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue which can run blocking operations.
                Such a thread pool has a core size and a queue with an upper bound.
                When a task is submitted, if the number of running threads is less than the core size, a new thread is created.
                Otherwise, the task is placed in queue.
                If too many tasks are allowed to be submitted to this type of executor, an out of memory condition may occur.
                If the queue is too small it may cause a CacheBackpressureFullException to be thrown if a non-blocking thread cannot submit a task.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The "keepalive-time" attribute may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
              ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="non-blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue which should only run non blocking operations.
                Such a thread pool has a core size and a queue with an upper bound.
                When a task is submitted, if the number of running threads is less than the core size, a new thread is created.
                Otherwise, the task is placed in queue.
                If too many tasks are allowed to be submitted to this type of executor, an out of memory condition may occur.
                If the queue is too small it may cause blocking thread pool tasks to build up waiting to submit.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The "keepalive-time" attribute may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="cached-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates new threads as needed, but
                will reuse previously constructed threads when they are available.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="scheduled-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates a single-threaded executor
                that can schedule commands to run after a given delay, or to
                execute periodically.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-container">
    <xs:sequence>
      <xs:element name="transport" type="tns:transport" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Overrides the transport characteristics for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:global-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures security for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serialization" type="tns:serialization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Specifies how data serialization will be performed by the cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="metrics" type="tns:metrics" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures metrics.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="tracing" type="tns:tracing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures tracing, can be collected by an OpenTelemetry collector.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="jmx" type="tns:jmx" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables and configures JMX monitoring and management.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="global-state" type="tns:global-state" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the global state persistence configuration. If this element is not present, global state persistence will be disabled.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="local-cache" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="local-cache-configuration" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache-configuration" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache-configuration" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache-configuration" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="default-cache" type="xs:string">
      <xs:annotation>
        <xs:documentation>Indicates the default cache for this cache container</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zero-capacity-node" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If 'true' then no data is stored in this node. Defaults to 'false'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="listener-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache listener notifications.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiration-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the scheduled executor used for expirations.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="non-blocking-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the executor used for non-blocking operations. Must be non-blocking and must have a queue.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="blocking-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>The name of the executor used for blocking operations. Must be blocking and must have a queue.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string" default="org.jboss.as.clustering.infinispan">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shutdown-hook" type="tns:shutdown-hook-behavior">
      <xs:annotation>
        <xs:documentation>
          Behavior of the JVM shutdown hook registered by the cache
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transport">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A transport property with name and value to be passed to the Transport instance.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="stack" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the jgroups stack used by the transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the name for the underlying group communication cluster.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lock-timeout" type="xs:long" default="240000">
      <xs:annotation>
        <xs:documentation>
          Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
          This constraint is in place because more than one cache could be involved in a transaction.
          This timeout controls the time to wait to acquire a distributed lock.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="node-name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the name of the current node. Defaults to a combination of the host name and a random number to differentiate between multiple nodes on the same host.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="machine" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the ID of the machine where the node runs. When a single physical machine hosts multiple JVM instances, the machine ID ensures that data is distributed across different physical hosts.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rack" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the ID of the rack where the node runs. The rack ID ensures that the copies of data are stored on different rack than the original data.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="site" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The ID of the site where the node runs.In clusters with nodes in multiple physical locations site ID ensures that backup copies of data are stored across different locations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The minimum number of nodes that must join the cluster for the cache manager to start
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="raft-members" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The list of raft members separated by space.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:anyAttribute/>
  </xs:complexType>

  <xs:complexType name="global-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0">
              <xs:element name="cluster-permission-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Stores role to permission mappings in the cluster registry.
                    This role mapper is enabled by default in the server configuration.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="custom-permission-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Configures a custom permission mapper implementation.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="class" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Specifies the class name of a custom implementation that maps roles to permissions.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:choice minOccurs="0">
              <xs:element name="identity-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the identity role mapper where principal names are converted as-is into role names.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="common-name-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="cluster-role-mapper" type="tns:cluster-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Stores the principal to role mappings in the cluster registry.
                    This role mapper is enabled by default in the server configuration.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="custom-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Configures a custom role mapper.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="class" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Specifies the class name of a custom principal to role mapper implementation.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:element name="roles" type="tns:roles" minOccurs="0" />
          </xs:sequence>
          <xs:attribute name="audit-logger" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the audit logger.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="group-only-mapping" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                Specifies whether principal-to-role mapping applies only to group principals or also to user principals. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="cache-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The ACL cache size. The default is 1000 entries. A value of 0 disables the cache.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cache-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The ACL cache timeout in milliseconds. The default is 300000 (5 minutes). A value of 0 disables the cache.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cluster-role-mapper">
    <xs:sequence>
      <xs:element type="tns:name-rewriter" name="name-rewriter" minOccurs="0"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="name-rewriter">
    <xs:annotation>
      <xs:documentation>
        Specifies a name rewriter that transforms names returned by a realm.
      </xs:documentation>
    </xs:annotation>
    <xs:choice>
      <xs:element type="tns:regex-principal-transformer" name="regex-principal-transformer"/>
    </xs:choice>
  </xs:complexType>

  <xs:complexType name="principal-transformer" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Specifies the base type for all PrincipalTransformer definitions.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Deprecated. Will be ignored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="regex-principal-transformer">
    <xs:annotation>
      <xs:documentation>
        Specifies a PrincipalTransformer definition using regular expressions and Matcher based replacement.
      </xs:documentation>
    </xs:annotation>
    <xs:complexContent>
      <xs:extension base="tns:principal-transformer">
        <xs:attribute name="pattern" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              Specifies the regular expression for this PrincipalTransformer.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="replacement" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>
              Specifies the replacement string for the PrincipalTransformer.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="replace-all" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation>
              Replaces all occurrences instead of the first occurrence.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="roles">
    <xs:sequence>
      <xs:element name="role" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Defines a new role name and assigns permissions to it.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="name" use="required" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Defines the name of the role.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="description" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Defines the description of the role.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="permissions" use="required" type="tns:permission-list">
            <xs:annotation>
              <xs:documentation>
                Defines the list of permissions for the role.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="serialization">
    <xs:sequence>
      <xs:element name="context-initializer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            SerializationContextInitializer implementation which is used to initialize a ProtoStream based marshaller
            for user types. If no &lt;context-initializer&gt; elements are present then the java.util.ServiceLoader
            mechanism will be used to automatically discover all SerializationContextInitializer implementations present
            in classpath and load them.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the SerializationContextInitializer implementation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="allow-list" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables individual classes or regular expressions to be added to the EmbeddedCacheManager allow list.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="class" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  FQN of the class to be added to the allowlist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="regex" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Regex pattern used to determine if a class is a member of the allowlist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="marshaller" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string" default="71">
      <xs:annotation>
        <xs:documentation>
          Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="schema-compatibility" type="tns:schema-compatibility" default="STRICT">
      <xs:annotation>
        <xs:documentation>
          The kind of compatibility validation that is performed when updating schemas.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="metrics">
    <xs:attribute name="gauges" type="xs:boolean" default="${GlobalMetrics.gauges}">
      <xs:annotation>
        <xs:documentation>
          Exports gauge metrics. Gauges are enabled by default but you must
          enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="histograms" type="xs:boolean" default="${GlobalMetrics.histograms}">
      <xs:annotation>
        <xs:documentation>
          Exports histogram metrics. Histograms are not enabled by default
          because they require additional computation. If you enable histograms
          you must also enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies a global name prefix for metrics.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="names-as-tags" type="xs:boolean" default="${GlobalMetrics.names-as-tags}">
      <xs:annotation>
        <xs:documentation>
          Put the cache manager and cache name in tags rather than include them in the metric name.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="accurate-size" type="xs:boolean" default="${GlobalMetrics.accurate-size}">
      <xs:annotation>
        <xs:documentation>
          Enables accurate size computation for numberOfEntries statistics. Note that this doesn't affect invocations of
          Cache#size() method.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="tracing">
    <xs:attribute name="collector-endpoint" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Enables tracing collection defining the collector that will receive the spans created by Infinispan.
          The value is supposed to be a valid parsable URL containing the protocol,
          the address and the port of the remote receiving process.
          E.g., http://otlp-collector-host:4317.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${GlobalTracing.enabled}">
      <xs:annotation>
        <xs:documentation>
          Tracing is enabled by default if "collector-endpoint" is defined.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="exporter-protocol" type="tns:tracing-exporter-protocol" default="${GlobalTracing.exporter-protocol}">
      <xs:annotation>
        <xs:documentation>
          By default, the tracing spans will be exported applying the OTLP (OpenTelemetry Protocol).
          This protocol can be changed, but an extra exporter dependency should be added in case.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="service-name" type="xs:string" default="${GlobalTracing.service-name}">
      <xs:annotation>
        <xs:documentation>
          The service name used by tracing to identify the server process.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="security" type="xs:boolean" default="${GlobalTracing.security}">
      <xs:annotation>
        <xs:documentation>
          If true, it allows to trace security events. False by default.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jmx">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Specifies a JMX property with a name and value that is passed to
            the MBean Server lookup instance.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="domain" type="xs:string" default="${GlobalJmx.domain}">
      <xs:annotation>
        <xs:documentation>
          If JMX statistics are enabled then all 'published' JMX objects appear
          under this domain. Optional, if not specified it defaults to
          "org.infinispan".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mbean-server-lookup" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Class that attempts to locate a JMX MBean server to bind to. Defaults
          to the platform MBean server.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${GlobalJmx.enabled}">
      <xs:annotation>
        <xs:documentation>
          Enables exporting of JMX MBeans.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-state">
    <xs:sequence>
      <xs:element name="persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where persistent state data which needs to survive container restarts
            should be stored. The data stored at this location is required for graceful
            shutdown and restore. This path must NOT be shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="shared-persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where shared persistent state data which needs to survive container restarts
            should be stored. This path can be safely shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="temporary-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where temporary state should be stored. Defaults to the value of the
            java.io.tmpdir system property.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0">
        <xs:element name="immutable-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              An immutable configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="volatile-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A non-persistent configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="overlay-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage which saves runtime configurations to the persistent-location.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="managed-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage for managed environments. This doesn't work in embedded mode.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="custom-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              Uses a custom configuration storage implementation.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="class" type="xs:string">
              <xs:annotation>
                <xs:documentation>
                  Class of the custom configuration storage implementation.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="unclean-shutdown-action" type="tns:unclean-shutdown-action" default="${GlobalState.unclean-shutdown-action}">
      <xs:annotation>
        <xs:documentation>
          Defines the action taken when a dangling lock file is found in the persistent global state, signifying an
          unclean shutdown of the node (usually because of a crash or an external termination).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-state-path">
    <xs:attribute name="relative-to" type="xs:string" default="jboss.server.data.dir">
        <xs:annotation>
            <xs:documentation>A property name whose value will be used as the root path for storing global state</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Defines the path where global state for this cache-container will be stored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cache" abstract="true">
    <xs:sequence>
      <xs:element name="backups" type="tns:backups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines backup locations for cache data and modifies state transfer properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="backup-for" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the local cache as a backup for a remote cache with a different name.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="remote-cache" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote cache that uses the local cache as a backup.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remote-site" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote site that backs up data to the local cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="encoding" type="tns:encoding" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache encoding configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="locking" type="tns:locking" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The locking configuration of the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="transaction" type="tns:transaction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache transaction configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expiration" type="tns:expiration" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache expiration configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store-as-binary" type="tns:store-as-binary" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures the cache to store data in binary format.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="persistence" type="tns:persistence" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the persistence layer for caches.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="memory" type="tns:memory" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls how the entries are stored in memory
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="query" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines query options for cache
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="default-max-results" type="xs:integer" default="${Query.default-max-results}">
            <xs:annotation>
              <xs:documentation>
                Limits the number of results returned by a query. Applies to indexed, non-indexed, and hybrid queries.
                Setting the default-max-results significantly improves performance of queries that don't have an explicit limit set.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="hit-count-accuracy" type="xs:integer" default="${Query.hit-count-accuracy}">
            <xs:annotation>
              <xs:documentation>
                Limit the required accuracy of the hit count for the indexed queries to an upper-bound.
                Setting the hit-count-accuracy optimize the performance of queries targeting large data sets.
                For optimal results, set this value slightly above the expected hit count.
                If you do not require accurate hit counts, set it to a low value.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="indexing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines indexing options for cache
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="index-reader" type="tns:index-reader" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Controls index reading parameters.</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="index-writer" type="tns:index-writer" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Controls index writing parameters</xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="index-sharding" type="tns:index-sharding" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Sharding consists in splitting index data into multiple "smaller indexes", called shards,
                  in order to improve performance when dealing with large amounts of data.
                  By default, sharding is disabled.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="key-transformers" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Defines the Transformers used to stringify keys for indexing with Lucene</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="key-transformer" minOccurs="0" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:annotation>
                        <xs:documentation>Defines the Transformer to use for the specified key class</xs:documentation>
                      </xs:annotation>
                      <xs:attribute name="key" type="xs:string" use="required" />
                      <xs:attribute name="transformer" type="xs:string" use="required"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="indexed-entities" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Defines the set of indexed type names (fully qualified). If values of types that are not included in this set are put in the cache they will not be indexed.</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="indexed-entity" type="xs:string" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>Indexed entity type name. Must be either a fully qualified Java class name or a protobuf type name.</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="enabled" type="xs:boolean" default="${Indexing.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enables and disables cache indexing.
                Including the indexing element in cache configuration automatically enables indexing without the need to set the value of this attribute to "true".
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storage" type="tns:index-storage" default="filesystem">
            <xs:annotation>
              <xs:documentation>Specify index storage options.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="startup-mode" type="tns:startup-mode" default="none">
            <xs:annotation>
              <xs:documentation>
                Triggers an indexing process when the cache starts.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Specifies a filesystem path for the index when storage is 'filesystem'.
                The value can be a relative or absolute path. Relative paths are created
                relative to the configured global persistent location, or to the current
                working directory when global state is disabled.
                By default, the cache name is used as a relative path for index path.
                When setting a custom value, ensure that there are no conflicts between caches using the same indexed entities.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="indexing-mode" type="tns:indexing-mode" default="auto">
            <xs:annotation>
              <xs:documentation>
                Affects how cache operations will be propagated to the indexes.
                By default, all the changes to the cache will be immediately applied to the indexes.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="use-java-embedded-entities" type="xs:boolean" default="${Indexing.use-java-embedded-entities}">
            <xs:annotation>
              <xs:documentation>
                Whether true, the indexes will be defined on the Java indexed entities accessible from the class path of the server VM.
                Even if the cache is Protobuf encoded and the indexes are run in server mode.
                Useful in case we want to run embedded queries from a server task, in the case the cache is Protobuf encoded.
                By default, false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="tracing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures tracing for cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="${Tracing.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enable or disable tracing on the given cache.
                This property can be used to enable or disable tracing at runtime.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="categories" default="container" type="tns:tracing-category-list">
            <xs:annotation>
              <xs:documentation>
                <![CDATA[
                  Enable or disable tracing for the categories defined in the list.
                  This property can be used to enable or disable tracing at runtime,
                  enabling / disabling specific categories for a given cache.
                ]]>
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="custom-interceptors" type="tns:custom-interceptors" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.
             Configures custom interceptors to be added to the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:cache-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures cache-level security.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:ID" use="required">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache within its cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configuration" type="xs:IDREF">
      <xs:annotation>
        <xs:documentation>The name of the cache configuration which this configuration inherits from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="aliases" type="tns:string-list" default="">
      <xs:annotation>
        <xs:documentation>Zero or more cache alias names.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="${Statistics.statistics}">
      <xs:annotation>
        <xs:documentation>Determines whether the cache should collect statistics. Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unreliable-return-values" type="xs:boolean" default="${Unsafe.unreliable-return-values}">
      <xs:annotation>
        <xs:documentation>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="local-cache">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:attribute name="simple-cache" default="${Configuration.simple-cache}">
          <xs:annotation>
            <xs:documentation>
                This cache will be using optimized (faster) implementation that does not support transactions/invocation
                batching, persistence, custom interceptors, indexing, store-as-binary or transcoding. Also, this type of
                cache does not support Map-Reduce jobs or Distributed Executor framework.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="locking">
    <xs:attribute name="isolation" type="tns:isolation" default="${Locking.isolation}">
      <xs:annotation>
        <xs:documentation>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="striping" type="xs:boolean" default="${Locking.striping}">
      <xs:annotation>
        <xs:documentation>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquire-timeout" type="xs:string" default="${Locking.acquire-timeout}">
      <xs:annotation>
        <xs:documentation>
          Maximum time to attempt a particular lock acquisition.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="concurrency-level" type="xs:int" default="${Locking.concurrency-level}">
      <xs:annotation>
        <xs:documentation>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transaction">
    <xs:attribute name="mode" type="tns:transaction-mode" default="NONE">
      <xs:annotation>
        <xs:documentation>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stop-timeout" type="xs:string" default="${Transaction.stop-timeout}">
      <xs:annotation>
        <xs:documentation>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="locking" type="tns:locking-mode" default="${Transaction.locking}">
      <xs:annotation>
        <xs:documentation>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transaction-manager-lookup" type="xs:string" default="${Transaction.transaction-manager-lookup}">
      <xs:annotation>
        <xs:documentation>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="complete-timeout" type="xs:string" default="${Transaction.complete-timeout}">
      <xs:annotation>
        <xs:documentation>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reaper-interval" type="xs:string" default="${Transaction.reaper-interval}">
      <xs:annotation>
        <xs:documentation>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto-commit" type="xs:boolean" default="${Transaction.auto-commit}">
      <xs:annotation>
        <xs:documentation>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recovery-cache" type="xs:string" default="${Recovery.recovery-cache}">
      <xs:annotation>
        <xs:documentation>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notifications" type="xs:boolean" default="${Transaction.notifications}">
      <xs:annotation>
        <xs:documentation>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="encodingType" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Describes the content-type and encoding.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="media-type" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="keyEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="valueEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="encoding">
    <xs:annotation>
      <xs:documentation>
        Defines content type and encoding for keys and values of the cache.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="key" type="tns:keyEncodingType" minOccurs="0"/>
      <xs:element name="value" type="tns:valueEncodingType" minOccurs="0"/>
    </xs:sequence>
    <xs:attribute name="media-type" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The media type for both keys and values. When present, takes precedence over the
          individual configurations for keys and values.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="expiration">
    <xs:attribute name="max-idle" type="xs:string" default="${Expiration.max-idle}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can remain idle. If no operations are performed on entries
          within the maximum idle time, the entries expire across the cluster.
          A value of 0 or -1 disables expiration.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lifespan" type="xs:string" default="${Expiration.lifespan}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can exist. After reaching their lifespan, cache entries
          expire across the cluster. A value of 0 or -1 disables expiration.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="xs:string" default="${Expiration.interval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the interval, in milliseconds, between expiration runs. A value of 0 or -1 disables the expiration reaper.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="touch" type="tns:touch-mode" default="${Expiration.touch}">
      <xs:annotation>
        <xs:documentation>
          Controls how timestamps get updated for entries in clustered caches with maximum idle expiration.
          The default value is SYNC.
          This attribute applies only to caches that use synchronous mode.
          Timestamps are updated asynchronously for caches that use asynchronous mode.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="store-as-binary">
    <xs:annotation>
      <xs:documentation>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
        DEPRECATED: please use memory element instead
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="keys" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="values" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="persistence">
    <xs:choice minOccurs="0">
      <xs:element name="cluster-loader" type="tns:cluster-loader">
        <xs:annotation>
          <xs:documentation>Defines a cluster cache loader.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store" type="tns:custom-store">
        <xs:annotation>
          <xs:documentation>Defines a custom cache store.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="file-store" type="tns:file-store">
        <xs:annotation>
          <xs:documentation>
            Defines a filesystem-based cache store.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="single-file-store" type="tns:single-file-store">
        <xs:annotation>
          <xs:documentation>
            Deprecated since 13.0. Defines a filesystem-based cache store that stores its elements in a single file.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" />
    </xs:choice>
    <xs:attribute name="passivation" type="xs:boolean" default="${Persistence.passivation}">
      <xs:annotation>
        <xs:documentation>
          Enables passivation so that data is written to cache stores only if
          it is evicted from memory. Subsequent requests for passivated entries
          restore them to memory and remove them from persistent storage.
          If you do not enable passivation, writes to entries in memory result
          in writes to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connection-attempts" type="xs:int" default="${Persistence.connection-attempts}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum number of attempts to start each configured
          `CacheWriter` or `CacheLoader`. An exception is thrown and the cache
          does not start if the number of connection attempts exceeds the
          maximum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="availability-interval" type="xs:string" default="${Persistence.availability-interval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the time, in milliseconds, between availability checks to
          determine if the PersistenceManager is available. In other words,
          this interval sets how often stores and loaders are polled via their
          `org.infinispan.persistence.spi.CacheWriter#isAvailable` or
          `org.infinispan.persistence.spi.CacheLoader#isAvailable`
          implementation. If a single store or loader is not available, an
          exception is thrown during cache operations.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-interceptors">
    <xs:sequence>
      <xs:element name="interceptor" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="property" type="tns:property" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="after" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="before" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation><xs:documentation>A fully qualified class name of the new custom interceptor to add to the configuration.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="index" type="xs:int">
            <xs:annotation><xs:documentation>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="xs:string">
            <xs:annotation><xs:documentation>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures authorization for this cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="${Authorization.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roles" type="tns:role-list">
            <xs:annotation>
              <xs:documentation>
                Sets the valid roles required to access this cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="memory">
    <xs:attribute name="max-size" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container in bytes. The default unit is
          B (bytes). You can optionally set one of the following units: KB
          (kilobytes), MB (megabytes), GB (gigabytes), TB (terabytes), KiB
          (kibibytes), MiB (mebibytes), GiB (gibibytes) and TiB (tebibytes).
          Eviction occurs when the approximate memory usage of the data
          container exceeds the maximum size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-count" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container by number of entries. Eviction occurs after the container size exceeds the maximum count.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="when-full" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define either the max-size or the max-count
          (but not both) for the data container. If no strategy is defined,
          but max-count or max-size is configured, REMOVE is used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

    <xs:attribute name="storage" type="tns:memory-storage" default="HEAP">
      <xs:annotation>
        <xs:documentation>
          Defines the type of memory that the data container uses as storage.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="memory-storage">
    <xs:restriction base="xs:token">
      <xs:enumeration value="HEAP">
        <xs:annotation>
          <xs:documentation>
            Stores cache entries in JVM heap memory.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OFF_HEAP">
        <xs:annotation>
          <xs:documentation>
            Stores cache entries as bytes in native memory outside the Java
            heap.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="OBJECT">
        <xs:annotation>
          <xs:documentation>
            Deprecated, only added in 11.0 to simplify the transition from the &lt;object/&gt; element.
            Please use HEAP instead.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BINARY">
        <xs:annotation>
          <xs:documentation>
            Deprecated, only added in 11.0 to simplify the transition from the &lt;binary/&gt; element.
            Please use HEAP and set the encoding media type instead.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="clustered-cache" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:sequence>
          <xs:element name="partition-handling" minOccurs="0">
             <xs:annotation>
                <xs:documentation>
                   Configures the way this cache reacts to node crashes and split brains.
                </xs:documentation>
             </xs:annotation>
             <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean">
                   <xs:annotation>
                      <xs:documentation>
                         Deprecated, use type instead. Enable/disable the partition handling functionality. Defaults to false.
                      </xs:documentation>
                   </xs:annotation>
                </xs:attribute>
               <xs:attribute name="when-split" type="tns:partition-handling-type" default="${PartitionHandling.when-split}">
                 <xs:annotation>
                   <xs:documentation>The type of actions that are possible when a split brain scenario is encountered.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
               <xs:attribute name="merge-policy" type="tns:merge-policy" default="${PartitionHandling.merge-policy}">
                 <xs:annotation>
                   <xs:documentation>The entry merge policy which should be applied on partition merges.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
             </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="mode" type="tns:mode" default="SYNC">
          <xs:annotation>
            <xs:documentation>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="remote-timeout" type="xs:string" default="${Clustering.remote-timeout}">
          <xs:annotation>
            <xs:documentation>
              In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.
              You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="invalidation-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="replicated-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="${Hash.segments}">
          <xs:annotation>
            <xs:documentation>
              Sets the number of hash space segments per cluster. The default
              value is 256. The value should be at least 20 * the cluster size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 11.0. Will be removed in 14.0, the segment allocation will no longer be customizable.
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="distributed-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="owners" type="xs:int" default="${Hash.owners}">
          <xs:annotation>
            <xs:documentation>Number of cluster-wide replicas for each cache entry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="segments" type="xs:int" default="${Hash.segments}">
          <xs:annotation>
            <xs:documentation>Sets the number of hash space segments per cluster. The default value is 256. The value should be at least 20 * the cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity-factor" type="xs:double" default="${Hash.capacity-factor}">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that reside on the local node in comparison to other nodes in the cluster.
              You must specify a positive number as the value.
              The value can also be a fraction such as 1.5.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-lifespan" type="xs:string">
          <xs:annotation>
            <xs:documentation>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
              By default, L1 is disabled unless a positive value is configured for this attribute.
              If the attribute is not present, L1 is disabled.
              You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-cleanup-interval" type="xs:string" default="${L1.l1-cleanup-interval}">
          <xs:annotation>
            <xs:documentation>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
              You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loader" abstract="true">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A cache loader property with name and value.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>
          Determines if a cache loader is shared between cache instances.
          Values are true / false (default). This property prevents duplicate
          writes of data to the cache loader by different cache instances. An
          example is where all cache instances in a cluster use the same JDBC
          settings for the same remote, shared database. If true, only the
          nodes where modifications originate write to the cache store. If
          false, each cache reacts to potential remote updates by storing the
          data to the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>
          Pre-loads data into memory from the cache loader when the cache
          starts. Values are true / false (default). This property is useful
          when data in the cache loader is required immediately after startup
          to prevent delays with cache operations when the data is loaded
          lazily. This property can provide a "warm cache" on startup but it
          impacts performance because it affects start time. Pre-loading data
          is done locally, so any data loaded is stored locally in the node
          only. Pre-loaded data is not replicated or distributed. Likewise,
          data is pre-loaded only up to the maximum configured number of
          entries in eviction.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cluster-loader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="remote-timeout" type="xs:string" default="${ClusterLoader.remote-timeout}">
          <xs:annotation>
            <xs:documentation>
              The timeout when performing remote calls.
              You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="store" abstract="true">
    <xs:sequence>
      <xs:element name="write-behind" type="tns:write-behind" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures cache stores as write-behind instead of write-through.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Defines a cache store property with name and value.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactional" type="xs:boolean" default="${AbstractStore.transactional}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and cache's transactions rollingback.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process. Likewise in some cases you cannot pre-load data in caches stores, such as when using shared remote stores.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="purge" type="xs:boolean" default="${AbstractStore.purge}">
      <xs:annotation>
        <xs:documentation>
          Empties the specified cache loader at startup. Values are true /
          false (default). This property takes effect only if read-only is
          false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="read-only" type="xs:boolean" default="${AbstractStore.read-only}">
      <xs:annotation>
        <xs:documentation>
          Prevents data from being persisted to cache stores. Values are true /
          false (default). If true, cache stores load entries only. Any
          modifications to data in the cache do not apply to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="write-only" type="xs:boolean" default="${AbstractStore.write-only}">
      <xs:annotation>
        <xs:documentation>
          Prevents data from being loaded from cache stores. Values are true /
          false (default). If true, cache stores write entries only. Any
          retrievals of data in the cache do not read from the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-batch-size" type="xs:int" default="${AbstractStore.max-batch-size}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum size of a batch to insert or delete from the cache
          store. If the value is less than one, no upper limit applies to the
          number of operations in a batch.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segmented" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Configures cache stores to store data in hash space segments, with the cache's
          "segments" attribute defining the number of segments.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="write-behind">
    <xs:attribute name="modification-queue-size" type="xs:int" default="${AsyncStore.modification-queue-size}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum number of entries in the asynchronous
          modification queue. When the queue is full, write-through mode is
          used until the queue can accept new entries.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="${AsyncStore.thread-pool-size}">
      <xs:annotation>
        <xs:documentation>
          Specifies the number of threads to apply modifications to the cache
          store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fail-silently" type="xs:boolean" default="${AsyncStore.fail-silently}">
      <xs:annotation>
        <xs:documentation>
          Controls how asynchronous write operations take place when cache
          stores become unavailable. If "true", asynchronous write operations
          that fail are re-attempted with the number of times specified in the
          "connection-attempts" parameter. If all attempts fail, errors are
          ignored and write operations are not executed on the cache store. If
          "false", asynchronous write operations that fail are re-attempted
          when the underlying store becomes available. If the modification
          queue becomes full before the underlying store becomes available, an
          error is thrown on all future write operations to the store until the
          modification queue is flushed. The modification queue is not
          persisted. If the underlying store does not become available before
          the asynchronous store is stopped, queued modifications are lost.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="class" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the class name of a cache store that
              implements either `CacheLoader`, `CacheWriter`, or both.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="single-file-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="max-entries" type="xs:int">
          <xs:annotation>
            <xs:documentation>
              Specifies the maximum number of entries that the file store can
              hold. To increase the speed of lookups, Single File cache stores
              index keys and their locations in the file. To avoid excessive
              memory usage, you can configure the maximum number of entries so
              that entries are removed permanently from both memory and the
              cache store when the maximum is exceeded. However, this can lead
              to data loss. You should only set a maximum number of entries if
              data can be recomputed or retrieved from an authoritative data
              store. By default, the value is `-1` which means that there is no
              maximum number of entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Specifies a filesystem directory for data. The value can be a
              relative or absolute path. Relative paths are created relative to
              the configured global persistent location. Absolute paths must be
              subdirectories of the global persistent location, otherwise an
              exception is thrown.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="file-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:sequence>
          <xs:element name="index" type="tns:index-type" minOccurs="0" />
          <xs:element name="data" type="tns:data-type" minOccurs="0" />
        </xs:sequence>
        <xs:attribute name="max-entries" type="xs:int">
          <xs:annotation>
            <xs:documentation>
              Deprecated since 13.0 which ignores the property.
              Specifies the maximum number of entries that the file store can
              hold. To increase the speed of lookups, Single File cache stores
              index keys and their locations in the file. To avoid excessive
              memory usage, you can configure the maximum number of entries so
              that entries are removed permanently from both memory and the
              cache store when the maximum is exceeded. However, this can lead
              to data loss. You should only set a maximum number of entries if
              data can be recomputed or retrieved from an authoritative data
              store. By default, the value is `-1` which means that there is no
              maximum number of entries.
              Deprecated since 13.0, will be removed in 16.0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Specifies a filesystem directory for data. The value can be a
              relative or absolute path. Relative paths are created relative to
              the configured global persistent location. Absolute paths must be
              subdirectories of the global persistent location, otherwise an
              exception is thrown.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>

        <xs:attribute name="open-files-limit" type="xs:int" default="${SoftIndexFileStore.open-files-limit}">
          <xs:annotation>
            <xs:documentation>
              Max number of data and index files opened for reading (current log file and compaction output are not included here - always uses one each).
              Index files will use 1/10th of list limit with a minimum of 1 and a maximum equal to the number of cache segments.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="compaction-threshold" type="xs:double" default="${SoftIndexFileStore.compaction-threshold}">
          <xs:annotation>
            <xs:documentation>
              If amount of unused space in some data file gets above this threshold, the file is compacted - entries from that file are copied to a new file and the old file is deleted.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="data-type">
    <xs:annotation>
      <xs:documentation>
        Configure where and how should be the entries stored - this is the persistent location.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="path" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          A location on disk where the store writes entries. Files are written sequentially, reads are random.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-file-size" type="xs:int" default="${Data.max-file-size}">
      <xs:annotation>
        <xs:documentation>
          Max size of single file with entries, in bytes.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="sync-writes" type="xs:boolean" default="${Data.sync-writes}">
      <xs:annotation>
        <xs:documentation>
          If true, the write is confirmed only after the entry is fsynced on disk.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-type">
    <xs:annotation>
      <xs:documentation>
        Configure where and how should be the index stored.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="path" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          A location where the store keeps index - this does not have be persistent across restarts, and SSD storage is recommended (the index is accessed randomly).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segments" type="xs:int" default="${Index.segments}">
      <xs:annotation>
        <xs:documentation>
          Deprecated since 15.0 which ignores the property.
          This value is ignored as we create an index file per cache segment instead.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-queue-length" type="xs:int" default="${Index.max-queue-length}">
      <xs:annotation>
        <xs:documentation>
          Max number of entry writes that are waiting to be written to the index, per index segment.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-node-size" type="xs:int" default="${Index.max-node-size}">
      <xs:annotation>
        <xs:documentation>
          Max size of node (continuous block on filesystem used in index implementation), in bytes.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-node-size" type="xs:int" default="${Index.min-node-size}">
      <xs:annotation>
        <xs:documentation>
          If the size of node (continuous block on filesystem used in index implementation) drops below this threshold, the node will try to balance its size with some neighbour node, possibly causing join of multiple nodes.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>

  </xs:complexType>

  <xs:complexType name="remote-server">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The hostname or ip address of a remote Hot Rod server
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:int" default="11222">
      <xs:annotation>
        <xs:documentation>
          The port on which the server is listening (default 11222)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outbound-socket-binding" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="state-transfer">
    <xs:attribute name="enabled" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${StateTransfer.timeout}">
      <xs:annotation>
        <xs:documentation>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.
        Must be greater than or equal to 'remote-timeout' in the clustering configuration.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunk-size" type="xs:integer" default="${StateTransfer.chunk-size}">
      <xs:annotation>
        <xs:documentation>The number of cache entries to batch in each transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="await-initial-transfer" type="xs:boolean" default="${StateTransfer.await-initial-transfer}">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="groups">
    <xs:sequence>
      <xs:element name="grouper" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="enabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Enables or disables grouping.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backups">
    <xs:sequence>
      <xs:element name="backup" type="tns:backup" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Configures a remote site as a backup location for cache data.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="merge-policy" type="tns:xsite-merge-policy" default="${Sites.merge-policy}">
      <xs:annotation>
        <xs:documentation>
          Specifies the fully qualified name of a class that implements the XSiteEntryMergePolicy interface or any of
          the alias. Use if for ASYNC strategy backup.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-cleanup-delay" type="xs:string" default="${Sites.max-cleanup-delay}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum delay, in milliseconds, between which tombstone cleanup tasks run.
          This attribute applies to the asynchronous backup strategy only.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tombstone-map-size" type="xs:positiveInteger" default="${Sites.tombstone-map-size}">
      <xs:annotation>
        <xs:documentation>
          Specifies the target number of tombstones to store.
          If the current size of the tombstone map is greater than the target size, then cleanup tasks run more frequently.
          If the current size of the tombstone map is less than the target size, then cleanup tasks run less frequently.
          This attribute applies to the asynchronous backup strategy only.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backup">
    <xs:sequence>
      <xs:element name="take-offline" type="tns:take-offline" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Specifies the number of failures that can occur before backup locations go offline.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="state-transfer" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Modifies state transfer operations.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="chunk-size" type="xs:int" default="${XSiteStateTransfer.chunk-size}">
            <xs:annotation>
               <xs:documentation>
                 Specifies how many cache entries are batched in each transfer request.
               </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="xs:string" default="${XSiteStateTransfer.timeout}">
            <xs:annotation>
              <xs:documentation>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
                You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max-retries" type="xs:int" default="${XSiteStateTransfer.max-retries}">
            <xs:annotation>
              <xs:documentation>
                Sets the maximum number of retry attempts for push state failures. Specify a value of 0 (zero) to disable retry attempts. The default value is 30.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wait-time" type="xs:string" default="${XSiteStateTransfer.wait-time}">
            <xs:annotation>
              <xs:documentation>
                Sets the amount of time, in milliseconds, to wait between retry attempts for push state failures. You must specify a value of 1 or more. The default value is 2000.
                You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="mode" type="tns:xsite-state-transfer-mode" default="${XSiteStateTransfer.mode}">
            <xs:annotation>
              <xs:documentation>
                Controls whether cross-site state transfer happens manually on user action, which is the default, or automatically when backup locations come online.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="site" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Names the remote site to which the cache backs up data.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:mode" default="${Backup.strategy}">
      <xs:annotation>
        <xs:documentation>
          Sets the strategy for backing up to a remote site.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy" type="tns:backup-failure-policy" default="${Backup.failure-policy}">
      <xs:annotation>
        <xs:documentation>
          Controls how local writes to caches are handled if synchronous backup operations fail.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string" default="${Backup.timeout}">
      <xs:annotation>
        <xs:documentation>
          Specifies timeout, in milliseconds, for synchronous and asynchronous backup operations.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="two-phase-commit" type="xs:boolean" default="${Backup.two-phase-commit}">
      <xs:annotation>
        <xs:documentation>
          Enables two-phase commits for optimistic transactional caches with
          the synchronous backup strategy only.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy-class" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the fully qualified name of a class that implements the
          CustomFailurePolicy interface. Use if failure-policy="CUSTOM".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="take-offline">
    <xs:attribute name="after-failures" type="xs:int" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the number of consecutive failures that can occur for backup
          operations before sites go offline. Specify a negative or zero value
          to ignore this attribute and use minimum wait time only ("min-wait").
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-wait" type="xs:string" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the minimum time to wait, in milliseconds, before sites go
          offline when backup operations fail. If subsequent operations are
          successful, the minimum wait time is reset. If you set
          "after-failures", sites go offline when the wait time is reached and
          the number of failures occur.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="property">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the name of a property.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="isolation">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_UNCOMMITTED">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures READ_COMMITTED</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_COMMITTED">
        <xs:annotation>
          <xs:documentation>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REPEATABLE_READ">
        <xs:annotation>
          <xs:documentation>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SERIALIZABLE">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures REPEATABLE_READ</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Cache will not enlist within transactions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BATCH">
        <xs:annotation>
          <xs:documentation>Uses batching to group cache operations together.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.Synchronization</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_DURABLE_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FULL_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="indexing">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not index data. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LOCAL">
        <xs:annotation>
          <xs:documentation>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>Index all data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PRIMARY_OWNER">
        <xs:annotation>
          <xs:documentation>Only index changes on the primary owner, regardless of it's local or remote.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="index-storage">
    <xs:restriction base="xs:token">
      <xs:enumeration value="filesystem">
        <xs:annotation>
          <xs:documentation>Local filesystem index storage. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="local-heap">
        <xs:annotation>
          <xs:documentation>JVM heap index storage, not persisted between restarts. Only suitable for small datasets with low concurrency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="startup-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="purge">
        <xs:annotation>
          <xs:documentation>
            Clears the index when the cache starts.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="reindex">
        <xs:annotation>
          <xs:documentation>
            Rebuilds the index when the cache starts.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="auto">
        <xs:annotation>
          <xs:documentation>
            Automatically triggers an indexing operation when the cache starts.
            If data is volatile and the index is persistent then the cache is cleared when it starts.
            If data is persistent and the index is volatile then the cache is reindexed when it starts.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="none">
        <xs:annotation>
          <xs:documentation>
            Cache startup does not trigger an indexing operation. This is the default value.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="indexing-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="auto">
        <xs:annotation>
          <xs:documentation>
            All the changes to the cache will be immediately applied to the indexes.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="manual">
        <xs:annotation>
          <xs:documentation>
            Indexes will be only updated when a reindex is explicitly invoked.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:complexType name="index-reader">
    <xs:attribute name="refresh-interval" type="xs:string" default="0">
      <xs:annotation>
        <xs:documentation>
          Interval, in milliseconds, to reopen the index reader.
          By default, the index reader is refreshed on-demand during searches, if new entries were indexed since the last refresh. Configuring with a value larger than zero will make some queries results stale, but query throughput will increase substantially, specially in write heavy scenarios.
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-sharding">
    <xs:attribute name="shards" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Defines the number of shards with which slip the index data.
          To enable sharding, set this attribute to a value that is strictly major of 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-merge">
    <xs:attribute name="max-entries" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Maximum number of entries that an index segment can have before merging. Segments with more than this number of entries are not merged. Smaller values perform better on frequently changing indexes, larger values provide better search performance if the index does not change often.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="factor" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Number of segments that are merged at once. With smaller values, merging happens more often, which uses more resources, but the total number of segments will be lower on average, increasing search performance. Larger values (greater than 10) are best for heavy writing scenarios.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Minimum target size of segments, in MB, for background merges. Segments smaller than this size are merged more aggressively. Setting a value that is too large might result in expensive merge operations, even though they are less frequent.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          Maximum size of segments, in MB, for background merges. Segments larger than this size are never merged in the background. Settings this to a lower value helps reduce memory requirements and avoids some merging operations at the cost of optimal search speed. This attribute is ignored when forcefully merging an index and `max-forced-size` applies instead.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-forced-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          maximum size of segments, in MB, for forced merges and overrides the `max-size` attribute. Set this to the same value as `max-size` or lower. However setting the value too low degrades search performance because documents are deleted.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="calibrate-by-deletes" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Whether the number of deleted entries in an index should be taken into account when counting the entries in the segment. Setting `false` will lead to more frequent merges caused by `max-entries`, but will more aggressively merge segments with many deleted documents, improving search performance.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="index-writer">
    <xs:sequence>
      <xs:element name="index-merge" type="tns:index-merge" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines properties to control the merge of index segments. An index segment is
            not related to an Infinispan segment, but represents a section of index in the storage.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="commit-interval" type="xs:string" default="1s">
      <xs:annotation>
        <xs:documentation>
          Amount of time, in milliseconds, that index changes that are buffered in memory are flushed to the index storage and a commit is performed. Because operation is costly, small values should be avoided. The default is 1000 ms (1 second).
          You can optionally set one of the following units: ms (milliseconds), s (seconds), m (minutes), h (hours), d (days).
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ram-buffer-size" type="xs:int" default="32">
      <xs:annotation>
        <xs:documentation>
          Maximum amount of memory that can be used for buffering added entries and deletions before they are flushed to the index storage. Large values result in faster indexing but use more memory. For faster indexing performance you should set this attribute instead of `max-buffered-entries`. When used in combination with the `max-buffered-entries` attribute, a flush occurs for whichever event happens first.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-buffered-entries" type="xs:int" default="32">
      <xs:annotation>
        <xs:documentation>
          Maximum number of entries that can be buffered in-memory before they are flushed to the index storage. Large values result in faster indexing but use more memory. When used in combination with the `ram-buffer-size` attribute, a flush occurs for whichever event happens first.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Number of threads that execute write operations to the index.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue-count" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Number of internal queues to use for each indexed type. Each queue holds a batch of modifications that is applied to the index and queues are processed in parallel. Increasing the number of queues will lead to an increase of indexing throughput, but only if the bottleneck is CPU. For optimum results, do not set a value for `queue-count` that is larger than the value for `thread-pool-size`.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="queue-size" type="xs:int" default="1000">
      <xs:annotation>
        <xs:documentation>
          Maximum number of elements each queue can hold. Increasing the `queue-size` value increases the amount of memory that is used during indexing operations. Setting a value that is too small can block indexing operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="low-level-trace" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          Enables low-level trace information for indexing operations. Enabling this attribute substantially degrades performance. You should use this low-level tracing only as a last resource for troubleshooting.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="eviction-strategy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If you define a size for the data container,
            you should specify either the REMOVE or EXCEPTION exiction strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>
            Manually evict entries. This strategy is the same as NONE but does
            not log errors if you enable passivation without eviction.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE">
        <xs:annotation>
          <xs:documentation>
            Automatically evict older entries to make space for new entries. By
            default REMOVE is always used when you define a size for the data
            container unless you configure the EXCEPTION strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXCEPTION">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If the data container reaches the maximum
            size, exceptions occur for requests to create new entries. You can
            use this eviction strategy only with transactional caches that use
            two phase commit.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNORDERED">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIFO">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LRU">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIRS">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>
            Enables asynchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>
            Enables synchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="locking-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="OPTIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Optimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PESSIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Pessimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="backup-failure-policy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="IGNORE">
        <xs:annotation>
          <xs:documentation>
            Ignore failed backup operations and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARN">
        <xs:annotation>
          <xs:documentation>
            Log exceptions when backup operations fail and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FAIL">
        <xs:annotation>
          <xs:documentation>
            Throw exceptions when backup operations fail and attempt to stop writes to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CUSTOM">
        <xs:annotation>
          <xs:documentation>
            Use a custom failure policy. Requires the "failure-policy-class" attribute.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdown-hook-behavior">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REGISTER">
        <xs:annotation>
          <xs:documentation>Register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DONT_REGISTER">
        <xs:annotation>
          <xs:documentation>Don't register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="tracing-exporter-protocol">
    <xs:restriction base="xs:token">
      <xs:enumeration value="OTLP">
        <xs:annotation>
          <xs:documentation>
            Use the OpenTelemetry Protocol (OTLP). This is the default and the recommended option.
            This option does not require any extra dependency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="JAEGER">
        <xs:annotation>
          <xs:documentation>
            Tracing will be exported using gRPC and the Jaeger format.
            This option will require the Jaeger exporter as extra dependency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ZIPKIN">
        <xs:annotation>
          <xs:documentation>
            Tracing will be exported in JSON Zipkin format using HTTP.
            This option will require the Zipkin exporter as extra dependency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PROMETHEUS">
        <xs:annotation>
          <xs:documentation>
            Tracing will be exported for a Prometheus collector.
            This option will require the Prometheus exporter as extra dependency.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="COUNT">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the number of entries reaches the
            configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MEMORY">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the amount of memory in use
            reaches the configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="versioning-scheme">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIMPLE">
        <xs:annotation>
          <xs:documentation>
            A simple versioning scheme that is cluster-aware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Don't version entries
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="permission-list">
    <xs:list itemType="tns:permission"/>
  </xs:simpleType>

  <xs:simpleType name="permission">
    <xs:restriction base="xs:string">
      <xs:enumeration value="LIFECYCLE">
        <xs:annotation>
          <xs:documentation>
            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ">
        <xs:annotation>
          <xs:documentation>
            Allows reading data from a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows writing data to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXEC">
        <xs:annotation>
          <xs:documentation>
            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LISTEN">
        <xs:annotation>
          <xs:documentation>
            Allows attaching listeners to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_READ">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-read operations (e.g. obtaining all the keys in a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-write operations (e.g. clearing a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ADMIN">
        <xs:annotation>
          <xs:documentation>
            Allows performing "administrative" operations on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all of the others
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_READ">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all read permissions (READ and BULK_READ)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_WRITE">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Permission which means no permissions
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="role-list">
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="partition-handling-type">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DENY_READ_WRITES">
        <xs:annotation>
          <xs:documentation>
            Allow read and write operations only if all replicas of an entry are in the partition.
            If a partition does not include all replicas of an entry, do not allow cache operations for that entry.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READS">
        <xs:annotation>
          <xs:documentation>
            Allow read operations for entries and deny write operations unless the partition includes all replicas of an entry.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READ_WRITES">
        <xs:annotation>
          <xs:documentation>
            Allow read and write operations on caches while a cluster is split into network partitions.
            Caches remain available and conflicts are resolved during merge.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="merge-policy">
    <xs:union memberTypes="tns:merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Do not resolve conflicts when merging split clusters.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_ALWAYS">
        <xs:annotation>
          <xs:documentation>
            Use the value that exists on the majority of nodes in the cluster to resolve conflicts.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_NON_NULL">
        <xs:annotation>
          <xs:documentation>
            Use the first non-null value on the cluster to resolve conflicts.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE_ALL">
        <xs:annotation>
          <xs:documentation>
            Delete any conflicting entries from the cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- JGroups extension attributes -->
  <xs:attribute name="stack.combine" default="COMBINE">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="COMBINE">
          <xs:annotation>
            <xs:documentation>Combines the protocol attributes, overriding any that have been set in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_AFTER">
          <xs:annotation>
            <xs:documentation>Inserts the protocol after/above an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_ABOVE">
          <xs:annotation>
            <xs:documentation>Inserts the protocol after/above an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_BEFORE">
          <xs:annotation>
            <xs:documentation>Inserts the protocol before/below an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_BELOW">
          <xs:annotation>
            <xs:documentation>Inserts the protocol before/below an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REPLACE">
          <xs:annotation>
            <xs:documentation>Replaces the protocol in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REMOVE">
          <xs:annotation>
            <xs:documentation>Removes the protocol from the stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>

  <xs:attribute name="stack.position" type="xs:string" />

  <xs:simpleType name="bias-acquisition">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NEVER">
        <xs:annotation>
          <xs:documentation>The bias is never acquired.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ON_WRITE">
        <xs:annotation>
          <xs:documentation>Bias is acquired by the writing entry.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="touch-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>Delays read operations until the other owners confirm that the timestamp for the entry is updated.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>
            Sends touch commands to other owners without waiting for confirmation.
            This mode allows read operations to return the value of a key even if another node has started
            expiring it.
            When that occurs, the read operation does not extend the lifespan of the key.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="xsite-merge-policy">
    <xs:union memberTypes="tns:xsite-merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="xsite-merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>In case of conflict, it chooses the entry for the site's name with lower lexicographically
            order.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFER_NON_NULL">
        <xs:annotation>
          <xs:documentation>In case of conflict and one of the entries is null, it chooses the non-null entry. If both
            non-null, it uses the DEFAULT.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFER_NULL">
        <xs:annotation>
          <xs:documentation>In case of conflict and one of the entries is null, it chooses the null entry. If both
            non-null, it uses the DEFAULT.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALWAYS_REMOVE">
        <xs:annotation>
          <xs:documentation>In case of any conflict, the entry is removed from both sites.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="xsite-state-transfer-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>
            Users must bring backup locations online and initiate state
            transfer between remote sites.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="AUTO">
        <xs:annotation>
          <xs:documentation>
            Backup locations that use the asynchronous backup strategy can
            automatically come back online. State transfer operations begin
            when the remote site connections are stable.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  <xs:simpleType name="unclean-shutdown-action">
    <xs:restriction base="xs:token">
      <xs:enumeration value="IGNORE">
        <xs:annotation>
          <xs:documentation>
            Ignores the presence of a dangling lock file in the persistent global state.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FAIL">
        <xs:annotation>
          <xs:documentation>
            Prevents startup of the cache manager if a dangling lock file is found in the persistent global state.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PURGE">
        <xs:annotation>
          <xs:documentation>
            Clears the persistent global state if a dangling lock file is found in the persistent global state.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="tracing-category-list">
    <xs:list itemType="tns:tracing-category"/>
  </xs:simpleType>

  <xs:simpleType name="tracing-category">
    <xs:restriction base="xs:string">
      <xs:enumeration value="container">
        <xs:annotation>
          <xs:documentation>
            Default Infinispan span category, which includes all the major put/insertion operations.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="cluster">
        <xs:annotation>
          <xs:documentation>
            Span category for cluster operations causally related by client interactions.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="x_site">
        <xs:annotation>
          <xs:documentation>
            Span category for x-site operations causally related by client interactions.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="persistence">
        <xs:annotation>
          <xs:documentation>
            Span category for persistence operations causally related by client interactions.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="security">
        <xs:annotation>
          <xs:documentation>
            Span category for security operations causally related by client interactions.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="string-list">
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="schema-compatibility">
    <xs:restriction base="xs:token">
      <xs:enumeration value="UNRESTRICTED">
        <xs:annotation>
          <xs:documentation>
            Replaces existing schemas without performing any backwards-compatibility checks.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LENIENT">
        <xs:annotation>
          <xs:documentation>
            Enables lenient compatibility checks when updating an existing schema. The following checks are performed:
            No Using Reserved Fields, No Changing Field IDs, No Changing Field Types, No Removing Fields Without Reserve
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="STRICT">
        <xs:annotation>
          <xs:documentation>
            Enables strict compatibility checks when updating an existing schema. The following checks are performed:
            No Using Reserved Fields, No Changing Field IDs, No Changing Field Types, No Removing Fields Without Reserve,
            No Removing Reserved Fields, No Changing Field Names
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>
