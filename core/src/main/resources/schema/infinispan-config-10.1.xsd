<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema elementFormDefault="qualified"
           version="1.1" targetNamespace="urn:infinispan:config:10.1"
           xmlns:tns="urn:infinispan:config:10.1"
           xmlns:jgroups="urn:org:jgroups"
           xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:import namespace="urn:org:jgroups" schemaLocation="http://www.jgroups.org/schema/jgroups-4.1.xsd"/>

  <xs:element name="infinispan" type="tns:infinispan">
    <xs:annotation>
      <xs:documentation>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </xs:documentation>
    </xs:annotation>
  </xs:element>

  <xs:complexType name="infinispan">
    <xs:sequence>
      <xs:element name="jgroups" type="tns:jgroups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines JGroups stacks.</xs:documentation>
        </xs:annotation>
        <xs:unique name="stack_id_unique">
          <xs:selector xpath="./tns:stack|./tns:stack-file" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:element name="threads" type="tns:threads" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the threading subsystem.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="cache-container" type="tns:cache-container">
        <xs:annotation>
          <xs:documentation>Defines an embedded cache container.</xs:documentation>
        </xs:annotation>
        <xs:unique name="cache_id_unique">
          <xs:selector xpath="./tns:local-cache|./tns:local-cache-configuration|./tns:invalidation-cache|./tns:invalidation-cache-configuration|./tns:replicated-cache|./tns:replicated-cache-configuration|./tns:distributed-cache|./tns:distributed-cache-configuration" />
          <xs:field xpath="@name" />
        </xs:unique>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="jgroups">
    <xs:annotation>
      <xs:documentation>
        Defines JGroups transport stacks.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="stack-file" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              Defines an individual JGroups stack, pointing to the file containing its definition.
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation><xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="path" type="xs:string">
            <xs:annotation><xs:documentation>Path of JGroups configuration file containing stack definition.</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="stack" type="tns:jgroups-stack" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
    <xs:attribute name="transport" type="xs:string" default="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
      <xs:annotation>
        <xs:documentation>Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jgroups-stack">
    <xs:complexContent>
      <xs:extension base="jgroups:ConfigType">
        <xs:sequence>
          <xs:element name="remote-sites" type="tns:jgroups-remote-sites" minOccurs="0">
            <xs:annotation>
              <xs:documentation>
                Defines the relay configuration.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Name of the stack, to be referenced by transport's stack attribute.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="extends" type="xs:string">
          <xs:annotation>
            <xs:documentation>The base stack to extend.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="jgroups-remote-sites">
    <xs:sequence maxOccurs="unbounded">
      <xs:element name="remote-site" type="tns:jgroups-stack-relay-remote-site" />
    </xs:sequence>
    <xs:attribute name="default-stack" type="xs:string" use="required"/>
  </xs:complexType>

  <xs:complexType name="jgroups-stack-relay-remote-site">
    <xs:attribute name="name" type="xs:string" use="required"/>
    <xs:attribute name="stack" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="threads">
    <xs:annotation>
      <xs:documentation>
        The threading subsystem, used to declare manageable thread pools and resources.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="thread-factory" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread factory (implementing java.util.concurrent.ThreadFactory).  The "name" attribute is
                the bean name of the created thread factory.  The optional "priority" attribute may be used to specify
                the thread priority of created threads.  The optional "group-name" attribute specifies the name of a the
                thread group to create for this thread factory.

                The "thread-name-pattern" is the template used to create names for threads.  The following patterns
                may be used:

                 %% - emit a percent sign
                 %t - emit the per-factory thread sequence number
                 %g - emit the global thread sequence number
                 %f - emit the factory sequence number
                 %i - emit the thread ID
                 %G - emit the thread group name
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" type="xs:string" use="required" />
          <xs:attribute name="group-name" type="xs:string" use="optional"/>
          <xs:attribute name="thread-name-pattern" type="xs:string" use="optional" />
          <xs:attribute name="priority" type="xs:string" use="optional" />
        </xs:complexType>
      </xs:element>
      <xs:element name="blocking-bounded-queue-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor with a bounded queue.  Such a thread pool has a core size and a queue with an
                upper bound.  When a task is submitted, if the number of running threads is less than the core size,
                a new thread is created.  Otherwise, the task is placed in queue.  If too many tasks are allowed to be
                submitted to this type of executor, an out of memory condition may occur.

                The "name" attribute is the bean name of the created executor.

                The "max-threads" attribute must be used to specify the maximum thread pool size.
                The "core-threads" attribute defines the number of threads to keep in the pool.

                The nested "keepalive-time" element may used to specify the amount of time that pool threads should
                be kept running when idle; if not specified, threads will run until the executor is shut down.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
          <xs:attribute name="max-threads" type="xs:int"/>
          <xs:attribute name="core-threads" type="xs:int"/>
          <xs:attribute name="keepalive-time" type="xs:string" use="optional"/>
          <xs:attribute name="queue-length" type="xs:string"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="cached-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates new threads as needed, but
                will reuse previously constructed threads when they are available.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="scheduled-thread-pool" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:annotation>
            <xs:documentation>
              <![CDATA[
                A thread pool executor that creates a single-threaded executor
                that can schedule commands to run after a given delay, or to
                execute periodically.

                The "name" attribute is the bean name of the created executor.
                The "thread-factory" element specifies the bean name of a specific thread factory to use to create worker
                threads.
                    ]]>
            </xs:documentation>
          </xs:annotation>
          <xs:attribute name="name" use="required" type="xs:string"/>
          <xs:attribute name="thread-factory" type="xs:string" use="optional"/>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-container">
    <xs:sequence>
      <xs:element name="transport" type="tns:transport" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Overrides the transport characteristics for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:global-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures security for this cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="serialization" type="tns:serialization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Specifies how data serialization will be performed by the cache container.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="metrics" type="tns:metrics" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures MicroProfile metrics.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="jmx" type="tns:jmx" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables and configures JMX monitoring and management.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="global-state" type="tns:global-state" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Defines the global state persistence configuration. If this element is not present, global state persistence will be disabled.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0" maxOccurs="unbounded">
        <xs:element name="local-cache" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="local-cache-configuration" type="tns:local-cache">
          <xs:annotation>
            <xs:documentation>Defines a LOCAL mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="replicated-cache-configuration" type="tns:replicated-cache">
          <xs:annotation>
            <xs:documentation>Defines a REPL_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="invalidation-cache-configuration" type="tns:invalidation-cache">
          <xs:annotation>
            <xs:documentation>Defines an INVALIDATION_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="distributed-cache-configuration" type="tns:distributed-cache">
          <xs:annotation>
            <xs:documentation>Defines a DIST_* mode cache configuration.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="scattered-cache-configuration" type="tns:scattered-cache">
          <xs:annotation>
            <xs:documentation>Defines a SCATTERED_* mode cache configuration. Since 9.0.</xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:any namespace="##other"/>
      </xs:choice>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="aliases" type="tns:aliases">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="default-cache" type="xs:string">
      <xs:annotation>
        <xs:documentation>Indicates the default cache for this cache container</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="zero-capacity-node" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>If 'true' then no data is stored in this node. Defaults to 'false'.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="async-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="listener-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous cache listener notifications.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>DEPRECATED Defines the scheduled executor used for evictions.  The expiration-executor type should be used instead.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="expiration-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the scheduled executor used for expirations.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="persistence-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used when interacting with the persistent store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="state-transfer-executor" type="xs:string">
      <xs:annotation>
        <xs:documentation>Deprecated since 10.1, no longer used.
          Configuration for the executor service used when applying state from other nodes during the state transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string" default="org.jboss.as.clustering.infinispan">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shutdown-hook" type="tns:shutdown-hook-behavior">
      <xs:annotation>
        <xs:documentation>
          Behavior of the JVM shutdown hook registered by the cache
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transport">
    <xs:attribute name="stack" type="xs:string">
      <xs:annotation>
        <xs:documentation>Defines the jgroups stack used by the transport.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cluster" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the name for the underlying group communication cluster.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="executor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Defines the executor used for asynchronous transport communication.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="remote-command-executor" type="xs:string" >
      <xs:annotation>
        <xs:documentation>Configuration for the executor service used to execute remote commands. Use org.infinispan.executors.WithinThreadExecutorFactory to disable.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lock-timeout" type="xs:long" default="240000">
      <xs:annotation>
        <xs:documentation>
          Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
          This constraint is in place because more than one cache could be involved in a transaction.
          This timeout controls the time to wait to acquire a distributed lock.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="node-name" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Name of the current node. This is a friendly name to make logs, etc. make more sense. Defaults to a combination of host name and a random number (to differentiate multiple nodes on the same host)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="machine" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the machine where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="rack" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the rack where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="site" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The id of the site where this node runs.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-size" type="xs:int">
      <xs:annotation>
        <xs:documentation>
          The minimum number of nodes that must join the cluster for the cache manager to start
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="initial-cluster-timeout" type="xs:long">
      <xs:annotation>
        <xs:documentation>
          The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
              <xs:element name="identity-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the identity role mapper where principal names are converted as-is into role names.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="common-name-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="cluster-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses the cluster role mapper which stores the principal to role mappings within the cluster registry.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="custom-role-mapper">
                <xs:annotation>
                  <xs:documentation>
                    Uses a custom role mapper.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="class" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Class of the custom principal to role mapper
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
            </xs:choice>
            <xs:element name="role" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Defines a new role name and assigns permissions to it.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="name" use="required" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>
                      Defines the name of the role.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="permissions" use="required" type="tns:permission-list">
                  <xs:annotation>
                    <xs:documentation>
                      Defines the list of permissions for the role.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="audit-logger" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the audit logger.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="serialization">
    <xs:sequence>
      <xs:element name="advanced-externalizer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0. Please utilise ProtoStream based marshalling for your Java objects by
            configuring one or more context-initializer elements. Alternatively, it's possible to configure a custom
            org.infinispan.commons.marshall.Marshaller implementation for user types, via the "marshaller" attribute.
            AdvancedExternalizer implementations allow users to have fine grained control over how Java objects are
            serialized. Providing smaller payloads than traditional Serialization or Externalizer implementations by
            writing a class ID value instead of the classes FQN.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="id" type="xs:int">
            <xs:annotation>
              <xs:documentation>
                Id of the custom externalizer
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="context-initializer" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            SerializationContextInitializer implementation which is used to initialize a Protostream based marshaller for user types.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Class of the SerializationContextInitializer implementation
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="white-list" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Enables individual classes or regular expressions to be added to the EmbeddedCacheManager white list.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="class" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  FQN of the class to be added to the whitelist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="regex" type="xs:string" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>
                  Regex pattern used to determine if a class is a member of the whitelist.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="marshaller" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="version" type="xs:string" default="71">
      <xs:annotation>
        <xs:documentation>
          Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="metrics">
    <xs:attribute name="gauges" type="xs:boolean" default="${GlobalMetrics.gauges}">
      <xs:annotation>
        <xs:documentation>
          Exports gauge metrics. Gauges are enabled by default but you must
          enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="histograms" type="xs:boolean" default="${GlobalMetrics.histograms}">
      <xs:annotation>
        <xs:documentation>
          Exports histogram metrics. Histograms are not enabled by default
          because they require additional computation. If you enable histograms
          you must also enable statistics so that they are exported.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="prefix" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies a global name prefix for metrics.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="namesAsTags" type="xs:boolean" default="${GlobalMetrics.namesAsTags}">
      <xs:annotation>
        <xs:documentation>
          Put the cache manager and cache name in tags rather then include them in the metric name.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="jmx">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Specifies a JMX property with a name and value that is passed to
            the MBean Server lookup instance.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="domain" type="xs:string" default="${GlobalJmx.domain}">
      <xs:annotation>
        <xs:documentation>
          If JMX statistics are enabled then all 'published' JMX objects appear
          under this domain. Optional, if not specified it defaults to
          "org.infinispan".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mbean-server-lookup" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Class that attempts to locate a JMX MBean server to bind to. Defaults
          to the platform MBean server.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="duplicate-domains" type="xs:boolean" default="${GlobalJmx.duplicateDomains}">
      <xs:annotation>
        <xs:documentation>
          Deprecated since 10.1; please set a unique domain or cache manager name instead.
          If true, multiple cache manager instances could be configured under the same configured JMX domain. Each cache manager will in practice use a different JMX domain that has been calculated based on the configured one by adding an incrementing index to it.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${GlobalJmx.enabled}">
      <xs:annotation>
        <xs:documentation>
          Enables exporting of JMX MBeans.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="global-state">
    <xs:sequence>
      <xs:element name="persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where persistent state data which needs to survive container restarts
            should be stored. The data stored at this location is required for graceful
            shutdown and restore. This path must NOT be shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="shared-persistent-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where shared persistent state data which needs to survive container restarts
            should be stored. This path can be safely shared among multiple instances.
            Defaults to the user.dir system property which usually is where the
            application was started. This value should be overridden to a more appropriate location.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="temporary-location" type="tns:global-state-path" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the filesystem path where temporary state should be stored. Defaults to the value of the
            java.io.tmpdir system property.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:choice minOccurs="0">
        <xs:element name="immutable-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              An immutable configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="volatile-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A non-persistent configuration storage.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="overlay-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage which saves runtime configurations to the persistent-location.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="managed-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              A persistent configuration storage for managed environments. This doesn't work in embedded mode.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="custom-configuration-storage">
          <xs:annotation>
            <xs:documentation>
              Uses a custom configuration storage implementation.
            </xs:documentation>
          </xs:annotation>
          <xs:complexType>
            <xs:attribute name="class" type="xs:string">
              <xs:annotation>
                <xs:documentation>
                  Class of the custom configuration storage implementation.
                </xs:documentation>
              </xs:annotation>
            </xs:attribute>
          </xs:complexType>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="global-state-path">
    <xs:attribute name="relative-to" type="xs:string" default="jboss.server.data.dir">
        <xs:annotation>
            <xs:documentation>A property name whose value will be used as the root path for storing global state</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="path" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Defines the path where global state for this cache-container will be stored.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cache" abstract="true">
    <xs:sequence>
      <xs:element name="backups" type="tns:backups" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines backup locations for cache data and modifies state transfer properties.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="backup-for" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Defines the local cache as a backup for a remote cache with a different name.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="remote-cache" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote cache that uses the local cache as a backup.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="remote-site" type="xs:string" use="optional">
            <xs:annotation>
              <xs:documentation>
                Specifies the name of the remote site that backs up data to the local cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="encoding" type="tns:encoding" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache encoding configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="locking" type="tns:locking" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The locking configuration of the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="transaction" type="tns:transaction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache transaction configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="expiration" type="tns:expiration" minOccurs="0">
        <xs:annotation>
          <xs:documentation>The cache expiration configuration.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store-as-binary" type="tns:store-as-binary" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures the cache to store data in binary format.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="persistence" type="tns:persistence" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures the persistence layer for caches.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="memory" type="tns:memory" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls how the entries are stored in memory
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="indexing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines indexing options for cache
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="key-transformers" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>Defines the Transformers used to stringify keys for indexing with Lucene</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="key-transformer" minOccurs="0" maxOccurs="unbounded">
                    <xs:complexType>
                      <xs:annotation>
                        <xs:documentation>Defines the Transformer to use for the specified key class</xs:documentation>
                      </xs:annotation>
                      <xs:attribute name="key" type="xs:string" use="required" />
                      <xs:attribute name="transformer" type="xs:string" use="required"/>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="indexed-entities" minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>Defines the indexed entity classes</xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="indexed-entity" type="xs:string" minOccurs="0" maxOccurs="unbounded">
                    <xs:annotation>
                      <xs:documentation>Indexed entity class name</xs:documentation>
                    </xs:annotation>
                  </xs:element>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
              <xs:annotation>
                <xs:documentation>Property to pass on to the indexing system</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="index" type="tns:indexing" default="${Indexing.index}">
            <xs:annotation>
              <xs:documentation>The indexing mode of the cache. Defaults to NONE.</xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="auto-config" type="xs:boolean" default="${Indexing.autoConfig}" use="optional">
            <xs:annotation>
              <xs:documentation>Whether or not to apply automatic index configuration based on cache type</xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="custom-interceptors" type="tns:custom-interceptors" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.
             Configures custom interceptors to be added to the cache.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="security" type="tns:cache-security" minOccurs="0">
        <xs:annotation>
          <xs:documentation>Configures cache-level security.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="name" type="xs:ID" use="required">
      <xs:annotation>
        <xs:documentation>Uniquely identifies this cache within its cache container.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configuration" type="xs:IDREF">
      <xs:annotation>
        <xs:documentation>The name of the cache configuration which this configuration inherits from.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="jndi-name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="module" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics" type="xs:boolean" default="${Statistics.enabled}">
      <xs:annotation>
        <xs:documentation>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="statistics-available" type="xs:boolean" default="${Statistics.available}">
      <xs:annotation>
        <xs:documentation>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="unreliable-return-values" type="xs:boolean" default="${Unsafe.unreliable-return-values}">
      <xs:annotation>
        <xs:documentation>
          Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="local-cache">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:attribute name="simple-cache" default="${Configuration.simpleCache}">
          <xs:annotation>
            <xs:documentation>
                This cache will be using optimized (faster) implementation that does not support transactions/invocation
                batching, persistence, custom interceptors, indexing, store-as-binary or transcoding. Also, this type of
                cache does not support Map-Reduce jobs or Distributed Executor framework.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="locking">
    <xs:attribute name="isolation" type="tns:isolation" default="${Locking.isolationLevel}">
      <xs:annotation>
        <xs:documentation>Sets the cache locking isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation level.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="striping" type="xs:boolean" default="${Locking.striping}">
      <xs:annotation>
        <xs:documentation>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="acquire-timeout" type="xs:long" default="${Locking.lockAcquisitionTimeout}">
      <xs:annotation>
        <xs:documentation>Maximum time to attempt a particular lock acquisition.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="concurrency-level" type="xs:int" default="${Locking.concurrencyLevel}">
      <xs:annotation>
        <xs:documentation>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="transaction">
    <xs:attribute name="mode" type="tns:transaction-mode" default="NONE">
      <xs:annotation>
        <xs:documentation>Sets the cache transaction mode to one of NONE, BATCH, NON_XA, NON_DURABLE_XA, FULL_XA.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="stop-timeout" type="xs:long" default="${Transaction.stop-timeout}">
      <xs:annotation>
        <xs:documentation>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="locking" type="tns:locking-mode" default="${Transaction.locking}">
      <xs:annotation>
        <xs:documentation>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transaction-manager-lookup" type="xs:string" default="${Transaction.transaction-manager-lookup}">
      <xs:annotation>
        <xs:documentation>
          Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="complete-timeout" type="xs:long" default="${Transaction.complete-timeout}">
      <xs:annotation>
        <xs:documentation>
          The duration (millis) in which to keep information about the completion of a transaction. Defaults to 60000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="reaper-interval" type="xs:long" default="${Transaction.reaper-wake-up-interval}">
      <xs:annotation>
        <xs:documentation>
          The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 30000.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="auto-commit" type="xs:boolean" default="${Transaction.auto-commit}">
      <xs:annotation>
        <xs:documentation>
          If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="protocol" type="tns:transaction-protocol">
      <xs:annotation>
        <xs:documentation>
          (Deprecated, Total Order will be removed) Configures the commit protocol to use.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="recovery-cache" type="xs:string" default="${Recovery.recoveryInfoCacheName}">
      <xs:annotation>
        <xs:documentation>
          Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="notifications" type="xs:boolean" default="${Transaction.notifications}">
      <xs:annotation>
        <xs:documentation>
          Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="encodingType" abstract="true">
    <xs:annotation>
      <xs:documentation>
        Describes the content-type and encoding.
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="media-type" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="keyEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="valueEncodingType">
    <xs:complexContent>
      <xs:extension base="tns:encodingType"/>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="encoding">
    <xs:annotation>
      <xs:documentation>
        Defines content type and encoding for keys and values of the cache.
      </xs:documentation>
    </xs:annotation>
    <xs:sequence>
      <xs:element name="key" type="tns:keyEncodingType" minOccurs="1" maxOccurs="1"/>
      <xs:element name="value" type="tns:valueEncodingType" minOccurs="1" maxOccurs="1"/>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="expiration">
    <xs:attribute name="max-idle" type="xs:long" default="${Expiration.maxIdle}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can remain idle. If no operations are performed on entries
          within the maximum idle time, the entries expire across the cluster.
          A value of 0 or -1 disables expiration.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lifespan" type="xs:long" default="${Expiration.lifespan}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum amount of time, in milliseconds, that cache
          entries can exist. After reaching their lifespan, cache entries
          expire across the cluster. A value of 0 or -1 disables expiration.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="interval" type="xs:long" default="${Expiration.wakeUpInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the interval, in milliseconds, between expiration runs. A
          value of 0 or -1 disables the expiration reaper.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="store-as-binary">
    <xs:annotation>
      <xs:documentation>
        Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
        DEPRECATED: please use memory element instead
      </xs:documentation>
    </xs:annotation>
    <xs:attribute name="keys" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="values" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="persistence">
    <xs:choice minOccurs="0">
      <xs:element name="cluster-loader" type="tns:cluster-loader">
        <xs:annotation>
          <xs:documentation>Defines a cluster cache loader.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="store" type="tns:custom-store">
        <xs:annotation>
          <xs:documentation>Defines a custom cache store.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="file-store" type="tns:file-store">
        <xs:annotation>
          <xs:documentation>
            Defines a filesystem-based cache store.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:any namespace="##other" />
    </xs:choice>
    <xs:attribute name="passivation" type="xs:boolean" default="${Persistence.passivation}">
      <xs:annotation>
        <xs:documentation>
          Enables passivation so that data is written to cache stores only if
          it is evicted from memory. Subsequent requests for passivated entries
          restore them to memory and remove them from persistent storage.
          If you do not enable passivation, writes to entries in memory result
          in writes to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connection-attempts" type="xs:int" default="${Persistence.connectionAttempts}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum number of attempts to start each configured
          `CacheWriter` or `CacheLoader`. An exception is thrown and the cache
          does not start if the number of connection attempts exceeds the
          maximum.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="connection-interval" type="xs:int" default="${Persistence.connectionInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the time, in milliseconds, to wait between connection
          attempts on startup. A negative or zero value means no wait between
          connection attempts.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="availability-interval" type="xs:int" default="${Persistence.availabilityInterval}">
      <xs:annotation>
        <xs:documentation>
          Specifies the time, in milliseconds, between availability checks to
          determine if the PersistenceManager is available. In other words,
          this interval sets how often stores and loaders are polled via their
          `org.infinispan.persistence.spi.CacheWriter#isAvailable` or
          `org.infinispan.persistence.spi.CacheLoader#isAvailable`
          implementation. If a single store or loader is not available, an
          exception is thrown during cache operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-interceptors">
    <xs:sequence>
      <xs:element name="interceptor" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>Deprecated since 10.0, will be removed without a replacement.</xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="property" type="tns:property" minOccurs="0"/>
          </xs:sequence>
          <xs:attribute name="after" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="before" type="xs:string">
            <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation><xs:documentation>A fully qualified class name of the new custom interceptor to add to the configuration.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="index" type="xs:int">
            <xs:annotation><xs:documentation>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</xs:documentation></xs:annotation>
          </xs:attribute>
          <xs:attribute name="position" type="xs:string">
            <xs:annotation><xs:documentation>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</xs:documentation></xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="cache-security">
    <xs:sequence>
      <xs:element name="authorization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures authorization for this cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="${Authorization.enabled}">
            <xs:annotation>
              <xs:documentation>
                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="roles" type="tns:role-list">
            <xs:annotation>
              <xs:documentation>
                Sets the valid roles required to access this cache.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="memory">
    <xs:sequence>
      <xs:choice minOccurs="0" maxOccurs="1">
        <xs:element name="object" type="tns:memory-object">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as instance variables in the Java heap.
              Instances of byte[] are wrapped to ensure equality. This is the
              default storage format.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="binary" type="tns:memory-binary">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as bytes in the Java heap. Cache
              entries are serialized to binary representations. Note that
              binary storage violates object equality. This occurs because
              equality is determined by the equivalence of the resulting
              byte[] instead of the object instances.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="off-heap" type="tns:memory-off-heap">
          <xs:annotation>
            <xs:documentation>
              Store keys and values as bytes in native memory. Cache
              entries are serialized to binary representations. Temporary
              objects are stored in the Java heap space until processing
              completes. Note that off-heap storage violates object equality.
              This occurs because equality is determined by the equivalence of
              the resulting byte[] instead of the object instances.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:choice>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="memory-object">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container as a long. Eviction occurs
          when the number of entries exceeds the size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-binary">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container as a long. Eviction occurs
          either when the number of entries or amount of memory exceeds the
          size.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>
          Specifies whether eviction is based on the number of entries or the
          amount of memory used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="memory-off-heap">
    <xs:attribute name="size" type="xs:long" default="-1">
      <xs:annotation>
        <xs:documentation>
          Defines the size of the data container as a long. Eviction occurs
          either when the number of entries or amount of memory exceeds the
          size.
      </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eviction" type="tns:eviction-type">
      <xs:annotation>
        <xs:documentation>
          Specifies whether eviction is based on the number of entries or the
          amount of memory used.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:eviction-strategy">
      <xs:annotation>
        <xs:documentation>
          Specifies a strategy for evicting cache entries. Eviction always
          takes place when you define the size of the data container. If you
          specify a value for size, then you should configure a strategy.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="clustered-cache" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:cache">
        <xs:sequence>
          <xs:element name="partition-handling" minOccurs="0" maxOccurs="1">
             <xs:annotation>
                <xs:documentation>
                   Configures the way this cache reacts to node crashes and split brains.
                </xs:documentation>
             </xs:annotation>
             <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean" use="optional">
                   <xs:annotation>
                      <xs:documentation>
                         Deprecated, use type instead. Enable/disable the partition handling functionality. Defaults to false.
                      </xs:documentation>
                   </xs:annotation>
                </xs:attribute>
               <xs:attribute name="when-split" type="tns:partition-handling-type" default="${PartitionHandling.whenSplit}">
                 <xs:annotation>
                   <xs:documentation>The type of actions that are possible when a split brain scenario is encountered.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
               <xs:attribute name="merge-policy" type="tns:merge-policy" default="${PartitionHandling.mergePolicy}">
                 <xs:annotation>
                   <xs:documentation>The entry merge policy which should be applied on partition merges.</xs:documentation>
                 </xs:annotation>
               </xs:attribute>
             </xs:complexType>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="mode" type="tns:mode" default="SYNC">
          <xs:annotation>
            <xs:documentation>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="remote-timeout" type="xs:long" default="${Clustering.remoteTimeout}">
          <xs:annotation>
            <xs:documentation>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="invalidation-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="replicated-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>
              Sets the number of hash space segments per cluster. The default
              value is 256. The value should be at least 20 * the cluster size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="distributed-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="owners" type="xs:int" default="${Hash.numOwners}">
          <xs:annotation>
            <xs:documentation>Number of cluster-wide replicas for each cache entry.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="segments" type="xs:int" default="${Hash.numSegments}">
          <xs:annotation>
            <xs:documentation>Sets the number of hash space segments per cluster. The default value is 256. The value should be at least 20 * the cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity-factor" type="xs:double" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>Controls the proportion of entries that will reside on the local node,
              compared to the other nodes in the cluster. Value must be positive. The default is 1</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-lifespan" type="xs:long">
          <xs:annotation>
            <xs:documentation>Maximum lifespan in milliseconds of an entry placed in the L1 cache.
               By default L1 is disabled unless a positive value is configured for this attribute.
               If the attribute is not present, L1 is disabled.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="l1-cleanup-interval" type="xs:long" default="${L1.cleanupTaskFrequency}">
          <xs:annotation>
            <xs:documentation>
              Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="${Hash.capacityFactor}">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="scattered-cache">
    <xs:complexContent>
      <xs:extension base="tns:clustered-cache">
        <xs:sequence>
          <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
            <xs:annotation>
              <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="groups" type="tns:groups" minOccurs="0">
            <xs:annotation>
              <xs:documentation>Configures grouping of data.</xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="segments" type="xs:int" default="256">
          <xs:annotation>
            <xs:documentation>Number of hash space segments (per cluster). The default value is 256, and should be at least 20 * cluster size.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="capacity" type="xs:float" default="1">
          <xs:annotation>
            <xs:documentation>
              Controls the proportion of entries that will reside on the local node, compared to the other nodes
              in the cluster. This is just a suggestion, there is no guarantee that a node with a capacity
              factor of 2 will have twice as many entries as a node with a capacity factor of 1.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="consistent-hash-factory" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The factory to use for generating the consistent hash.
              Must implement `org.infinispan.distribution.ch.ConsistentHashFactory`.
              E.g. `org.infinispan.distribution.ch.impl.SyncConsistentHashFactory` can be used to guarantee
              that multiple distributed caches use exactly the same consistent hash, which for performance
              reasons is not guaranteed by the default consistent hash factory instance used.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="key-partitioner" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The name of the key partitioner class.
              Must implement `org.infinispan.distribution.ch.KeyPartitioner`.
              A custom key partitioner can be used as an alternative to grouping, to guarantee that some keys
              are located in the same segment (and thus their primary owner is the same node).
              Since 8.2.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="invalidation-batch-size" type="xs:integer" default="128">
          <xs:annotation>
            <xs:documentation>
              Threshold for sending batch invalidations. Once a node registers more updated keys,
              it sends a batch invalidation to all nodes requesting to remove old versions of the entries.
              The threshold is also used for second batch invalidation of tombstones for removed entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="loader" abstract="true">
    <xs:sequence>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>A cache loader property with name and value.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="name" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>
          Determines if a cache loader is shared between cache instances.
          Values are true / false (default). This property prevents duplicate
          writes of data to the cache loader by different cache instances. An
          example is where all cache instances in a cluster use the same JDBC
          settings for the same remote, shared database. If true, only the
          nodes where modifications originate write to the cache store. If
          false, each cache reacts to potential remote updates by storing the
          data to the cache store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>
          Pre-loads data into memory from the cache loader when the cache
          starts. Values are true / false (default). This property is useful
          when data in the cache loader is required immediately after startup
          to prevent delays with cache operations when the data is loaded
          lazily. This property can provide a "warm cache" on startup but it
          impacts performance because it affects start time. Pre-loading data
          is done locally, so any data loaded is stored locally in the node
          only. Pre-loaded data is not replicated or distributed. Likewise,
          data is pre-loaded only up to the maximum configured number of
          entries in eviction.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="cluster-loader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="remote-timeout" type="xs:long" default="${ClusterLoader.remoteCallTimeout}">
          <xs:annotation>
            <xs:documentation>The timeout when performing remote calls.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="store" abstract="true">
    <xs:sequence>
      <xs:element name="write-behind" type="tns:write-behind" minOccurs="0" maxOccurs="1">
        <xs:annotation>
          <xs:documentation>
            Configures cache stores as write-behind instead of write-through.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Defines a cache store property with name and value.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="shared" type="xs:boolean" default="${AbstractStore.shared}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="transactional" type="xs:boolean" default="${AbstractStore.transactional}">
      <xs:annotation>
        <xs:documentation>This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and cache's transactions rollingback.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="preload" type="xs:boolean" default="${AbstractStore.preload}">
      <xs:annotation>
        <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fetch-state" type="xs:boolean" default="${AbstractStore.fetchPersistentState}">
      <xs:annotation>
        <xs:documentation>Fetches the persistent state of a cache when joining
          a cluster. Values are true / false (default). The purpose of this
          property is to retrieve the persistent state of a cache and apply it to the local cache store of a node when it joins a cluster. Fetching
          the persistent state does not apply if a cache store is shared because it accesses the same data as the other stores. This property can be `true` for one configured cache loader only. If more than
          one cache loader fetches the persistent state, a configuration exception is thrown when the cache service starts.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="purge" type="xs:boolean" default="${AbstractStore.purgeOnStartup}">
      <xs:annotation>
        <xs:documentation>
          Empties the specified cache loader at startup. Values are true /
          false (default). This property takes effect only if read-only is
          false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="read-only" type="xs:boolean" default="${AbstractStore.ignoreModifications}">
      <xs:annotation>
        <xs:documentation>
          Prevents data from being persisted to cache stores. Values are true /
          false (default). If true, cache stores load entries only. Any
          modifications to data in the cache do not apply to cache stores.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="max-batch-size" type="xs:int" default="${AbstractStore.maxBatchSize}">
      <xs:annotation>
        <xs:documentation>
          Sets the maximum size of a batch to insert or delete from the cache
          store. If the value is less than one, no upper limit applies to the
          number of operations in a batch.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segmented" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          Configures cache stores to store data in hash space segments, with the
          "hash.numSegments" property defining the number of segments.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="write-behind">
    <xs:attribute name="modification-queue-size" type="xs:int" default="${AsyncStore.modificationQueueSize}">
      <xs:annotation>
        <xs:documentation>
          Specifies the maximum number of entries in the asynchronous
          modification queue. When the queue is full, write-through mode is
          used until the queue can accept new entries.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="thread-pool-size" type="xs:int" default="${AsyncStore.threadPoolSize}">
      <xs:annotation>
        <xs:documentation>
          Specifies the number of threads to apply modifications to the cache
          store.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="fail-silently" type="xs:boolean" default="${AsyncStore.failSilently}">
      <xs:annotation>
        <xs:documentation>
          Controls how asynchronous write operations take place when cache
          stores become unavailable. If "true", asynchronous write operations
          that fail are re-attempted with the number of times specified in the
          "connection-attempts" parameter. If all attempts fail, errors are
          ignored and write operations are not executed on the cache store. If
          "false", asynchronous write operations that fail are re-attempted
          when the underlying store becomes available. If the modification
          queue becomes full before the underlying store becomes available, an
          error is thrown on all future write operations to the store until the
          modification queue is flushed. The modification queue is not
          persisted. If the underlying store does not become available before
          the asynchronous store is stopped, queued modifications are lost.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="custom-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="class" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the class name of a cache store that
              implements either `CacheLoader`, `CacheWriter`, or both.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="file-store">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="max-entries" type="xs:int">
          <xs:annotation>
            <xs:documentation>
              Specifies the maximum number of entries that the file store can
              hold. To increase the speed of lookups, Single File cache stores
              index keys and their locations in the file. To avoid excessive
              memory usage, you can configure the maximum number of entries so
              that entries are removed permanently from both memory and the
              cache store when the maximum is exceeded. However, this can lead
              to data loss. You should only set a maximum number of entries if
              data can be recomputed or retrieved from an authoritative data
              store. By default, the value is `-1` which means that there is no
              maximum number of entries.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="relative-to" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Defines the root path on the file system where data is stored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              Defines a location in the root path, specified in "relative-to",
              where the cache state is stored. Defaults to the name of the
              cache container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="remote-server">
    <xs:attribute name="host" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          The hostname or ip address of a remote Hot Rod server
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="port" type="xs:int" default="11222">
      <xs:annotation>
        <xs:documentation>
          The port on which the server is listening (default 11222)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="outbound-socket-binding" type="xs:string">
      <xs:annotation><xs:documentation>Unused XML attribute.</xs:documentation></xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="state-transfer">
    <xs:attribute name="enabled" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${StateTransfer.timeout}">
      <xs:annotation>
        <xs:documentation>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chunk-size" type="xs:integer" default="${StateTransfer.chunkSize}">
      <xs:annotation>
        <xs:documentation>The number of cache entries to batch in each transfer.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="await-initial-transfer" type="xs:boolean" default="${StateTransfer.awaitInitialTransfer}">
      <xs:annotation>
        <xs:documentation>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="groups">
    <xs:sequence>
      <xs:element name="grouper" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="class" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="enabled" type="xs:boolean">
      <xs:annotation>
        <xs:documentation>
          Enables or disables grouping.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backups">
    <xs:sequence>
      <xs:element name="backup" type="tns:backup" minOccurs="0" maxOccurs="unbounded">
        <xs:annotation>
          <xs:documentation>
            Configures a remote site as a backup location for cache data.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="backup">
    <xs:sequence>
      <xs:element name="take-offline" type="tns:take-offline" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Specifies the number of failures that can occur before backup locations go offline.
          </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="state-transfer" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Modifies state transfer operations.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="chunk-size" type="xs:int" default="${XSiteStateTransfer.chunkSize}">
            <xs:annotation>
               <xs:documentation>
                 Specifies how many cache entries are batched in each transfer request.
               </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="timeout" type="xs:long" default="${XSiteStateTransfer.timeout}">
            <xs:annotation>
              <xs:documentation>
                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                received and applied. Default value is 20 min.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="max-retries" type="xs:int" default="${XSiteStateTransfer.maxRetries}">
            <xs:annotation>
              <xs:documentation>
                Sets the maximum number of retry attempts for push state failures. Specify a value of 0 (zero) to disable retry attempts. The default value is 30.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="wait-time" type="xs:long" default="${XSiteStateTransfer.waitTime}">
            <xs:annotation>
              <xs:documentation>
                Sets the amount of time, in milliseconds, to wait between retry attempts for push state failures. You must specify a value of 1 or more. The default value is 2000.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="site" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          Names the remote site to which the cache backs up data.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="strategy" type="tns:mode" default="${Backup.strategy}">
      <xs:annotation>
        <xs:documentation>
          Sets the strategy for backing up to a remote site.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy" type="tns:backup-failure-policy" default="${Backup.backupFailurePolicy}">
      <xs:annotation>
        <xs:documentation>
          Controls how local writes to caches are handled if synchronous backup operations fail.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:long" default="${Backup.replicationTimeout}">
      <xs:annotation>
        <xs:documentation>
          Specifies timeout, in milliseconds, for synchronous and asynchronous backup operations.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="${Backup.enabled}">
      <xs:annotation>
        <xs:documentation>
          Enables backup locations. Set the value to "false" to disable backups.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="two-phase-commit" use="optional" type="xs:boolean" default="${Backup.useTwoPhaseCommit}">
      <xs:annotation>
        <xs:documentation>
          Enables two-phase commits for optimistic transactional caches with
          the synchronous backup strategy only.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="failure-policy-class" use="optional" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Specifies the fully qualified name of a class that implements the
          CustomFailurePolicy interface. Use if failure-policy="CUSTOM".
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="take-offline">
    <xs:attribute name="after-failures" type="xs:int" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the number of consecutive failures that can occur for backup
          operations before sites go offline. Specify a negative or zero value
          to ignore this attribute and use minimum wait time only ("min-wait").
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="min-wait" type="xs:long" default="0">
      <xs:annotation>
        <xs:documentation>
          Sets the minimum time to wait, in milliseconds, before sites go
          offline when backup operations fail. If subsequent operations are
          successful, the minimum wait time is reset. If you set
          "after-failures", sites go offline when the wait time is reached and
          the number of failures occur.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="property">
    <xs:simpleContent>
      <xs:extension base="xs:string">
        <xs:attribute name="name" type="xs:string" use="required">
          <xs:annotation>
            <xs:documentation>Defines the name of a property.</xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:simpleContent>
  </xs:complexType>

  <xs:simpleType name="isolation">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_UNCOMMITTED">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures READ_COMMITTED</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_COMMITTED">
        <xs:annotation>
          <xs:documentation>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REPEATABLE_READ">
        <xs:annotation>
          <xs:documentation>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SERIALIZABLE">
        <xs:annotation>
          <xs:documentation>Unsupported. Actually configures REPEATABLE_READ</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Cache will not enlist within transactions.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BATCH">
        <xs:annotation>
          <xs:documentation>Uses batching to group cache operations together.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.Synchronization</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NON_DURABLE_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FULL_XA">
        <xs:annotation>
          <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="indexing">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not index data. This is the default.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LOCAL">
        <xs:annotation>
          <xs:documentation>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>Index all data</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PRIMARY_OWNER">
        <xs:annotation>
          <xs:documentation>Only index changes on the primary owner, regardless of it's local or remote.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-strategy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If you define a size for the data container,
            you should specify either the REMOVE or EXCEPTION exiction strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MANUAL">
        <xs:annotation>
          <xs:documentation>
            Manually evict entries. This strategy is the same as NONE but does
            not log errors if you enable passivation without eviction.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE">
        <xs:annotation>
          <xs:documentation>
            Automatically evict older entries to make space for new entries. By
            default REMOVE is always used when you define a size for the data
            container unless you configure the EXCEPTION strategy.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXCEPTION">
        <xs:annotation>
          <xs:documentation>
            Do not evict entries. If the data container reaches the maximum
            size, exceptions occur for requests to create new entries. You can
            use this eviction strategy only with transactional caches that use
            two phase commit.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNORDERED">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIFO">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LRU">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIRS">
        <xs:annotation>
          <xs:documentation>Deprecated. Activates REMOVE policy.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="ASYNC">
        <xs:annotation>
          <xs:documentation>
            Enables asynchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SYNC">
        <xs:annotation>
          <xs:documentation>
            Enables synchronous mode.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="locking-mode">
    <xs:restriction base="xs:token">
      <xs:enumeration value="OPTIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Optimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PESSIMISTIC">
        <xs:annotation>
          <xs:documentation>Enables Pessimistic locking.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="aliases">
    <xs:annotation>
      <xs:documentation>A list of aliases.</xs:documentation>
    </xs:annotation>
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="backup-failure-policy">
    <xs:restriction base="xs:token">
      <xs:enumeration value="IGNORE">
        <xs:annotation>
          <xs:documentation>
            Ignore failed backup operations and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WARN">
        <xs:annotation>
          <xs:documentation>
            Log exceptions when backup operations fail and write to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FAIL">
        <xs:annotation>
          <xs:documentation>
            Throw exceptions when backup operations fail and attempt to stop writes to the local cache.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="CUSTOM">
        <xs:annotation>
          <xs:documentation>
            Use a custom failure policy. Requires the "failure-policy-class" attribute.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="shutdown-hook-behavior">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REGISTER">
        <xs:annotation>
          <xs:documentation>Register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DONT_REGISTER">
        <xs:annotation>
          <xs:documentation>Don't register a shutdown hook</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="transaction-protocol">
    <xs:annotation>
      <xs:documentation>
        (Deprecated since 10.0. It is going to be removed) Enumeration containing the available commit protocols
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT" />
      <xs:enumeration value="TOTAL_ORDER" />
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="eviction-type">
    <xs:restriction base="xs:string">
      <xs:enumeration value="COUNT">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the number of entries reaches the
            configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="MEMORY">
        <xs:annotation>
          <xs:documentation>
            Evict entries from the cache when the amount of memory in use
            reaches the configured size.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="versioning-scheme">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIMPLE">
        <xs:annotation>
          <xs:documentation>
            A simple versioning scheme that is cluster-aware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Don't version entries
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="permission-list">
    <xs:list itemType="tns:permission"/>
  </xs:simpleType>

  <xs:simpleType name="permission">
    <xs:restriction base="xs:string">
      <xs:enumeration value="LIFECYCLE">
        <xs:annotation>
          <xs:documentation>
            Allows control of a cache's lifecycle (i.e. starting and stopping a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ">
        <xs:annotation>
          <xs:documentation>
            Allows reading data from a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows writing data to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="EXEC">
        <xs:annotation>
          <xs:documentation>
            Allows performing task execution (e.g. distributed executors, map/reduce) on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LISTEN">
        <xs:annotation>
          <xs:documentation>
            Allows attaching listeners to a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_READ">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-read operations (e.g. obtaining all the keys in a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="BULK_WRITE">
        <xs:annotation>
          <xs:documentation>
            Allows bulk-write operations (e.g. clearing a cache)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ADMIN">
        <xs:annotation>
          <xs:documentation>
            Allows performing "administrative" operations on a cache
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all of the others
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_READ">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all read permissions (READ and BULK_READ)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALL_WRITE">
        <xs:annotation>
          <xs:documentation>
            Aggregate permission which implies all write permissions (WRITE and BULK_WRITE)
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Permission which means no permissions
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="role-list">
    <xs:list itemType="xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="partition-handling-type">
    <xs:restriction base="xs:token">
      <xs:enumeration value="DENY_READ_WRITES">
        <xs:annotation>
          <xs:documentation>If the partition does not have all owners for a given segment, both reads and writes are denied for all keys in that segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READS">
        <xs:annotation>
          <xs:documentation>Allows reads for a given key if it exists in this partition, but only allows writes if this partition contains all owners of a segment.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="ALLOW_READ_WRITES">
        <xs:annotation>
          <xs:documentation>Allow entries on each partition to diverge, with conflicts resolved during merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="merge-policy">
    <xs:union memberTypes="tns:merge-policy-defaults xs:string"/>
  </xs:simpleType>

  <xs:simpleType name="merge-policy-defaults">
    <xs:restriction base="xs:token">
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>Do not attempt to resolve conflicts on merge.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_ALWAYS">
        <xs:annotation>
          <xs:documentation>Always utilise the entry located in the preferred partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PREFERRED_NON_NULL">
        <xs:annotation>
          <xs:documentation>Utilise entries from the preferred partition if non-null, otherwise utilise entries from the other partition.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REMOVE_ALL">
        <xs:annotation>
          <xs:documentation>If a conflict is encountered for a given key, remove all versions of that key.</xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <!-- JGroups extension attributes -->
  <xs:attribute name="stack.combine" default="COMBINE">
    <xs:simpleType>
      <xs:restriction base="xs:token">
        <xs:enumeration value="COMBINE">
          <xs:annotation>
            <xs:documentation>Combines the protocol attributes, overriding any that have been set in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="INSERT_AFTER">
          <xs:annotation>
            <xs:documentation>Inserts the protocol after an existing protocol in the stack, referenced using the stack.position attribute.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REPLACE">
          <xs:annotation>
            <xs:documentation>Replaces the protocol in the base stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
        <xs:enumeration value="REMOVE">
          <xs:annotation>
            <xs:documentation>Removes the protocol from the stack.</xs:documentation>
          </xs:annotation>
        </xs:enumeration>
      </xs:restriction>
    </xs:simpleType>
  </xs:attribute>

  <xs:attribute name="stack.position" type="xs:string" />

</xs:schema>
