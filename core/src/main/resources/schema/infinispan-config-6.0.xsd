<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" version="1.0" targetNamespace="urn:infinispan:config:6.0" xmlns:tns="urn:infinispan:config:6.0" xmlns:xs="http://www.w3.org/2001/XMLSchema">

  <xs:element name="infinispan">
    <xs:annotation>
      <xs:documentation>
        Defines the configuration for Infinispan, for the cache manager configuration, for the default cache, and for named caches.
      </xs:documentation>
    </xs:annotation>
    <xs:complexType>
        <xs:sequence>
        <xs:element name="global" minOccurs="0">
          <xs:complexType>
            <xs:annotation>
              <xs:documentation>
                Defines global settings shared among all cache instances created by a single CacheManager.
              </xs:documentation>
            </xs:annotation>
            <xs:all>
              <xs:element name="asyncListenerExecutor" type="tns:executorFactory" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the executor service used to emit notifications to asynchronous listeners
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="asyncTransportExecutor" type="tns:executorFactory" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the executor service used for asynchronous work on the Transport, including asynchronous marshalling and Cache 'async operations' such as Cache.putAsync().
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="remoteCommandsExecutor" type="tns:executorFactory" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the executor service used to execute remote commands. Use org.infinispan.executors.WithinThreadExecutorFactory to disable.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="evictionScheduledExecutor" type="tns:scheduledExecutorFactory" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the scheduled executor service used to periodically run eviction cleanup tasks.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="replicationQueueScheduledExecutor" type="tns:scheduledExecutorFactory" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the scheduled executor service used to periodically flush replication queues, used if asynchronous clustering is enabled along with useReplQueue being set to true.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
                <xs:element name="totalOrderExecutor" type="tns:executorFactory" minOccurs="0">
                    <xs:annotation>
                        <xs:documentation>
                            Configuration for the total order executor service used to concurrent validate non conflicting transactions
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
              <xs:element name="site" type="tns:site" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configuration for the x-site replication.
                  </xs:documentation>
                </xs:annotation>
              </xs:element>
              <xs:element name="globalJmxStatistics" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    This element specifies whether global statistics are gathered and reported via JMX for all caches under this cache manager.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="properties" type="tns:properties" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Sets properties which are then passed to the MBean Server Lookup implementation specified.
                        </xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="allowDuplicateDomains" type="xs:boolean" default="false">
                   <xs:annotation>
                     <xs:documentation>
                       If true, multiple cache manager instances could be configured under the same configured JMX domain. Each cache manager will in practice use a different JMX domain that has been calculated based on the configured one by adding an incrementing index to it.
                     </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="cacheManagerName" type="xs:string" default="DefaultCacheManager">
                   <xs:annotation>
                     <xs:documentation>
                       If JMX statistics are enabled, this property represents the name of this cache manager. It offers the possibility for clients to provide a user-defined name to the cache manager which later can be used to identify the cache manager within a JMX based management tool amongst other cache managers that might be running under the same JVM.
                     </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="enabled" type="xs:boolean" default="false">
                    <xs:annotation>
                      <xs:documentation>Enable Global JMX statistics</xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="jmxDomain" type="xs:string" default="org.infinispan">
                   <xs:annotation>
                     <xs:documentation>
                       If JMX statistics are enabled then all 'published' JMX objects will appear under this name. This is optional, if not specified an object name will be created for you by default.
                     </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="mBeanServerLookup" type="xs:string" default="org.infinispan.jmx.PlatformMBeanServerLookup">
                   <xs:annotation>
                     <xs:documentation>
                       Class that will attempt to locate a JMX MBean server to bind to. Defaults to using the platform MBean server.
                     </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="transport" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    This element configures the transport used for network communications across the cluster.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="properties" type="tns:properties" minOccurs="0">
                      <xs:annotation>
                         <xs:documentation>
                            Sets transport properties
                         </xs:documentation>
                      </xs:annotation>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="clusterName" type="xs:string" default="ISPN">
                    <xs:annotation>
                      <xs:documentation>
                         Defines the name of the cluster. Nodes only connect to clusters sharing the same name.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="distributedSyncTimeout" type="xs:long" default="240000">
                    <xs:annotation>
                      <xs:documentation>
                        Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing which means that only one cache can be doing state transfer or rehashing at the same time. This constraint is in place because more than one cache could be involved in a transaction. This timeout controls the time to wait to acquire acquire a lock on the distributed lock. Defaults to 4 minutes.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="machineId" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        The id of the machine where this node runs. Visit http://community.jboss.org/wiki/DesigningServerHinting for more information .
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="nodeName" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        Name of the current node. This is a friendly name to make logs, etc. make more sense. Defaults to a combination of host name and a random number (to differentiate multiple nodes on the same host)
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="rackId" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        The id of the rack where this node runs. Visit http://community.jboss.org/wiki/DesigningServerHinting for more information .
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="siteId" type="xs:string">
                    <xs:annotation>
                      <xs:documentation>
                        The id of the site where this node runs. Visit http://community.jboss.org/wiki/DesigningServerHinting for more information .
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="strictPeerToPeer" type="xs:boolean" default="false">
                    <xs:annotation>
                      <xs:documentation>
                        If set to true, RPC operations will fail if the named cache does not exist on remote nodes with a NamedCacheNotFoundException. Otherwise, operations will succeed but it will be logged on the caller that the RPC did not succeed on certain nodes due to the named cache not being available.
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="transportClass" type="xs:string" default="org.infinispan.remoting.transport.jgroups.JGroupsTransport">
                    <xs:annotation>
                      <xs:documentation>
                        Class that represents a network transport. Must implement org.infinispan.remoting.transport.Transport
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="serialization" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    Configures serialization and marshalling settings.
                  </xs:documentation>
                </xs:annotation>
                
                <xs:complexType>
                  <xs:sequence>
                    <xs:element name="advancedExternalizers" minOccurs="0">
                      <xs:annotation>
                        <xs:documentation>
                          Configures custom marshallers.
                        </xs:documentation>
                      </xs:annotation>
                        <xs:complexType>
                          <xs:sequence>
                            <xs:element name="advancedExternalizer" minOccurs="0" maxOccurs="unbounded">
                              <xs:annotation>
                                <xs:documentation>
                                  AdvancedExternalizer provides an alternative way to provide externalizers for marshalling/unmarshalling user defined classes that overcome the deficiencies of the more user-friendly externalizer definition  model explained in Externalizer.
                                </xs:documentation>
                              </xs:annotation>
                              <xs:complexType>
                                <xs:attribute name="externalizerClass" type="xs:string">
                                  <xs:annotation>
                                    <xs:documentation>
                                      Class of the custom marshaller
                                    </xs:documentation>
                                  </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="id" type="xs:int">
                                  <xs:annotation>
                                    <xs:documentation>
                                      Id of the custom marshaller
                                    </xs:documentation>
                                  </xs:annotation>
                                </xs:attribute>
                              </xs:complexType>
                            </xs:element>
                          </xs:sequence>
                        </xs:complexType>
                    </xs:element>
                  </xs:sequence>
                  <xs:attribute name="marshallerClass" type="xs:string" default="org.infinispan.marshall.VersionAwareMarshaller.VersionAwareMarshaller">
                   <xs:annotation>
                      <xs:documentation>
                         Fully qualified name of the marshaller to use. It must implement org.infinispan.marshall.StreamingMarshaller
                      </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="version" type="xs:string" default="53">
                   <xs:annotation>
                      <xs:documentation>
                         Largest allowable version to use when marshalling internal state. Set this to the lowest version cache instance in your cluster to ensure compatibility of communications. However, setting this too low will mean you lose out on the benefit of improvements in newer versions of the marshaller.
                      </xs:documentation>
                   </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="shutdown" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    This element specifies behavior when the JVM running the cache instance shuts down.
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:attribute name="hookBehavior" type="tns:shutdownHookBehavior">
                    <xs:annotation>
                      <xs:documentation>
                        Behavior of the JVM shutdown hook registered by the cache
                      </xs:documentation>
                    </xs:annotation>
                  </xs:attribute>
                </xs:complexType>
              </xs:element>
              <xs:element name="modules" minOccurs="0">
                <xs:annotation>
                  <xs:documentation>
                    This element contains configuration options for additional modules which affect global configuration
                  </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                  <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:any namespace="##other"/>
                  </xs:sequence>
                </xs:complexType>
              </xs:element>
            </xs:all>
          </xs:complexType>
        </xs:element>
        <xs:element name="default" type="tns:configuration" minOccurs="0">
          <xs:annotation>
            <xs:documentation>
              Specifies the default behavior for all named caches belonging to this cache manager.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
        <xs:element name="namedCache" type="tns:configuration" minOccurs="0" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>
              Specify the configuration for a named cache.
            </xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>

  <xs:complexType name="configuration">
    <xs:all>
      <xs:element name="locking" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines the local, in-VM locking and concurrency characteristics of the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="concurrencyLevel" type="xs:int" default="32">
            <xs:annotation>
              <xs:documentation>
                Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan. Similar to the concurrencyLevel tuning parameter seen in the JDK's ConcurrentHashMap. Defaults to 32.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="isolationLevel" type="tns:isolationLevel" default="READ_COMMITTED">
            <xs:annotation>
              <xs:documentation>
                Cache isolation level. Infinispan only supports READ_COMMITTED or REPEATABLE_READ isolation levels. See http://en.wikipedia.org/wiki/Isolation_level for a discussion on isolation levels. Defaults to READ_COMMITTED
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lockAcquisitionTimeout" type="xs:long" default="10000">
            <xs:annotation>
              <xs:documentation>
                Maximum time to attempt a particular lock acquisition. Defaults to 10 seconds
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="useLockStriping" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="writeSkewCheck" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                This setting is only applicable in the case of REPEATABLE_READ. When write skew check is set to false, if the writer at commit time discovers that the working entry and the underlying entry have different versions, the working entry will overwrite the underlying entry. If true, such version conflict - known as a write-skew - will throw an Exception. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="supportsConcurrentUpdates" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                  This option was deprecated in version 6.0 and can no longer be configured. It is now assumed to be always true.
                  For non-transactional caches only: if set to true(default value) the cache keeps data consistent in the case of concurrent updates. For clustered caches this comes at the cost of an additional RPC, so if you don't expect your application to write data concurrently, disabling this flag increases performance.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="loaders" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configuration for cache loaders and stores.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="loader" minOccurs="0" maxOccurs="unbounded" type="tns:customStore">
              <xs:annotation>
                <xs:documentation>
                  Configuration of a specific cache loader
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="store" minOccurs="0" maxOccurs="unbounded" type="tns:customStore">
              <xs:annotation>
                <xs:documentation>
                  Configuration of a specific cache store
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="clusterLoader" minOccurs="0" maxOccurs="unbounded" type="tns:clusterLoader">
              <xs:annotation>
                <xs:documentation>
                  Configuration of a ClusterCacheLoader
                </xs:documentation>
              </xs:annotation>
            </xs:element>
            <xs:element name="fileStore" minOccurs="0" maxOccurs="unbounded" type="tns:fileStore">
              <xs:annotation>
                <xs:documentation>
                  Configuration of a FileCacheStore
                </xs:documentation>
              </xs:annotation>
            </xs:element>
             <xs:element name="singleFileStore" minOccurs="0" maxOccurs="unbounded" type="tns:singleFileStore">
                <xs:annotation>
                   <xs:documentation>
                      Configuration of a FileCacheStore
                   </xs:documentation>
                </xs:annotation>
             </xs:element>
            <xs:any namespace="##other" minOccurs="0" maxOccurs="unbounded" />
          </xs:sequence>
          <xs:attribute name="passivation" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. This gives you the ability to 'overflow' to disk, similar to swapping in an operating system. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="preload" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="shared" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store. Note that this could be useful if each individual node has its own cache store - perhaps local on-disk. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="sites" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Cache configuration for the x-site replication.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence minOccurs="0" maxOccurs="unbounded">
              <xs:element name="backups" minOccurs="0" maxOccurs="unbounded">
                  <xs:annotation>
                      <xs:documentation>
                          Configures the list of sites where this cache backups.
                      </xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                      <xs:sequence minOccurs="0" maxOccurs="1">
                          <xs:element name="backup" minOccurs="0" maxOccurs="unbounded" type="tns:backup">
                              <xs:annotation>
                                  <xs:documentation>
                                      Configures a specific site where this cache backups data. The name of the backup
                                      must match
                                      a site defined in the "global" section.
                                  </xs:documentation>
                              </xs:annotation>
                          </xs:element>
                      </xs:sequence>
                  </xs:complexType>
              </xs:element>
              <xs:element name="backupFor" minOccurs="0" maxOccurs="1">
                  <xs:annotation>
                      <xs:documentation>
                          Configures this cache as a backup for a remote cache.
                      </xs:documentation>
                  </xs:annotation>
                  <xs:complexType>
                      <xs:attribute name="remoteCache" type="xs:string" use="optional">
                          <xs:annotation>
                              <xs:documentation>
                                  The name of the remote cache that backups data here.
                              </xs:documentation>
                          </xs:annotation>
                      </xs:attribute>
                      <xs:attribute name="remoteSite" type="xs:string" use="optional">
                          <xs:annotation>
                              <xs:documentation>
                                  The name of the remote site containing the cache that backups data here.
                              </xs:documentation>
                          </xs:annotation>
                      </xs:attribute>
                  </xs:complexType>
              </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="transaction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines transactional (JTA) characteristics of the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="recovery" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Defines recovery configuration for the cache.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean" use="required">
                  <xs:annotation>
                    <xs:documentation>
                      Enable recovery for this cache.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="recoveryInfoCacheName" type="xs:string" default="__recoveryInfoCacheName__">
                  <xs:annotation>
                    <xs:documentation>
                      Sets the name of the cache where recovery related information is held. The cache's default name is "__recoveryInfoCacheName__"
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="cacheStopTimeout" type="xs:int" default="30000">
            <xs:annotation>
              <xs:documentation>
                If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout. It is recommended that this value does not exceed the transaction timeout because even if a new transaction was started just before the cache was stopped, this could only last as long as the transaction timeout allows it. Defaults to 30 seconds.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="completedTxTimeout" type="xs:long" default="15000">
            <xs:annotation>
              <xs:documentation>
                The duration (millis) in which to keep information about the completion of a transaction. Defaults to 15000.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="reaperWakeUpInterval" type="xs:long" default="1000">
            <xs:annotation>
              <xs:documentation>
                The time interval (millis) at which the thread that cleans up transaction completion information kicks in. Defaults to 1000.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="eagerLockSingleNode" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                 Only has effect for DIST mode and when useEagerLocking is set to true. When this is enabled, then only one node is locked in the cluster, disregarding numOwners config. On the opposite, if this is false, then on all cache.lock() calls numOwners RPCs are being performed. The node that gets locked is the main data owner, i.e. the node where data would reside if numOwners==1. If the node where the lock resides crashes, then the transaction is marked for rollback - data is in a consistent state, no fault tolerance. Starting with Infinispan 5.1 single node locking is used by default.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="syncCommitPhase" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                If true, the cluster-wide commit phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the commit was sent. Otherwise, the commit phase will be asynchronous. Keeping it as false improves performance of 2PC transactions, since any remote failures are trapped during the prepare phase anyway and appropriate rollbacks are issued.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="syncRollbackPhase" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                If true, the cluster-wide rollback phase in two-phase commit (2PC) transactions will be synchronous, so Infinispan will wait for responses from all nodes to which the rollback was sent. Otherwise, the rollback phase will be asynchronous. Keeping it as false improves performance of 2PC transactions.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="transactionManagerLookupClass" type="xs:string" default="org.infinispan.transaction.lookup.GenericTransactionManagerLookup.GenericTransactionManagerLookup">
            <xs:annotation>
              <xs:documentation>
                Configure Transaction manager lookup directly using an instance of TransactionManagerLookup. Calling this method marks the cache as transactional.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="useEagerLocking" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                 Only has effect for DIST mode and when useEagerLocking is set to true. When this is enabled, then only one node is locked in the cluster, disregarding numOwners config. On the opposite, if this is false, then on all cache.lock() calls numOwners RPCs are being performed. The node that gets locked is the main data owner, i.e. the node where data would reside if numOwners==1. If the node where the lock resides crashes, then the transaction is marked for rollback - data is in a consistent state, no fault tolerance. Note: Starting with infinispan 5.1 eager locking is replaced with pessimistic locking and can be enforced by setting transaction's locking mode to PESSIMISTIC.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="useSynchronization" type="xs:boolean" default="true">
           <xs:annotation>
              <xs:documentation>
                 Configures whether the cache registers a synchronization with the transaction manager, or registers itself as an XA resource. It is often unnecessary to register as a full XA resource unless you intend to make use of recovery as well, and registering a synchronization is significantly more efficient.
              </xs:documentation>
           </xs:annotation>
          </xs:attribute>
          <xs:attribute name="lockingMode" type="tns:lockingMode" default="OPTIMISTIC">
            <xs:annotation>
              <xs:documentation>
                Configures whether the cache uses optimistic or pessimistic locking. If the cache is not transactional then the locking mode is ignored. See transactioMode.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="transactionMode" type="tns:transactionMode">
            <xs:annotation>
              <xs:documentation>
                Configures whether the cache is transactional or not. If unspecified, it defaults to NON_TRANSACTIONAL unless invocationBatching is enabled.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="autoCommit" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                If the cache is transactional and transactionAutoCommit is enabled then for single operation transactions the user doesn't need to manually start a transaction, but a transactions is injected by the system. Defaults to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="use1PcForAutoCommitTransactions" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Before Infinispan 5.1 you could access the cache both transactionally and non-transactionally. Naturally the non-transactional access is faster and offers less consistency guarantees. From Infinispan 5.1 onwards, mixed access is no longer supported, so if you wanna speed up transactional caches and you're ready to trade some consistency guarantees, you can enable use1PcForAutoCommitTransactions. What this configuration option does is force an induced transaction, that has been started by Infinispan as a result of enabling autoCommit, to commit in a single phase. So only 1 RPC instead of 2RPCs as in the case of a full 2 Phase Commit (2PC).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
            <xs:attribute name="transactionProtocol" type="tns:transactionProtocol">
                <xs:annotation>
                    <xs:documentation>
                        Configures the commit protocol to use.
                    </xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="customInterceptors" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures custom interceptors to be added to the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="interceptor" minOccurs="0" maxOccurs="unbounded">
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="properties" type="tns:properties" minOccurs="0"/>
                </xs:sequence>
                <xs:attribute name="after" type="xs:string">
                   <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately after the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="before" type="xs:string">
                   <xs:annotation><xs:documentation>Dictates that the custom interceptor appears immediately before the specified interceptor. If the specified interceptor is not found in the interceptor chain, a ConfigurationException will be thrown when the cache starts.</xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="class" type="xs:string">
                   <xs:annotation><xs:documentation>A fully qualified class name of the new custom interceptor to add to the configuration.</xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="index" type="xs:int">
                   <xs:annotation><xs:documentation>Specifies a position in the interceptor chain to place the new interceptor. The index starts at 0 and goes up to the number of interceptors in a given configuration. A ConfigurationException is thrown if the index is less than 0 or greater than the maximum number of interceptors in the chain.</xs:documentation></xs:annotation>
                </xs:attribute>
                <xs:attribute name="position" type="xs:string">
                   <xs:annotation><xs:documentation>Specifies a position where to place the new interceptor. Allowed values are FIRST, LAST, and OTHER_THAN_FIRST_OR_LAST</xs:documentation></xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="dataContainer" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls the data container for the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="properties" type="tns:properties" minOccurs="0">
              <xs:annotation>
                <xs:documentation>Properties passed to the data container</xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
           <xs:attribute name="class" type="xs:string">
              <xs:annotation>
                 <xs:documentation>
                    Fully qualified class name of the data container to use
                 </xs:documentation>
              </xs:annotation>
           </xs:attribute>
           <xs:attribute name="keyEquivalence" type="xs:string">
              <xs:annotation>
                 <xs:documentation>
                    Fully qualified class name of the Equivalence class to use
                    for keys stored in the cache, which provides with custom
                    ways to compare cached keys
                 </xs:documentation>
              </xs:annotation>
           </xs:attribute>
           <xs:attribute name="valueEquivalence" type="xs:string">
              <xs:annotation>
                 <xs:documentation>
                    Fully qualified class name of the Equivalence class to use
                    for values stored in the cache, which provides with custom
                    ways to compare cached values
                 </xs:documentation>
              </xs:annotation>
           </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="eviction" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls the eviction settings for the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="maxEntries" type="xs:int" default="-1">
            <xs:annotation>
              <xs:documentation>
                Maximum number of entries in a cache instance. Cache size is guaranteed not to exceed upper limit specified by max entries. However, due to the nature of eviction it is unlikely to ever be exactly maximum number of entries specified here.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="strategy" type="tns:evictionStrategy" default="NONE">
            <xs:annotation>
              <xs:documentation>
                Eviction strategy. Available options are 'UNORDERED', 'LRU', 'LIRS' and 'NONE' (to disable eviction, the default value).
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="threadPolicy" type="tns:evictionThreadPolicy" default="DEFAULT">
            <xs:annotation>
              <xs:documentation>
                Threading policy for eviction. Defaults to using the DEFAULT eviction policy.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="expiration" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls the default expiration settings for entries in the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
           <xs:attribute name="wakeUpInterval" type="xs:long" default="1000">
            <xs:annotation>
              <xs:documentation>
                Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set wakeupInterval to -1.
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
           <xs:attribute name="lifespan" type="xs:long" default="-1">
            <xs:annotation>
              <xs:documentation>
                Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API.
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
           <xs:attribute name="maxIdle" type="xs:long" default="-1">
            <xs:annotation>
              <xs:documentation>
                Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire. Note that this can be overridden on a per-entry basis by using the Cache API.
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
           <xs:attribute name="reaperEnabled" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                Determines whether the background reaper thread is enabled to test entries for expiration. Regardless of whether a reaper is used, entries are tested for expiration lazily when they are touched.
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="unsafe" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls certain tuning parameters that may break some of Infinispan's public API contracts in exchange for better performance in some cases. Use with care, only after thoroughly reading and understanding the documentation about a specific feature.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
           <xs:attribute name="unreliableReturnValues" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Specifies whether Infinispan is allowed to disregard the Map contract when providing return values for org.infinispan.Cache#put(Object, Object) and org.infinispan.Cache#remove(Object) methods.
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="versioning" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls whether entries are versioned.  Versioning is necessary, for example, when using optimistic transactions in a clustered environment, to be able to perform write-skew checks.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Determines whether versioning is enabled or disabled for this cache. Defaults to disabled
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
           <xs:attribute name="versioningScheme" type="tns:versioningScheme" default="NONE">
            <xs:annotation>
              <xs:documentation>
                The scheme to use when versioning entries. Can be either SIMPLE or NONE. Defaults to NONE
              </xs:documentation>
            </xs:annotation>
           </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="clustering" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Defines clustered characteristics of the cache.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:all>
            <xs:element name="sync" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  If configured all communications are synchronous, in that whenever a thread sends a message sent over the wire, it blocks until it receives an acknowledgment from the recipient. Sync configuration is mutually exclusive with async configuration. 
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="replTimeout" type="xs:long" default="15000">
                  <xs:annotation>
                    <xs:documentation>
                      This is the timeout used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown. Defaults to 15 seconds.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="stateTransfer" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Configures how state is transferred when a cache joins or leaves the cluster. Used in distributed and replication clustered modes.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="chunkSize" type="xs:int" default="10000">
                  <xs:annotation>
                    <xs:documentation>
                       If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries. If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 10000.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="fetchInMemoryState" type="xs:boolean">
                  <xs:annotation>
                    <xs:documentation>
                      If true, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time. Defaults to true if the cache is replicated/distributed, false otherwise.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="awaitInitialTransfer" type="xs:boolean">
                  <xs:annotation>
                    <xs:documentation>
                       If true, this will cause the first call to method CacheManager.getCache() on the joiner node to block and wait until the joining is complete and the cache has finished
                       receiving state from neighboring caches (if fetchInMemoryState is enabled). This option applies to distributed and replicated caches only and is enabled by default.
                       Please note that setting this to false will make the cache object available immediately but any access to keys that should be available locally but are not yet transferred
                       will actually cause a (transparent) remote access. While this will not have any impact on the logic of your application it might impact performance.
                       Defaults to true if the cache is replicated/distributed, false otherwise.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:long" default="240000">
                  <xs:annotation>
                    <xs:documentation>
                      This is the maximum amount of time - in milliseconds - to wait for state from neighboring caches, before throwing an exception and aborting startup. Defaults to 4 minutes.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="l1" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Configures the L1 cache behavior in 'distributed' caches instances. In any other cache modes, this element is ignored.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:attribute name="enabled" type="xs:boolean" default="false">
                  <xs:annotation>
                    <xs:documentation>
                      Enable the L1 cache. It is disabled by default.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="invalidationThreshold" type="xs:int" default="0">
                  <xs:annotation>
                    <xs:documentation>
                      Determines whether a multicast or a web of unicasts are used when performing L1 invalidations. By default multicast will be used. If the threshold is set to -1, then unicasts will always be used. If the threshold is set to  0 (default), then multicast will be always be used. 
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="lifespan" type="xs:long" default="60000">
                  <xs:annotation>
                    <xs:documentation>
                      Maximum lifespan of an entry placed in the L1 cache. Defaults to 10 minutes.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="cleanupTaskFrequency" type="xs:long" default="60000">
                   <xs:annotation>
                      <xs:documentation>
                         Controls how often a cleanup task to prune L1 tracking data is run. Defaults to 10 minutes.
                      </xs:documentation>
                   </xs:annotation>
                </xs:attribute>
                <xs:attribute name="onRehash" type="xs:boolean">
                  <xs:annotation>
                    <xs:documentation>
                       If enabled, entries removed due to a rehash will be moved to L1 rather than being removed altogether. Defaults to enabled when L1 is enabled.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="async" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  If configured all communications are asynchronous, in that whenever a thread sends a message sent over the wire, it does not wait for an acknowledgment before returning. Asynchronous configuration is mutually exclusive with synchronous configuration.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:annotation>
                  <xs:documentation>
                    If configured all communications are asynchronous, in that whenever a thread sends a message sent over the wire, it does not wait for an acknowledgment before returning. &lt;async&gt; is mutually exclusive with the &lt;sync&gt;.
                  </xs:documentation>
                </xs:annotation>
                <xs:attribute name="asyncMarshalling" type="xs:boolean" default="false">
                  <xs:annotation>
                    <xs:documentation>
                      If true, asynchronous marshalling is enabled which means that caller can return even quicker, but it can suffer from reordering of operations. You can find more information at https://docs.jboss.org/author/display/ISPN/Asynchronous+Options
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="replQueueClass" type="xs:string" default="org.infinispan.remoting.ReplicationQueueImpl">
                  <xs:annotation>
                    <xs:documentation>
                      The replication queue in use, by default ReplicationQueueImpl.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="replQueueInterval" type="xs:long" default="5000">
                  <xs:annotation>
                    <xs:documentation>
                      If useReplQueue is set to true, this attribute controls how often the asynchronous thread used to flush the replication queue runs. Defaults to 5 seconds.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="replQueueMaxElements" type="xs:int" default="1000">
                  <xs:annotation>
                    <xs:documentation>
                      If useReplQueue is set to true, this attribute can be used to trigger flushing of the queue when it reaches a specific threshold. Defaults to 1000 elements.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="useReplQueue" type="xs:boolean" default="false">
                  <xs:annotation>
                    <xs:documentation>
                      If true, forces all async communications to be queued up and sent out periodically as a batch.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
            <xs:element name="hash" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  Allows fine-tuning of rehashing characteristics. Must only used with 'distributed' cache mode.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:element name="groups" minOccurs="0">
                    <xs:complexType>
                      <xs:sequence>
                        <xs:element name="grouper" minOccurs="0" maxOccurs="unbounded">
                          <xs:complexType>
                            <xs:attribute name="class" type="xs:string">
                              <xs:annotation>
                                <xs:documentation>
                                   The class to use to group keys. Must implement org.infinispan.distribution.group.Grouper.
                                </xs:documentation>
                              </xs:annotation>
                            </xs:attribute>
                          </xs:complexType>
                        </xs:element>
                      </xs:sequence>
                      <xs:attribute name="enabled" type="xs:boolean">
                        <xs:annotation>
                          <xs:documentation>
                             Enables or disables grouping.
                          </xs:documentation>
                        </xs:annotation>
                      </xs:attribute>
                    </xs:complexType>
                  </xs:element>
                </xs:sequence>
                <xs:attribute name="factory" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>
                       The factory to use for generating the consistent hash. Must implement org.infinispan.distribution.ch.ConsistentHashFactory.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="hashFunctionClass" type="xs:string">
                  <xs:annotation>
                    <xs:documentation>
                      The hash function used as a bit spreader and a general hash code generator. Must implement org.infinispan.commons.hash.Hash.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numOwners" type="xs:int" default="2">
                  <xs:annotation>
                    <xs:documentation>
                      Number of cluster-wide replicas for each cache entry. Defaults to 2.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
                <xs:attribute name="numSegments" type="xs:int" default="60">
                  <xs:annotation>
                    <xs:documentation>
                      Controls the total number of hash space segments (per cluster). Recommended value is 10 * max_cluster_size. Defaults to 60.
                    </xs:documentation>
                  </xs:annotation>
                </xs:attribute>
              </xs:complexType>
            </xs:element>
          </xs:all>
          <xs:attribute name="mode" type="xs:string" default="local">
            <xs:annotation>
              <xs:documentation>
                Cache mode. For distribution, set mode to either 'dist'. For replication, use 'repl'. Finally, for invalidation 'inv'. If the cache mode is set to 'local', the cache in question will not support clustering even if its cache manager does.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="jmxStatistics" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Determines whether statistics are gathered and reported.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Enable or disable statistics gathering and reporting. Disabled by default.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="storeAsBinary" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Controls whether when stored in memory, keys and values are stored as references to their original objects, or in a serialized, binary format.  There are benefits to both approaches, but often if used in a clustered mode, storing objects as binary means that the cost of serialization happens early on, and can be amortized.  Further, deserialization costs are incurred lazily which improves throughput. It is possible to control this on a fine-grained basis: you can choose to just store keys or values as binary, or both.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Enables storing both keys and values as binary. Disabled by default.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storeKeysAsBinary" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                Specify whether keys are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="storeValuesAsBinary" type="xs:boolean" default="true">
            <xs:annotation>
              <xs:documentation>
                Specify whether values are stored as binary or not. Enabled by default if the "enabled" attribute is set to true.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
           <xs:attribute name="defensive" type="xs:boolean" default="false">
              <xs:annotation>
                 <xs:documentation>
                    Specify whether defensive copying of keys and values should be enabled. Defensive copying means that once an object is stored, the client can no longer use the reference to the object to make changes to the object stored in the cache, since they're different instances. By default this is disabled, which means that clients keep references to the same objects stored in the cache. Although this has some risks, it provides better overall performance.
                 </xs:documentation>
              </xs:annotation>
           </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="lazyDeserialization" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Deprecated configuration element. Use storeAsBinary instead.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean"/>
        </xs:complexType>
      </xs:element>
      <xs:element name="invocationBatching" minOccurs="0">
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
               <xs:documentation>
                  Specifies whether invocation batching will be enabled for the cache. Defaults to false.
               </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="deadlockDetection" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures deadlock detection.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Enable or disable deadlock detection. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="spinDuration" type="xs:long" default="100">
            <xs:annotation>
              <xs:documentation>
                Time period that determines how often is lock acquisition attempted within maximum time allowed to acquire a particular lock. Defaults to 100ms.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="indexing" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures indexing of entries in the cache for searching.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence>
            <xs:element name="properties" type="tns:properties" minOccurs="0">
              <xs:annotation>
                <xs:documentation>
                  The Query engine relies on properties for configuration. These properties are passed directly to the embedded Hibernate Search engine, so for the complete and up to date documentation about available properties refer to the Hibernate Search reference of the version you're using with Infinispan Query.
                </xs:documentation>
              </xs:annotation>
            </xs:element>
          </xs:sequence>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Enable or disable indexing. Disabled by default.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="indexLocalOnly" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                If true, only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates. Defaults to false.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
      <xs:element name="modules" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            This element contains configuration options for additional modules which affect cache configuration
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:any namespace="##other"/>
          </xs:sequence>
        </xs:complexType>
      </xs:element>
      <xs:element name="compatibility" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Configures compatibility mode to share cached data between embedded and remote endpoints.
          </xs:documentation>
        </xs:annotation>
        <xs:complexType>
          <xs:attribute name="enabled" type="xs:boolean" default="false">
            <xs:annotation>
              <xs:documentation>
                Enable or disable compatibility mode. Disabled by default.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="marshallerClass" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                Fully qualified name of the marshaller to use for compatibility mode. When running in compatibility mode, data is stored in deserialized form. This is achieved with the help of the marshaller. It must implement org.infinispan.marshall.Marshaller
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
       </xs:element>
    </xs:all>
    <xs:attribute name="name" type="xs:string"/>
  </xs:complexType>

  <xs:complexType name="executorFactory">
    <xs:sequence>
      <xs:element name="properties" type="tns:properties" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Add key/value property pair to this factory configuration. Example properties include "maxThreads" which sets the maximum number of threads for this executor and "threadNamePrefix" which sets the thread name prefix for threads created by this executor ( default values can be found at https://docs.jboss.org/author/display/ISPN/Default+Values+For+Property+Based+Attributes ).
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
    <xs:attribute name="factory" type="xs:string">
      <xs:annotation>
        <xs:documentation>
          Fully qualified class name of the ExecutorFactory to use.  Must implement org.infinispan.executors.ExecutorFactory
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="properties">
    <xs:sequence>
      <xs:element name="property" minOccurs="0" maxOccurs="unbounded">
        <xs:complexType>
          <xs:attribute name="name" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The property name or key
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="value" type="xs:string">
            <xs:annotation>
              <xs:documentation>
                The property value
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
        </xs:complexType>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="scheduledExecutorFactory">
    <xs:sequence>
       <xs:element name="properties" type="tns:properties" minOccurs="0">
         <xs:annotation>
            <xs:documentation>
               Add key/value property pair to this factory configuration. Example properties include "maxThreads" which sets the maximum number of threads for this executor and "threadNamePrefix" which sets the thread name prefix for threads created by this executor ( default values can be found at https://docs.jboss.org/author/display/ISPN/Default+Values+For+Property+Based+Attributes ).
            </xs:documentation>
         </xs:annotation>
       </xs:element>
     </xs:sequence>
     <xs:attribute name="factory" type="xs:string">
      <xs:annotation>
         <xs:documentation>
            Fully qualified class name of the ScheduledExecutorFactory to use.  Must implement org.infinispan.executors.ScheduledExecutorFactory
         </xs:documentation>
      </xs:annotation>
     </xs:attribute>
  </xs:complexType>

  <xs:complexType name="backup">
      <xs:sequence minOccurs="0" maxOccurs="1">
          <xs:element name="takeOffline" minOccurs="0">
              <xs:annotation>
                  <xs:documentation>
                      Determines whether this backup is taken offline (ignored) after a certain
                      number of tries.
                  </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                  <xs:attribute name="afterFailures" type="xs:int" default="0">
                      <xs:annotation>
                          <xs:documentation>
                              The number of failed request operations after which this site
                              should be taken offline. Defaults to 0 (never).
                              A negative value would mean that the site will be taken offline
                              after 'minTimeToWait'.
                          </xs:documentation>
                      </xs:annotation>
                  </xs:attribute>
                  <xs:attribute name="minTimeToWait" type="xs:long" default="0">
                      <xs:annotation>
                          <xs:documentation>
                              The minimal number of millis to wait before taking this site
                              offline, even in the case 'afterFailures' is reached.
                              If smaller or equal to 0, then only 'afterFailures' is considered.
                          </xs:documentation>
                      </xs:annotation>
                  </xs:attribute>
              </xs:complexType>
          </xs:element>
      </xs:sequence>
      <xs:attribute name="site" type="xs:string" use="required">
          <xs:annotation>
              <xs:documentation>
                  Name of the remote site where this cache backups data.
              </xs:documentation>
          </xs:annotation>
      </xs:attribute>
      <xs:attribute name="strategy" use="optional" default="ASYNC">
          <xs:annotation>
              <xs:documentation>
                  The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"
              </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
              <xs:restriction base="xs:string">
                  <xs:enumeration value="SYNC"/>
                  <xs:enumeration value="ASYNC"/>
              </xs:restriction>
          </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="backupFailurePolicy" use="optional" default="FAIL">
          <xs:annotation>
              <xs:documentation>
                  Decides what the system would do in case of failure during backup. Defaults to
                  "FAIL"
              </xs:documentation>
          </xs:annotation>
          <xs:simpleType>
              <xs:restriction base="xs:string">
                  <xs:enumeration value="IGNORE"/>
                  <xs:enumeration value="WARN"/>
                  <xs:enumeration value="FAIL"/>
                  <xs:enumeration value="CUSTOM"/>
              </xs:restriction>
          </xs:simpleType>
      </xs:attribute>
      <xs:attribute name="timeout" use="optional" type="xs:long" default="10000">
          <xs:annotation>
              <xs:documentation>
                  The timeout(millis) to be used when backing up data remotely. Defaults to 10
                  secs.
              </xs:documentation>
          </xs:annotation>
      </xs:attribute>
      <xs:attribute name="useTwoPhaseCommit" use="optional" type="xs:boolean" default="false">
          <xs:annotation>
              <xs:documentation>
                  Whether a backup will use a 2PC cycle for SYNC backups.  Defaults to "false".
                  NOTE: Not used for ASYNC backup strategies.
              </xs:documentation>
          </xs:annotation>
      </xs:attribute>      
      <xs:attribute name="failurePolicyClass" use="optional" type="xs:string">
          <xs:annotation>
              <xs:documentation>
                  If the 'backupFailurePolicy' is set to 'CUSTOM' then this attribute is
                  required and should
                  contain the fully qualified name of a class implementing
                  org.infinispan.xsite.CustomFailurePolicy.
              </xs:documentation>
          </xs:annotation>
      </xs:attribute>
      <xs:attribute name="enabled" type="xs:boolean" default="true">
          <xs:annotation>
              <xs:documentation>
                  If 'false' then no data is backed up to this site. Defaults to 'true'.
              </xs:documentation>
          </xs:annotation>
      </xs:attribute>
  </xs:complexType>

  <xs:complexType name="site">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
    </xs:sequence>
    <xs:attribute name="local" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
          The name of the local site. Must be one of the site names defined in child "site" elements.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:simpleType name="shutdownHookBehavior">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
         <xs:annotation>
            <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REGISTER">
         <xs:annotation>
            <xs:documentation>Register a shutdown hook</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DONT_REGISTER">
         <xs:annotation>
            <xs:documentation>Don't register a shutdown hook</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="isolationLevel">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE">
         <xs:annotation>
            <xs:documentation>Use the default shutdown hook behaviour (REGISTER)</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="SERIALIZABLE">
         <xs:annotation>
            <xs:documentation>SERIALIZABLE isolation level</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="REPEATABLE_READ">
         <xs:annotation>
            <xs:documentation>REPEATABLE_READ isolation level</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_COMMITTED">
         <xs:annotation>
            <xs:documentation>READ_COMMITTED isolation level</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="READ_UNCOMMITTED">
         <xs:annotation>
            <xs:documentation>READ_UNCOMMITTED isolation level</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="evictionStrategy">
    <xs:restriction base="xs:string">
      <xs:enumeration value="NONE">
         <xs:annotation>
            <xs:documentation>Do not enable eviction</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="UNORDERED">
         <xs:annotation>
            <xs:documentation>Alias for LRU</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="FIFO">
         <xs:annotation>
            <xs:documentation>Alias for LRU</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LRU">
         <xs:annotation>
            <xs:documentation>Least-recently used eviction strategy</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="LIRS">
         <xs:annotation>
            <xs:documentation>Low inter-reference recency set eviction strategy</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

  <xs:simpleType name="evictionThreadPolicy">
    <xs:restriction base="xs:string">
      <xs:enumeration value="PIGGYBACK">
         <xs:annotation>
            <xs:documentation>Fires the eviction events from the same thread which is performing the eviction </xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="DEFAULT">
         <xs:annotation>
            <xs:documentation>Use the default eviction listener thread policy (PIGGYBACK)</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:simpleType name="lockingMode">
    <xs:annotation>
      <xs:documentation>
        Defines the locking modes that are available for transactional caches: optimistic or pessimistic - see http://community.jboss.org/wiki/OptimisticLockingInInfinispan for more.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="OPTIMISTIC">
         <xs:annotation>
            <xs:documentation>Use optimistic locking</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PESSIMISTIC">
         <xs:annotation>
            <xs:documentation>Use pessimistic locking</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
  
  <xs:simpleType name="transactionMode">
    <xs:annotation>
      <xs:documentation>
        Enumeration containing the available transaction modes for a cache.
      </xs:documentation>
    </xs:annotation>
    <xs:restriction base="xs:string">
      <xs:enumeration value="NON_TRANSACTIONAL">
         <xs:annotation>
            <xs:documentation>Define the cache to be non-transactional</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="TRANSACTIONAL">
         <xs:annotation>
            <xs:documentation>Define the cache to be transactional</xs:documentation>
         </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>

    <xs:simpleType name="transactionProtocol">
        <xs:annotation>
            <xs:documentation>
                Enumeration containing the available commit protocols
            </xs:documentation>
        </xs:annotation>
        <xs:restriction base="xs:string">
            <xs:enumeration value="DEFAULT" />
            <xs:enumeration value="TOTAL_ORDER" />
        </xs:restriction>
    </xs:simpleType>

  <xs:complexType name="loader" abstract="true">
    <xs:sequence>
      <xs:element name="properties" type="tns:properties" minOccurs="0">
        <xs:annotation>
          <xs:documentation>
            Properties passed to the cache store or loader
          </xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:sequence>
  </xs:complexType>

  <xs:complexType name="customLoader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="class" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The cache loader to configure and use
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="async">
    <xs:attribute name="enabled" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          If true, all modifications to this cache store happen asynchronously, on a separate thread.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="flushLockTimeout" type="xs:long" default="1">
      <xs:annotation>
        <xs:documentation>
          Timeout to acquire the lock which guards the state to be flushed to the cache store periodically. Defaults to 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="modificationQueueSize" type="xs:int" default="1024">
      <xs:annotation>
        <xs:documentation>
          Sets the size of the modification queue for the async store. If updates are made at a rate that is faster than the underlying cache store can process this queue, then the async
          store behaves like a synchronous store for that period, blocking until the queue can accept more elements. Defaults to 1024 elements.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="shutdownTimeout" type="xs:long" default="25000">
      <xs:annotation>
        <xs:documentation>
          Timeout to stop the cache store. When the store is stopped it's possible that some modifications still need to be applied; you likely want to set a very large timeout to make sure to
          not loose data. Defaults to 25 seconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="threadPoolSize" type="xs:int" default="1">
      <xs:annotation>
        <xs:documentation>
          Size of the thread pool whose threads are responsible for applying the modifications. Defaults to 1.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="singletonStore">
    <xs:attribute name="pushStateTimeout" type="xs:long" default="10000">
      <xs:annotation>
        <xs:documentation>
          If pushStateWhenCoordinator is true, this property sets the maximum number of milliseconds that the process of pushing the in-memory state to the underlying cache loader should
          take. Defaults to 10 seconds.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pushStateWhenCoordinator" type="xs:boolean" default="true">
      <xs:annotation>
        <xs:documentation>
          If true, when a node becomes the coordinator, it will transfer in-memory state to the underlying cache store. This can be very useful in situations where the coordinator crashes
          and there's a gap in time until the new coordinator is elected. Defaults to true.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="enabled" type="xs:boolean" default="false">
      <xs:annotation>
        <xs:documentation>
          If true, the singleton store cache store is enabled. Defaults to false.
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>

  <xs:complexType name="store" abstract="true">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:sequence>
          <xs:element name="async" type="tns:async" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                Configuration for the async cache loader. If enabled, this provides you with asynchronous writes to the cache store, giving you 'write-behind' caching.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
          <xs:element name="singletonStore" type="tns:singletonStore" minOccurs="0" maxOccurs="1">
            <xs:annotation>
              <xs:documentation>
                SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. The coordinator of the cluster will be responsible for the underlying CacheStore. SingletonStore is a simply facade to a real CacheStore implementation. It always delegates reads to the real CacheStore.
              </xs:documentation>
            </xs:annotation>
          </xs:element>
        </xs:sequence>
        <xs:attribute name="fetchPersistentState" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation>
              If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled. Persistent state transfer with a shared cache store does not make sense, as the same
              persistent store that provides the data will just end up receiving it. Therefore, if a shared cache store is used, the cache will not allow a persistent state transfer even if a cache store has this
              property set to true. Finally, setting it to true only makes sense if in a clustered environment, and only 'replication' and 'invalidation' cluster modes are supported. Defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreModifications" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation>
              If true, any operation that modifies the cache (put, remove, clear, store...etc) won't be applied to the cache store. This means that the cache store could become out of sync with the cache.
              Defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="purgeOnStartup" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation>
              If true, purges this cache store when it starts up. Defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="purgeSynchronously" type="xs:boolean" default="false">
          <xs:annotation>
            <xs:documentation>
              If true, CacheStore#purgeExpired() call will be done synchronously. Defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="purgerThreads" type="xs:int" default="1">
          <xs:annotation>
            <xs:documentation>
              The number of threads to use when purging asynchronously. Defaults to 1 thread.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="lockSupportStore">
    <xs:complexContent>
      <xs:extension base="tns:store">
        <xs:attribute name="lockAcquisitionTimeout" type="xs:long" default="60000">
            <xs:annotation>
              <xs:documentation>
                Maximum time to attempt a particular lock acquisition
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
          <xs:attribute name="concurrencyLevel" type="xs:int" default="2048">
            <xs:annotation>
              <xs:documentation>
                Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan. Similar to the concurrencyLevel tuning parameter seen in the JDK's ConcurrentHashMap.
              </xs:documentation>
            </xs:annotation>
          </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="customStore">
    <xs:complexContent>
      <xs:extension base="tns:lockSupportStore">
        <xs:attribute name="class" type="xs:string">
          <xs:annotation>
            <xs:documentation>
              The cache store to configure and use
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="clusterLoader">
    <xs:complexContent>
      <xs:extension base="tns:loader">
        <xs:attribute name="remoteCallTimeout" type="xs:long" default="0">
          <xs:annotation>
            <xs:documentation>
              How long to wait for results from other members in the cluster before returning a null. Defaults to 0 (no timeout).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  
  <xs:complexType name="fileStore">
    <xs:complexContent>
      <xs:extension base="tns:lockSupportStore">
        <xs:attribute name="location" type="xs:string" default="Infinispan-FileCacheStore">
          <xs:annotation>
            <xs:documentation>
              A location on disk where the store can write internal files.  This defaults to Infinispan-FileCacheStore in the current working directory.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="streamBufferSize" type="xs:int" default="8192">
          <xs:annotation>
            <xs:documentation>
              When writing state to disk, a buffered stream is used.  This parameter allows you to tune the buffer size.  Larger buffers are usually faster but take up more (temporary) memory, resulting in more gc. By default, this is set to 8192
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fsyncMode" type="tns:fsyncMode" default="DEFAULT">
          <xs:annotation>
            <xs:documentation>
              Configures how the file changes will be synchronized with the underlying file system. This property has three possible values (The default mode configured is DEFAULT)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fsyncInterval" type="xs:long" default="1000">
          <xs:annotation>
            <xs:documentation>
              Specifies the time after which the file changes in the cache need to be flushed. This option has only effect when periodic fsync mode is in use. The default fsync interval is 1 second.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>

  <xs:complexType name="singleFileStore">
      <xs:complexContent>
         <xs:extension base="tns:loader">
            <xs:attribute name="location" type="xs:string" default="Infinispan-SingleFileCacheStore">
               <xs:annotation>
                  <xs:documentation>
                     A location on disk where the store can write.  This defaults to Infinispan-SingleFileCacheStore in the current working directory.
                  </xs:documentation>
               </xs:annotation>
            </xs:attribute>
            <xs:attribute name="maxKeysInMemory" type="xs:int" default="-1">
               <xs:annotation>
                  <xs:documentation>
                     To speed up data lookup, the single file store keeps an index of keys and their positions in the file. By default, this index is unbounded, but it's size can be limited setting this attribute to a positive number. To avoid data becoming unreachable, a positive value cannot be used if the cache is configured with eviction or passivation.
                  </xs:documentation>
               </xs:annotation>
            </xs:attribute>
         </xs:extension>
      </xs:complexContent>
  </xs:complexType>
  
  <xs:simpleType name="fsyncMode">
    <xs:restriction base="xs:string">
      <xs:enumeration value="DEFAULT">
        <xs:annotation>
          <xs:documentation>
            Means that the file system will be synchronized when the OS buffer is full or when the bucket is read.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PER_WRITE">
        <xs:annotation>
          <xs:documentation>
            Configures the file cache store to sync up changes after each write request
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="PERIODIC">
        <xs:annotation>
          <xs:documentation>
            Enables sync operations to happen as per a defined interval, or when the bucket is about to be read.
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>


  
  <xs:simpleType name="versioningScheme">
    <xs:restriction base="xs:string">
      <xs:enumeration value="SIMPLE">
        <xs:annotation>
          <xs:documentation>
           A simple versioning scheme that is cluster-aware
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
      <xs:enumeration value="NONE">
        <xs:annotation>
          <xs:documentation>
            Don't version entries
          </xs:documentation>
        </xs:annotation>
      </xs:enumeration>
    </xs:restriction>
  </xs:simpleType>
</xs:schema>

