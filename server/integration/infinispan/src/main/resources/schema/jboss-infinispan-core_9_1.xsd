<?xml version="1.0" encoding="UTF-8"?>

<!--
  ~ JBoss, Home of Professional Open Source.
  ~ Copyright 2016, Red Hat, Inc., and individual contributors
  ~ as indicated by the @author tags. See the copyright.txt file in the
  ~ distribution for a full listing of individual contributors.
  ~
  ~ This is free software; you can redistribute it and/or modify it
  ~ under the terms of the GNU Lesser General Public License as
  ~ published by the Free Software Foundation; either version 2.1 of
  ~ the License, or (at your option) any later version.
  ~
  ~ This software is distributed in the hope that it will be useful,
  ~ but WITHOUT ANY WARRANTY; without even the implied warranty of
  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
  ~ Lesser General Public License for more details.
  ~
  ~ You should have received a copy of the GNU Lesser General Public
  ~ License along with this software; if not, write to the Free
  ~ Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
  ~ 02110-1301 USA, or see the FSF site: http://www.fsf.org.
  -->
<xs:schema targetNamespace="urn:infinispan:server:core:9.1"
            xmlns:xs="http://www.w3.org/2001/XMLSchema"
            xmlns:tns="urn:infinispan:server:core:9.1"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified"
            version="9.1">

    <xs:element name="subsystem" type="tns:subsystem">
        <xs:annotation>
            <xs:documentation>Enumerates the cache containers available to the registry.</xs:documentation>
        </xs:annotation>
    </xs:element>

    <xs:complexType name="subsystem">
        <xs:choice maxOccurs="unbounded">
            <xs:element name="cache-container" type="tns:cache-container">
                <xs:annotation>
                    <xs:documentation>Defines an embedded cache container.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:choice>
    </xs:complexType>

    <xs:complexType name="cache-container">
        <xs:sequence>
            <xs:element name="transport" type="tns:transport" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Overrides the transport characteristics for this cache container.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="security" type="tns:global-security" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Configures security for this cache container.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="global-state" type="tns:global-state" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Defines the global state configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="async-operations-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for asynchronous operations.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="expiration-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for expiration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="listener-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for asynchronous cache listener notifications.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="persistence-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for interacting with the persistent store.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="remote-command-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for executing remote commands.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="state-transfer-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for state transfer.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="transport-thread-pool" type="tns:thread-pool" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Defines a thread pool used for asynchronous transport communication.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:choice maxOccurs="unbounded">
                <xs:element name="local-cache-configuration" type="tns:local-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a LOCAL mode cache configuration.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="local-cache" type="tns:local-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a LOCAL mode cache.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="replicated-cache-configuration" type="tns:replicated-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a REPL_* mode cache configuration.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="replicated-cache" type="tns:replicated-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a REPL_* mode cache.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="invalidation-cache-configuration" type="tns:invalidation-cache">
                    <xs:annotation>
                        <xs:documentation>Defines an INVALIDATION_* mode cache configuration.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="invalidation-cache" type="tns:invalidation-cache">
                    <xs:annotation>
                        <xs:documentation>Defines an INVALIDATION_* mode cache.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="distributed-cache-configuration" type="tns:distributed-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a DIST_* mode cache configuration.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="distributed-cache" type="tns:distributed-cache">
                    <xs:annotation>
                        <xs:documentation>Defines a DIST_* mode cache.</xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Uniquely identifies this cache container.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="aliases" type="tns:aliases">
            <xs:annotation>
                <xs:documentation>A set of aliases by which this cache container may also be referenced.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="jndi-name" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    The jndi name to which to bind this cache container.
                    If undefined, the cache will be bound to: java:jboss/infinispan/container/container-name
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="default-cache" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Indicates the default cache for this cache container.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="start" type="tns:controller-mode" default="${Server.CacheContainer.start}">
            <xs:annotation>
                <xs:documentation>Should this cache container be started on server startup, or lazily when requested by a service or deployment.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="listener-executor" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the executor used for asynchronous cache listener notifications. Deprecated: please use the listener-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="async-executor" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the executor used for asynchronous cache operations. Deprecated: please use the async-operations-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="eviction-executor" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the scheduled executor used for evictions. Deprecated: please use the expiration-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="state-transfer-executor" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the executor used by the state transfer. Deprecated: please use the state-transfer-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="module" type="xs:string" default="${Server.CacheContainer.module}">
            <xs:annotation>
                <xs:documentation>Defines the module whose class loader should be used when building this cache container.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statistics" type="xs:boolean" default="${Server.CacheContainer.statistics}">
            <xs:annotation>
                <xs:documentation>Determines whether or not the cache container should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="transport">
        <xs:attribute name="channel" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the channel used for this transport.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="stack" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the jgroups stack used by the transport. Deprecated: please use the channel attribute instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="cluster" type="xs:string" >
            <xs:annotation>
                <xs:documentation>Defines the name for the underlying group communication cluster. Deprecated: please use the channel attribute instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="executor" type="xs:string" >
            <xs:annotation>
                <xs:documentation>Defines the executor used for asynchronous transport communication.  Deprecated: please use the transport-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lock-timeout" type="xs:long" default="${Server.Transport.lock-timeout}">
            <xs:annotation>
                <xs:documentation>
                    Infinispan uses a distributed lock to maintain a coherent transaction log during state transfer or rehashing, which means that only one cache can be doing state transfer or rehashing at the same time.
                    This constraint is in place because more than one cache could be involved in a transaction.
                    This timeout controls the time to wait to acquire a distributed lock.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="remote-command-executor" type="xs:string">
            <xs:annotation>
                <xs:documentation>Defines the executor used for processing remote (non-total order) commands. Deprecated: please use the remote-command-thread-pool element instead.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strict-peer-to-peer" type="xs:boolean" default="${Server.Transport.strict-peer-to-peer}">
            <xs:annotation>
                <xs:documentation>
                    Makes clustered operations fail with NamedCacheNotFoundException if the named cache does not exist on remote nodes.
                    If set to false, operations will succeed but it will be logged on the caller that the operation did not succeed on
                    certain nodes due to the named cache not being available. This behaviour is applicable only to replicated caches.
                    Defaults to false.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="total-order-executor" type="xs:string" >
            <xs:annotation>
                <xs:documentation>Defines the executor used for processing remote total order commands. Deprecated.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="initial-cluster-size" type="xs:int">
            <xs:annotation>
                <xs:documentation>
                    The minimum number of nodes that must join the cluster for the cache manager to start
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="initial-cluster-timeout" type="xs:long">
            <xs:annotation>
                <xs:documentation>
                    The amount of time in milliseconds to wait for a cluster with sufficient nodes to form. Defaults to 60000
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="global-security">
        <xs:sequence>
            <xs:element name="authorization" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>
                        Configures the global authorization role to permission mapping. The presence of this element in the configuration implicitly enables authorization.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:choice minOccurs="0" maxOccurs="1">
                            <xs:element name="identity-role-mapper">
                                <xs:annotation>
                                    <xs:documentation>
                                        Uses the identity role mapper where principal names are converted as-is into role names.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="common-name-role-mapper">
                                <xs:annotation>
                                    <xs:documentation>
                                        Uses the common name role mapper which assumes principal names are in Distinguished Name format and extracts the Common Name to use as a role
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="cluster-role-mapper">
                                <xs:annotation>
                                    <xs:documentation>
                                        Uses the cluster role mapper which stores the principal to role mappings within the cluster registry.
                                    </xs:documentation>
                                </xs:annotation>
                            </xs:element>
                            <xs:element name="custom-role-mapper">
                                <xs:annotation>
                                    <xs:documentation>
                                        Uses a custom role mapper.
                                    </xs:documentation>
                                </xs:annotation>
                                <xs:complexType>
                                    <xs:attribute name="class" type="xs:string">
                                        <xs:annotation>
                                            <xs:documentation>
                                                Class of the custom principal to role mapper
                                            </xs:documentation>
                                        </xs:annotation>
                                    </xs:attribute>
                                </xs:complexType>
                            </xs:element>
                        </xs:choice>
                        <xs:element name="role" minOccurs="0"
                            maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>
                                    Defines a new role name and assigns permissions to it.
                                </xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:attribute name="name"
                                    use="required" type="xs:string">
                                    <xs:annotation>
                                        <xs:documentation>
                                            Defines the name of the role.
                                        </xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                                <xs:attribute name="permissions"
                                    use="required" type="tns:permission-list">
                                    <xs:annotation>
                                        <xs:documentation>
                                            Defines the list of permissions for the role.
                                        </xs:documentation>
                                    </xs:annotation>
                                </xs:attribute>
                            </xs:complexType>
                        </xs:element>
                    </xs:sequence>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="global-state">
        <xs:sequence>
            <xs:element name="persistent-location" type="tns:global-state-path" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Defines the path where global state for this cache-container will be stored. The data stored at this location is required for graceful
                        shutdown and restore.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="temporary-location" type="tns:global-state-path" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Defines the path which will be used to store temporary data.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="global-state-path">
        <xs:attribute name="relative-to" type="xs:string" default="${Server.GlobalState.relative-to}">
            <xs:annotation>
                <xs:documentation>The base directory in which to store the state</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="path" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Defines the path where state for this cache-container will be stored.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="cache" abstract="true">
        <xs:sequence>
            <xs:element name="backups" type="tns:backups" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The cross-site backup configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="backup-for" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>
                        Configures this cache as a backup for a remote cache.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="remote-cache" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:documentation>
                                The name of the remote cache that backups data here.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remote-site" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:documentation>
                                The name of the remote site containing the cache that backups data here.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="locking" type="tns:locking" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The locking configuration of the cache.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="transaction" type="tns:transaction" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The cache transaction configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="memory" type="tns:memory" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The cache memory configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="expiration" type="tns:expiration" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The cache expiration configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="compatibility" type="tns:compatibility" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>The cache compatibility mode configuration.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:choice minOccurs="0" maxOccurs="unbounded">
                <xs:element name="cluster-loader" type="tns:cluster-loader">
                    <xs:annotation>
                        <xs:documentation>Defines a cluster cache loader.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="store" type="tns:custom-store">
                    <xs:annotation>
                        <xs:documentation>Defines a custom cache store.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="loader" type="tns:custom-loader">
                    <xs:annotation>
                        <xs:documentation>Defines a custom cache loader.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="file-store" type="tns:file-store">
                    <xs:annotation>
                        <xs:documentation>Defines a file-based cache store.</xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:choice minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="string-keyed-jdbc-store" type="tns:string-keyed-jdbc-store">
                        <xs:annotation>
                            <xs:documentation>Defines a database cache store accessed via JDBC using string-based keys.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:choice>
                <xs:element name="rocksdb-store" type="tns:rocksdb-store">
                    <xs:annotation>
                        <xs:documentation>
                            Defines a RocksDB cache store.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="remote-store" type="tns:remote-store">
                    <xs:annotation>
                        <xs:documentation>
                            Defines a remote cache store accessed via HotRod.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="rest-store" type="tns:rest-store">
                    <xs:annotation>
                        <xs:documentation>
                            Defines a remote cache store accessed via REST.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
            <xs:element name="indexing" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>
                        Defines indexing options for cache
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:sequence>
                        <xs:element name="indexed-entities" minOccurs="0" maxOccurs="1">
                            <xs:annotation>
                                <xs:documentation>Defines the indexed entity classes</xs:documentation>
                            </xs:annotation>
                            <xs:complexType>
                                <xs:sequence>
                                    <xs:element name="indexed-entity" type="xs:string" minOccurs="0" maxOccurs="unbounded">
                                        <xs:annotation>
                                            <xs:documentation>Indexed entity class name</xs:documentation>
                                        </xs:annotation>
                                    </xs:element>
                                </xs:sequence>
                            </xs:complexType>
                        </xs:element>
                        <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
                            <xs:annotation>
                                <xs:documentation>Property to pass on to the indexing system</xs:documentation>
                            </xs:annotation>
                        </xs:element>
                    </xs:sequence>
                    <xs:attribute name="index" type="tns:indexing" default="${Server.Indexing.indexing}">
                        <xs:annotation>
                            <xs:documentation>The indexing mode of the cache. Defaults to NONE.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="auto-config" type="xs:boolean" default="${Server.Indexing.auto-config}">
                        <xs:annotation>
                            <xs:documentation>Whether or not to apply automatic index configuration based on cache type</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
            <xs:element name="security" type="tns:cache-security" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>
                        Configures cache-level security.
                    </xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Uniquely identifies this cache within its cache container.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="configuration" type="xs:string">
            <xs:annotation>
                <xs:documentation>The name of the cache configuration which this configuration inherits from.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="start" type="tns:controller-mode" default="${Server.CacheContainer.start}">
            <xs:annotation>
                <xs:documentation>Should this cache be started on server startup, or lazily when requested by a service or deployment.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="batching" type="xs:boolean" default="${Server.Cache.batching}">
            <xs:annotation>
                <xs:documentation>Enables invocation batching for this cache. Defaults to false.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="jndi-name" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    The jndi name to which to bind this cache.
                    If undefined, the cache will be bound to: java:jboss/infinispan/cache/container-name/cache-name
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="module" type="xs:string">
            <xs:annotation>
                <xs:documentation>
                    Defines the module whose class loader should be used when building this cache, if different from the enclosing cache container.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statistics" type="xs:boolean" default="${Server.Cache.statistics}">
            <xs:annotation>
                <xs:documentation>Determines whether or not the cache should collect statistics.  Keep disabled for optimal performance.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="statistics-available" type="xs:boolean" default="${Server.Cache.statistics-available}">
            <xs:annotation>
                <xs:documentation>If set to false, statistics gathering cannot be enabled during runtime. Keep disabled for optimal performance.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="local-cache">
        <xs:complexContent>
            <xs:extension base="tns:cache">
                <xs:attribute name="simple-cache" type="xs:boolean" default="${Server.Cache.simple-cache}">
                    <xs:annotation>
                        <xs:documentation>This cache will be using optimized (faster) implementation that does not support transactions/invocation batching, persistence, custom interceptors, indexing, store-as-binary or compatibility. Also, this type of cache does not support Map-Reduce jobs or Distributed Executor framework.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="locking">
        <xs:attribute name="isolation" type="tns:isolation" default="${Server.Locking.isolation}">
            <xs:annotation>
                <xs:documentation>Sets the cache locking isolation level. Defaults to READ_COMMITTED. When using REPEATABLE_READ with optimistic locking, write skew checking will be enabled.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="striping" type="xs:boolean" default="${Server.Locking.striping}">
            <xs:annotation>
                <xs:documentation>If true, a pool of shared locks is maintained for all entries that need to be locked. Otherwise, a lock is created per entry in the cache. Lock striping helps control memory footprint but may reduce concurrency in the system.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="acquire-timeout" type="xs:long" default="${Server.Locking.acquire-timeout}">
            <xs:annotation>
                <xs:documentation>Maximum time to attempt a particular lock acquisition.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="concurrency-level" type="xs:int" default="${Server.Locking.concurrency-level}">
            <xs:annotation>
                <xs:documentation>Concurrency level for lock containers. Adjust this value according to the number of concurrent threads interacting with Infinispan.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="transaction">
        <xs:attribute name="mode" type="tns:transaction-mode" default="${Server.Transaction.mode}">
            <xs:annotation>
                <xs:documentation>Sets the cache transaction mode to one of NONE, NON_XA, NON_DURABLE_XA, FULL_XA.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="stop-timeout" type="xs:long" default="${Server.Transaction.stop-timeout}">
            <xs:annotation>
                <xs:documentation>If there are any ongoing transactions when a cache is stopped, Infinispan waits for ongoing remote and local transactions to finish. The amount of time to wait for is defined by the cache stop timeout.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="locking" type="tns:locking-mode" default="${Server.Transaction.locking}">
            <xs:annotation>
                <xs:documentation>The locking mode for this cache, one of OPTIMISTIC or PESSIMISTIC.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="notifications" type="xs:boolean" default="${Server.Transaction.notifications}">
            <xs:annotation>
                <xs:documentation>
                    Enables or disables triggering transactional notifications on cache listeners. By default is enabled.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="memory">
        <xs:sequence>
            <xs:choice minOccurs="0" maxOccurs="1">
                <xs:element name="object" type="tns:memory-object">
                    <xs:annotation>
                        <xs:documentation>
                            Store keys and values as instance variables.  Instances of byte[] will be wrapped to ensure equality.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="binary" type="tns:memory-binary">
                    <xs:annotation>
                        <xs:documentation>
                            Store keys and values as byte[] instances.  Key and value will be serialized to binary representations.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
                <xs:element name="off-heap" type="tns:memory-off-heap">
                    <xs:annotation>
                        <xs:documentation>
                            Store keys and values as byte[] off of the Java heap.  Key and value will be serialized to binary
                            representations and stored in native memory as to not take up Java heap.  Temporary objects will be
                            put onto Java heap temporarily until processing is completed.
                        </xs:documentation>
                    </xs:annotation>
                </xs:element>
            </xs:choice>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="memory-object">
        <xs:attribute name="size" type="xs:long" default="-1">
            <xs:annotation>
                <xs:documentation>The size of the eviction cache as a long.  Limits the cache to this normal by the amount of
                    entries in the cache.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="memory-binary">
        <xs:attribute name="size" type="xs:long" default="-1">
            <xs:annotation>
                <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be
                    how many entries can be stored.  If the configured type is MEMORY, this will be how much memory
                    in bytes can be stored.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="eviction">
            <xs:annotation>
                <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on
                    the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="memory-off-heap">
        <xs:attribute name="size" type="xs:long" default="-1">
            <xs:annotation>
                <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be
                    how many entries can be stored.  If the configured type is MEMORY, this will be how much memory
                    in bytes can be stored.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="eviction">
            <xs:annotation>
                <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on
                    the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="address-count" type="xs:int" default="1048576">
            <xs:annotation>
                <xs:documentation>How many address pointers to use.  For optimal performance you will want more
                    address pointers than you expect to have entries.  This is similar to the size of an array backing
                    a hash map.  Without collisions lookups and writes will be constant time.  Each pointer will take
                    up 8 bytes of memory thus the default will use 8 MB of off heap memory.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="expiration">
        <xs:attribute name="max-idle" type="xs:long" default="${Server.Expiration.max-idle}">
            <xs:annotation>
                <xs:documentation>Maximum idle time a cache entry will be maintained in the cache, in milliseconds. If the idle time is exceeded, the entry will be expired cluster-wide. -1 means the entries never expire.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="lifespan" type="xs:long" default="${Server.Expiration.lifespan}">
            <xs:annotation>
                <xs:documentation>Maximum lifespan of a cache entry, after which the entry is expired cluster-wide, in milliseconds. -1 means the entries never expire.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="interval" type="xs:long" default="${Server.Expiration.interval}">
            <xs:annotation>
                <xs:documentation>Interval (in milliseconds) between subsequent runs to purge expired entries from memory and any cache stores. If you wish to disable the periodic eviction process altogether, set interval to -1.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="compatibility">
        <xs:attribute name="enabled" type="xs:boolean" default="${Server.Compatibility.enabled}">
            <xs:annotation>
                <xs:documentation>Enables compatibility mode for this cache. Disabled by default.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="marshaller" type="xs:string">
            <xs:annotation>
                <xs:documentation>A marshaller to use for compatibility conversions.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="clustered-cache" abstract="true">
        <xs:complexContent>
            <xs:extension base="tns:cache">
                <xs:attribute name="mode" type="tns:mode" default="SYNC">
                    <xs:annotation>
                        <xs:documentation>Sets the clustered cache mode, ASYNC for asynchronous operation, or SYNC for synchronous operation.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remote-timeout" type="xs:long" default="${Server.ClusteredCache.remote-timeout}">
                    <xs:annotation>
                        <xs:documentation>In SYNC mode, the timeout (in ms) used to wait for an acknowledgment when making a remote call, after which the call is aborted and an exception is thrown.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="invalidation-cache">
        <xs:complexContent>
            <xs:extension base="tns:clustered-cache">
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="replicated-cache">
        <xs:complexContent>
            <xs:extension base="tns:clustered-cache">
                <xs:sequence>
                    <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="partition-handling" type="tns:partition-handling" minOccurs="0">
                      <xs:annotation>
                          <xs:documentation>The partition handling configuration for distribution and replicated caches.</xs:documentation>
                      </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="distributed-cache">
        <xs:complexContent>
            <xs:extension base="tns:clustered-cache">
                <xs:sequence>
                    <xs:element name="state-transfer" type="tns:state-transfer" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>The state transfer configuration for distribution and replicated caches.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="partition-handling" type="tns:partition-handling" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>The partition handling configuration for distribution and replicated caches.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="owners" type="xs:int" default="${Server.DistributedCache.owners}">
                    <xs:annotation>
                        <xs:documentation>Number of cluster-wide replicas for each cache entry.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="segments" type="xs:int" default="${Server.DistributedCache.segments}">
                    <xs:annotation>
                        <xs:documentation>Number of hash space segments (per cluster). The recommended value is 10 * cluster size. The default value is 80</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="capacity-factor" type="xs:double" default="${Server.DistributedCache.capacity-factor}">
                    <xs:annotation>
                        <xs:documentation>Controls the proportion of entries that will reside on the local node,
                            compared to the other nodes in the cluster. Value must be positive. The default is 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="l1-lifespan" type="xs:long" default="${Server.DistributedCache.l1-lifespan}">
                    <xs:annotation>
                        <xs:documentation>Maximum lifespan in milliseconds of an entry placed in the L1 cache. Defaults to 0 which means L1 is disabled.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="loader" abstract="true">
        <xs:sequence>
            <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A cache loader property with name and value.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string">
            <xs:annotation>
                <xs:documentation>Uniquely identifies this loader.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shared" type="xs:boolean" default="${Server.BaseLoader.shared}">
            <xs:annotation>
                <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="preload" type="xs:boolean" default="${Server.BaseLoader.preload}">
            <xs:annotation>
                <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="cluster-loader">
        <xs:complexContent>
            <xs:extension base="tns:loader">
                <xs:attribute name="remote-timeout" type="xs:long">
                    <xs:annotation>
                        <xs:documentation>The timeout when performing remote calls.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="store" abstract="true">
        <xs:sequence>
            <xs:element name="write-behind" type="tns:write-behind" minOccurs="0" maxOccurs="1">
                <xs:annotation>
                    <xs:documentation>Configures a cache store as write-behind instead of write-through.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="property" type="tns:property" minOccurs="0" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>A cache store property with name and value.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="name" type="xs:string">
            <xs:annotation>
                <xs:documentation>Uniquely identifies this store.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shared" type="xs:boolean" default="${Server.BaseLoader.shared}">
            <xs:annotation>
                <xs:documentation>This setting should be set to true when multiple cache instances share the same cache store (e.g., multiple nodes in a cluster using a JDBC-based CacheStore pointing to the same, shared database.) Setting this to true avoids multiple cache instances writing the same modification multiple times. If enabled, only the node where the modification originated will write to the cache store. If disabled, each individual cache reacts to a potential remote update by storing the data to the cache store.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="transactional" type="xs:boolean" default="false">
            <xs:annotation>
                <xs:documentation>This setting should be set to true when the underlying cache store supports transactions and it is desirable for the underlying store and the cache to remain synchronized. With this enabled any Exceptions thrown whilst writing to the underlying store will result in both the store's and cache's transactions rollingback.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="preload" type="xs:boolean" default="${Server.BaseLoader.preload}">
            <xs:annotation>
                <xs:documentation>If true, when the cache starts, data stored in the cache store will be pre-loaded into memory. This is particularly useful when data in the cache store will be needed immediately after startup and you want to avoid cache operations being delayed as a result of loading this data lazily. Can be used to provide a 'warm-cache' on startup, however there is a performance penalty as startup time is affected by this process.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="passivation" type="xs:boolean" default="${Server.BaseStore.passivation}">
            <xs:annotation>
                <xs:documentation>If true, data is only written to the cache store when it is evicted from memory, a phenomenon known as 'passivation'. Next time the data is requested, it will be 'activated' which means that data will be brought back to memory and removed from the persistent store. If false, the cache store contains a copy of the contents in memory, so writes to cache result in cache store writes. This essentially gives you a 'write-through' configuration.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="fetch-state" type="xs:boolean" default="${Server.BaseStore.fetch-state}">
            <xs:annotation>
                <xs:documentation>If true, fetch persistent state when joining a cluster. If multiple cache stores are chained, only one of them can have this property enabled.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="purge" type="xs:boolean" default="${Server.BaseStore.purge}">
            <xs:annotation>
                <xs:documentation>If true, purges this cache store when it starts up.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="singleton" type="xs:boolean" default="${Server.BaseStore.singleton}">
            <xs:annotation>
                <xs:documentation>If true, the singleton store cache store is enabled. SingletonStore is a delegating cache store used for situations when only one instance in a cluster should interact with the underlying store. Deprecated: A shared store should be used instead, as this limits store writes to the primary owner of a key</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="read-only" type="xs:boolean" default="${Server.BaseStore.read-only}">
            <xs:annotation>
                <xs:documentation>If true, the cache store will only be used to load entries. Any modifications made to the caches will not be applied to the store.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-batch-size" type="xs:int" default="${Server.BaseStore.max-batch-size}">
            <xs:annotation>
                <xs:documentation>The maximum size of a batch to be inserted/deleted from the store. If the value is less than one, then no upper limit is placed on the number of operations in a batch.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="write-behind">
        <xs:attribute name="modification-queue-size" type="xs:int" default="${Server.StoreWriteBehind.modification-queue-size}">
            <xs:annotation>
                <xs:documentation>
                    Maximum number of entries in the asynchronous queue. When the queue is full, the store becomes write-through.
                    until it can accept new entries
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="thread-pool-size" type="xs:int" default="${Server.StoreWriteBehind.thread-pool-size}">
            <xs:annotation>
                <xs:documentation>
                    Size of the thread pool whose threads are responsible for applying the modifications to the cache store.
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="custom-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:attribute name="class" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:documentation>The class name of the cache store implementation.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="custom-loader">
        <xs:complexContent>
            <xs:extension base="tns:loader">
                <xs:attribute name="class" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:documentation>The class name of the cache loader implementation.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="file-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:attribute name="max-entries" type="xs:int">
                    <xs:annotation>
                        <xs:documentation>
                            Sets the maximum number of in-memory mappings between keys and their position in the store.
                            Normally this is unlimited, but to avoid excess memory usage, an upper bound can be configured.
                            If this limit is exceeded, entries are removed permanently using the LRU algorithm both from
                            the in-memory index and the underlying file based cache store. Warning: setting this value
                            may cause data loss.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="relative-to" type="xs:string" default="${Server.FileStore.relative-to}">
                    <xs:annotation>
                        <xs:documentation>The base directory in which to store the cache state.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="path" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            The path within "relative-to" in which to store the cache state.
                            If undefined, the path defaults to the cache container name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="remote-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:sequence>
                    <xs:element name="remote-server" type="tns:remote-server" minOccurs="1" maxOccurs="unbounded"/>
                    <xs:element name="authentication" type="tns:remote-store-authentication" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="encryption" type="tns:remote-store-encryption" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                <xs:attribute name="cache" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>The name of the remote cache.  If undefined, the default cache will be used.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="socket-timeout" type="xs:long" default="${Server.RemoteStore.socket-timeout}">
                    <xs:annotation>
                        <xs:documentation>
                            Enable/disable SO_TIMEOUT on socket connections to remote Hot Rod servers with the specified timeout, in milliseconds.
                            A timeout of zero is interpreted as an infinite timeout.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="tcp-no-delay" type="xs:boolean" default="${Server.RemoteStore.tcp-no-delay}">
                    <xs:annotation>
                        <xs:documentation>
                            Enable/disable TCP_NODELAY on socket connections to remote Hot Rod servers.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="hotrod-wrapping" type="xs:boolean" default="${Server.RemoteStore.hotrod-wrapping}">
                    <xs:annotation>
                        <xs:documentation>
                            Ensures that, when entries are retrieved from the remote store, they will be wrapped in a format suitable for serving via HotRod. This flag must be enabled when performing a rolling upgrade
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="raw-values" type="xs:boolean" default="${Server.RemoteStore.raw-values}">
                    <xs:annotation>
                        <xs:documentation>
                            Enables the storage of data on the remote server in "raw" format as opposed to wrapping the entries in InternalCacheEntry. This will make the remote cache interoperable between direct RemoteCacheManager clients and RemoteCacheStore stores
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="protocol-version" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            This property defines the protocol version that this client should use.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="remote-server">
        <xs:attribute name="outbound-socket-binding" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>An outbound socket binding for a remote server.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="remote-store-authentication">
        <xs:choice minOccurs="1" maxOccurs="1">
            <xs:element name="plain" type="tns:remote-store-authentication-plain" />
            <xs:element name="digest" type="tns:remote-store-authentication-digest" />
            <xs:element name="external" type="tns:remote-store-authentication-external" />
        </xs:choice>
    </xs:complexType>

    <xs:complexType name="remote-store-authentication-plain">
        <xs:annotation>
            <xs:documentation>Uses PLAIN authentication with the supplied credentials.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="username" type="xs:string" use="required" />
        <xs:attribute name="password" type="xs:string" use="required" />
    </xs:complexType>

    <xs:complexType name="remote-store-authentication-digest">
        <xs:annotation>
            <xs:documentation>Uses DIGEST-MD5 authentication with the supplied credentials.</xs:documentation>
        </xs:annotation>
        <xs:attribute name="username" type="xs:string" use="required" />
        <xs:attribute name="password" type="xs:string" use="required" />
        <xs:attribute name="realm" type="xs:string" use="required" />
    </xs:complexType>

    <xs:complexType name="remote-store-authentication-external">
        <xs:annotation>
            <xs:documentation>Uses EXTERNAL authentication, with credentials supplied by the encrypted transport client certificate.</xs:documentation>
        </xs:annotation>
    </xs:complexType>

    <xs:complexType name="remote-store-encryption">
        <xs:attribute name="security-realm" use="required">
            <xs:annotation>
                <xs:documentation>A security realm which supplies a truststore for identifying the remote servers. If client authentication is required, then the security realm must also provide an identity keystore.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="sni-hostname">
            <xs:annotation>
                <xs:documentation>An optional SNI hostname for identifying the remote server.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="rest-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:sequence>
                    <xs:element name="remote-server" type="tns:remote-server" minOccurs="1" maxOccurs="unbounded"/>
                    <xs:element name="connection-pool" type="tns:rest-connection-pool" minOccurs="1" maxOccurs="unbounded"/>
                </xs:sequence>

                <xs:attribute name="append-cache-name-to-path" type="xs:boolean" default="${Server.RestStore.append-cache-name-to-path}">
                    <xs:annotation>
                        <xs:documentation>Whether to append the name of the cache to the path.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="path" type="xs:string" default="${Server.RestStore.path}">
                    <xs:annotation>
                        <xs:documentation>The path portion of the URI of the remote REST endpoint.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="rest-connection-pool">
        <xs:attribute name="buffer-size" type="xs:int" default="${Server.RestStore.buffer-size}">
           <xs:annotation>
               <xs:documentation>The size of the socket buffer.</xs:documentation>
           </xs:annotation>
        </xs:attribute>
        <xs:attribute name="connection-timeout" type="xs:int" default="${Server.RestStore.connection-timeout}">
           <xs:annotation>
               <xs:documentation>A connection timeout for remote cache communication.</xs:documentation>
           </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-connections-per-host" type="xs:int" default="${Server.RestStore.max-connections-per-host}">
           <xs:annotation>
               <xs:documentation>The maximum number of connections per host.</xs:documentation>
           </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-total-connections" type="xs:int" default="${Server.RestStore.max-total-connections}">
           <xs:annotation>
               <xs:documentation>The maximum number of total connections.</xs:documentation>
           </xs:annotation>
        </xs:attribute>
        <xs:attribute name="socket-timeout" type="xs:int" default="${Server.RestStore.socket-timeout}">
           <xs:annotation>
               <xs:documentation>A socket timeout for remote cache communication.</xs:documentation>
           </xs:annotation>
       </xs:attribute>
       <xs:attribute name="tcp-no-delay" type="xs:boolean" default="${Server.RestStore.tcp-no-delay}">
           <xs:annotation>
               <xs:documentation>Enable/disable TCP_NODELAY on socket connections to remote Hot Rod servers.</xs:documentation>
           </xs:annotation>
       </xs:attribute>
    </xs:complexType>

    <xs:complexType name="jdbc-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:attribute name="datasource" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:documentation>Defines the jndi name of the datasource.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="dialect" type="tns:dialect" use="optional">
                    <xs:annotation>
                        <xs:documentation>Defines the JDBC dialect.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="db-major-version" type="xs:nonNegativeInteger" use="optional">
                    <xs:annotation>
                        <xs:documentation>Defines the major version of the database.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="db-minor-version" type="xs:nonNegativeInteger" use="optional">
                    <xs:annotation>
                        <xs:documentation>Defines the minor version of the database.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="string-keyed-jdbc-store">
        <xs:complexContent>
            <xs:extension base="tns:jdbc-store">
                <xs:sequence>
                    <xs:element name="string-keyed-table" type="tns:string-keyed-table" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>
                                Defines the table used to store cache entries.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="string-keyed-table">
        <xs:complexContent>
            <xs:extension base="tns:table">
                <xs:attribute name="prefix" type="xs:string" default="${Server.BaseJDBCStore.stringKeyedTablePrefix}">
                    <xs:annotation>
                        <xs:documentation>Defines the prefix prepended to the cache name used when composing the name of the cache entry table.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="table">
        <xs:sequence>
            <xs:element name="id-column" type="tns:id-column" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Defines the column in which to store the cache key or bucket id.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="data-column" type="tns:data-column" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Defines the column in which to store the cache entry or bucket.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="timestamp-column" type="tns:timestamp-column" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Defines the column in which to store the timestamp of the cache entry or bucket.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="fetch-size" type="xs:int" default="${Server.BaseJDBCStore.fetch-size}">
            <xs:annotation>
                <xs:documentation>The fetch size used when querying from this table.  Used to avoid heap memory exhaustion when query is large.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="batch-size" type="xs:int" default="${Server.BaseJDBCStore.batch-size}">
            <xs:annotation>
                <xs:documentation>The statement batch size used when modifying this table.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="create-on-start" type="xs:boolean" default="${Server.BaseJDBCStore.create-on-start}">
            <xs:annotation>
                <xs:documentation>Determines whether database tables should be created by the store on startup.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="drop-on-exit" type="xs:boolean" default="${Server.BaseJDBCStore.drop-on-exit}">
            <xs:annotation>
                <xs:documentation>Determines whether database tables should be dropped by the store on shutdown.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="id-column">
        <xs:attribute name="name" type="xs:string" default="id">
            <xs:annotation>
                <xs:documentation>The name of the column used to store the cache key or bucket id.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string" default="VARCHAR">
            <xs:annotation>
                <xs:documentation>The type of the column used to store the cache key or bucket id.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="data-column">
        <xs:attribute name="name" type="xs:string" default="datum">
            <xs:annotation>
                <xs:documentation>The name of the column used to store the cache entry or bucket.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string" default="BINARY">
            <xs:annotation>
                <xs:documentation>The type of the column used to store the cache entry or bucket.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="timestamp-column">
        <xs:attribute name="name" type="xs:string" default="version">
            <xs:annotation>
                <xs:documentation>The name of the column used to store the cache entry or bucket timestamp.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string" default="BIGINT">
            <xs:annotation>
                <xs:documentation>The type of the column used to store the cache entry or bucket timestamp.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="rocksdb-store">
        <xs:complexContent>
            <xs:extension base="tns:store">
                <xs:sequence>
                    <xs:element name="expiration" type="tns:rocksdb-expiration" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>
                                Defines the expiration settings for the RocksDB cache store.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="compression" type="tns:rocksdb-compression" minOccurs="0">
                        <xs:annotation>
                            <xs:documentation>
                                Defines the data compression to use in the RocksDB store.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:element>
                </xs:sequence>
                <xs:attribute name="relative-to" type="xs:string" default="${Server.RocksDBStore.relative-to}">
                    <xs:annotation>
                        <xs:documentation>The base directory in which to store the cache state.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="path" type="xs:string">
                    <xs:annotation>
                        <xs:documentation>
                            The path within "relative-to" in which to store the cache state.
                            If undefined, the path defaults to the cache container name.
                        </xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="block-size" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>Cache store block size.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="cache-size" type="xs:long">
                    <xs:annotation>
                        <xs:documentation>Cache size for the cache store.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="clear-threshold" type="xs:integer">
                    <xs:annotation>
                        <xs:documentation>Cache store cache clear threshold.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="rocksdb-expiration">
        <xs:attribute name="path" type="xs:string">
            <xs:annotation>
                <xs:documentation>The base directory in which to store expired cache state.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="queue-size" type="xs:integer" default="${Server.RocksDBExpiration.queue-size}">
            <xs:annotation>
                <xs:documentation>Expired entry queue size.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="rocksdb-compression">
        <xs:attribute name="type" type="tns:rocksdb-compression-mode" default="${Server.RocksDBCompression.type}">
            <xs:annotation>
                <xs:documentation>The type of compression to be used by RocksDB store.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:simpleType name="rocksdb-compression-mode">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>No compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SNAPPY">
                <xs:annotation>
                    <xs:documentation>Snappy compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ZLIB">
                <xs:annotation>
                    <xs:documentation>ZLib compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BZLIB2">
                <xs:annotation>
                    <xs:documentation>BZLib 2 compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LZ4">
                <xs:annotation>
                    <xs:documentation>LZ4 compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LZ4HC">
                <xs:annotation>
                    <xs:documentation>LZ4HC compression.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="state-transfer">
        <xs:attribute name="enabled" type="xs:boolean" default="${Server.StateTransfer.enabled}">
            <xs:annotation>
                <xs:documentation>If enabled, this will cause the cache to ask neighboring caches for state when it starts up, so the cache starts 'warm', although it will impact startup time.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long" default="${Server.StateTransfer.timeout}">
            <xs:annotation>
                <xs:documentation>The maximum amount of time (ms) to wait for state from neighboring caches, before throwing an exception and aborting startup.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="chunk-size" type="xs:integer" default="${Server.StateTransfer.chunk-size}">
            <xs:annotation>
                <xs:documentation>The number of cache entries to batch in each transfer.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="await-initial-transfer" type="xs:boolean" default="${Server.StateTransfer.await-initial-transfer}">
            <xs:annotation>
                <xs:documentation>If enabled, this will cause the cache to wait for initial state transfer to complete before responding to requests.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="partition-handling">
        <xs:attribute name="enabled" type="xs:boolean">
            <xs:annotation>
                <xs:documentation>Deprecated, use type instead. If enabled, the cache will enter degraded mode when it loses too many nodes.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="when-split" type="tns:partition-handling-type" default="${Server.PartitionHandling.when-split}">
            <xs:annotation>
                <xs:documentation>The type of actions that are possible when a split brain scenario is encountered.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="merge-policy" type="tns:merge-policy" default="${Server.PartitionHandling.merge-policy}">
            <xs:annotation>
                <xs:documentation>The entry merge policy which should be applied on partition merges.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:simpleType name="partition-handling-type">
        <xs:restriction base="xs:token">
            <xs:enumeration value="DENY_READ_WRITES">
                <xs:annotation>
                    <xs:documentation>If the partition does not have all owners for a given segment, both reads and writes are denied for all keys in that segment.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALLOW_READS">
                <xs:annotation>
                    <xs:documentation>Allows reads for a given key if it exists in this partition, but only allows writes if this partition contains all owners of a segment.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALLOW_READ_WRITES">
                <xs:annotation>
                    <xs:documentation>Allow entries on each partition to diverge, with conflicts resolved during merge.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="merge-policy">
        <xs:union memberTypes="tns:merge-policy-defaults xs:string"/>
    </xs:simpleType>

    <xs:simpleType name="merge-policy-defaults">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>Do not attempt to resolve conflicts on merge.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PREFERRED_ALWAYS">
                <xs:annotation>
                    <xs:documentation>Always utilise the entry located in the preferred partition.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PREFERRED_NON_NULL">
                <xs:annotation>
                    <xs:documentation>Utilise entries from the preferred partition if non-null, otherwise utilise entries from the other partition.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="REMOVE_ALL">
                <xs:annotation>
                    <xs:documentation>If a conflict is encountered for a given key, remove all versions of that key.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:complexType name="backups">
        <xs:sequence>
            <xs:element name="backup" type="tns:backup" maxOccurs="unbounded">
                <xs:annotation>
                    <xs:documentation>Configures a specific site where this cache backups data.</xs:documentation>
                </xs:annotation>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:complexType name="backup">
        <xs:sequence>
            <xs:element name="take-offline" type="tns:take-offline" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>Determines whether this backup is taken offline (ignored) after a certain number of tries.</xs:documentation>
                </xs:annotation>
            </xs:element>
            <xs:element name="state-transfer" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>
                        Configures the properties needed to transfer the state for this site.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="chunk-size" type="xs:int" default="${Server.BackupSiteStateTransfer.chunk-size}">
                        <xs:annotation>
                            <xs:documentation>
                                If &gt; 0, the state will be transferred in batches of {@code chunkSize} cache entries.
                                If &lt;= 0, the state will be transferred in all at once. Not recommended. Defaults to 512.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:long" default="${Server.BackupSiteStateTransfer.timeout}">
                        <xs:annotation>
                            <xs:documentation>
                                The time (in milliseconds) to wait for the backup site acknowledge the state chunk
                                received and applied. Default value is 20 min.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="max-retries" type="xs:int" default="${Server.BackupSiteStateTransfer.max-retries}">
                        <xs:annotation>
                            <xs:documentation>
                                The maximum number of retries when a push state command fails. A value &lt;= 0 (zero) mean that
                                the command will not retry. Default value is 30.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="wait-time" type="xs:long" default="${Server.BackupSiteStateTransfer.wait-time}">
                        <xs:annotation>
                            <xs:documentation>
                                The waiting time (in milliseconds) between each retry. The value should be &gt; 0 (zero). Default
                                value is 2 seconds.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
        <xs:attribute name="site" type="xs:string" use="required">
            <xs:annotation>
                <xs:documentation>Name of the remote site where this cache backups data.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="strategy" type="tns:mode" default="${Server.BackupSite.strategy}">
            <xs:annotation>
                <xs:documentation>The strategy used for backing up data: "SYNC" or "ASYNC". Defaults to "ASYNC"</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="failure-policy" type="tns:backup-failure-policy" default="${Server.BackupSite.failure-policy}">
            <xs:annotation>
                <xs:documentation>Decides what the system would do in case of failure during backup. Defaults to "FAIL"</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="timeout" type="xs:long" default="${Server.BackupSite.timeout}">
            <xs:annotation>
                <xs:documentation>The timeout(millis) to be used when backing up data remotely. Defaults to 10 secs.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="enabled" type="xs:boolean" default="${Server.BackupSite.enabled}">
            <xs:annotation>
                <xs:documentation>If 'false' then no data is backed up to this site. Defaults to 'true'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="take-offline">
        <xs:attribute name="after-failures" type="xs:int" default="${Server.BackupSite.after-failures}">
            <xs:annotation>
                <xs:documentation>The number of failed request operations after which this site should be taken offline. Defaults to 0 (never). A negative value would mean that the site will be taken offline after 'min-wait'.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="min-wait" type="xs:long" default="${Server.BackupSite.min-wait}">
            <xs:annotation>
                <xs:documentation>The minimal number of millis to wait before taking this site offline, even in the case 'after-failures' is reached. If smaller or equal to 0, then only 'after-failures' is considered.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="property">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="name" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:documentation>Defines the name of a property.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

    <xs:simpleType name="isolation">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>No locking isolation will be performed. This is only valid in local mode. In clustered mode, READ_COMMITTED will be used instead.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="READ_UNCOMMITTED">
                <xs:annotation>
                    <xs:documentation>Unsupported. Actually configures READ_COMMITTED</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="READ_COMMITTED">
                <xs:annotation>
                    <xs:documentation>Read committed is an isolation level that guarantees that any data read is committed at the moment it is read. However, depending on the outcome of other transactions, successive reads may return different results</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="REPEATABLE_READ">
                <xs:annotation>
                    <xs:documentation>Repeatable read is an isolation level that guarantees that any data read is committed at the moment it is read and that, within a transaction, successive reads will always return the same data.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SERIALIZABLE">
                <xs:annotation>
                    <xs:documentation>Unsupported. Actually configures REPEATABLE_READ</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="transaction-mode">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>Cache will not enlist within transactions.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NON_XA">
                <xs:annotation>
                    <xs:documentation>Cache will enlist within transactions as a javax.transaction.Synchronization</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NON_DURABLE_XA">
                <xs:annotation>
                    <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, without recovery.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FULL_XA">
                <xs:annotation>
                    <xs:documentation>Cache will enlist within transactions as a javax.transaction.xa.XAResource, with recovery.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="indexing">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>Do not index data. This is the default.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LOCAL">
                <xs:annotation>
                    <xs:documentation>Only index changes made locally, ignoring remote changes. This is useful if indexes are shared across a cluster to prevent redundant indexing of updates.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALL">
                <xs:annotation>
                    <xs:documentation>Index all data</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PRIMARY_OWNER">
                <xs:annotation>
                    <xs:documentation>Only index changes on the primary owner, regardless of it's local or remote.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="eviction-strategy">
        <xs:restriction base="xs:token">
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>Never evict entries. This is the default.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="UNORDERED">
                <xs:annotation>
                    <xs:documentation>Actually activates LRU.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FIFO">
                <xs:annotation>
                    <xs:documentation>Deprecated. Actually activates LRU.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LRU">
                <xs:annotation>
                    <xs:documentation>Least-Recently Used policy.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LIRS">
                <xs:annotation>
                    <xs:documentation>Low Inter-reference Recency Set. An improved version of LRU which uses cache-locality access information to better decide which data to evict.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="MANUAL">
                <xs:annotation>
                    <xs:documentation>Eviction will be performed manually. Equivalent internally to NONE.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="mode">
        <xs:restriction base="xs:token">
            <xs:enumeration value="ASYNC">
                <xs:annotation>
                    <xs:documentation>Enables asynchronous mode.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="SYNC">
                <xs:annotation>
                    <xs:documentation>Enables synchronous mode.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="locking-mode">
        <xs:restriction base="xs:token">
            <xs:enumeration value="OPTIMISTIC">
                <xs:annotation>
                    <xs:documentation>Enables Optimistic locking.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="PESSIMISTIC">
                <xs:annotation>
                    <xs:documentation>Enables Pessimistic locking.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="controller-mode">
        <xs:restriction base="xs:token">
            <xs:enumeration value="EAGER">
                <xs:annotation>
                    <xs:documentation>Whether to start the component on initialization.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LAZY">
                <xs:annotation>
                    <xs:documentation>Whether to start the component on-demand.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="aliases">
        <xs:annotation>
            <xs:documentation>A list of aliases.</xs:documentation>
        </xs:annotation>
        <xs:list itemType="xs:string"/>
    </xs:simpleType>

    <xs:simpleType name="backup-failure-policy">
        <xs:restriction base="xs:token">
            <xs:enumeration value="IGNORE">
                <xs:annotation>
                    <xs:documentation>Ignore backup failures.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="WARN">
                <xs:annotation>
                    <xs:documentation>Warn of backup failures.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="FAIL">
                <xs:annotation>
                    <xs:documentation>Fail local operations when a backup failure occurs.</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="eviction-type">
        <xs:restriction base="xs:string">
            <xs:enumeration value="COUNT">
                <xs:annotation>
                    <xs:documentation>Evicts entries from the cache when a specified count has been set</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="MEMORY">
                <xs:annotation>
                    <xs:documentation>Evicts entries from the cache when a specified memory usage has been reached. Memory usage is computed using an approximation which is tailored for the HotSpot VM. This can only be used when both key and values are stored as byte arrays. To guarantee only byte arrays are stored it is recommended to run with store as binary for both keys and values</xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="permission-list">
        <xs:list itemType="tns:permission" />
    </xs:simpleType>

    <xs:simpleType name="permission">
        <xs:restriction base="xs:string">
            <xs:enumeration value="LIFECYCLE">
                <xs:annotation>
                    <xs:documentation>
                        Allows control of a cache's lifecycle (i.e. starting and stopping a
                        cache)
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="READ">
                <xs:annotation>
                    <xs:documentation>
                        Allows reading data from a cache
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="WRITE">
                <xs:annotation>
                    <xs:documentation>
                        Allows writing data to a cache
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="EXEC">
                <xs:annotation>
                    <xs:documentation>
                        Allows performing task execution (e.g. distributed executors,
                        map/reduce) on a cache
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="LISTEN">
                <xs:annotation>
                    <xs:documentation>
                        Allows attaching listeners to a cache
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BULK_READ">
                <xs:annotation>
                    <xs:documentation>
                        Allows bulk-read operations (e.g. obtaining all the keys in a cache)
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="BULK_WRITE">
                <xs:annotation>
                    <xs:documentation>
                        Allows bulk-write operations (e.g. clearing a cache)
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ADMIN">
                <xs:annotation>
                    <xs:documentation>
                        Allows performing "administrative" operations on a cache
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALL">
                <xs:annotation>
                    <xs:documentation>
                        Aggregate permission which implies all of the others
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALL_READ">
                <xs:annotation>
                    <xs:documentation>
                        Aggregate permission which implies all read permissions (READ and
                        BULK_READ)
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="ALL_WRITE">
                <xs:annotation>
                    <xs:documentation>
                        Aggregate permission which implies all write permissions (WRITE and
                        BULK_WRITE)
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
            <xs:enumeration value="NONE">
                <xs:annotation>
                    <xs:documentation>
                        Permission which means no permissions
                    </xs:documentation>
                </xs:annotation>
            </xs:enumeration>
        </xs:restriction>
    </xs:simpleType>

    <xs:simpleType name="role-list">
        <xs:list itemType="xs:string" />
    </xs:simpleType>

    <xs:complexType name="cache-security">
        <xs:sequence>
            <xs:element name="authorization" minOccurs="0">
                <xs:annotation>
                    <xs:documentation>
                        Configures authorization for this cache.
                    </xs:documentation>
                </xs:annotation>
                <xs:complexType>
                    <xs:attribute name="enabled" type="xs:boolean" default="${Server.CacheAuthorization.enabled}">
                        <xs:annotation>
                            <xs:documentation>
                                Enables authorization checks for this cache. Defaults to true if the authorization element is present.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="roles" type="tns:role-list">
                        <xs:annotation>
                            <xs:documentation>
                                Sets the valid roles required to access this cache.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:complexType>
            </xs:element>
        </xs:sequence>
    </xs:complexType>

    <xs:simpleType name="dialect">
        <xs:restriction base="xs:token">
            <xs:enumeration value="ACCESS"/>
            <xs:enumeration value="DB2"/>
            <xs:enumeration value="DB2_390"/>
            <xs:enumeration value="DERBY"/>
            <xs:enumeration value="FIREBIRD"/>
            <xs:enumeration value="H2"/>
            <xs:enumeration value="HSQL"/>
            <xs:enumeration value="INFORMIX"/>
            <xs:enumeration value="INTERBASE"/>
            <xs:enumeration value="MARIA_DB"/>
            <xs:enumeration value="MYSQL"/>
            <xs:enumeration value="ORACLE"/>
            <xs:enumeration value="POSTGRES"/>
            <xs:enumeration value="SQL_SERVER"/>
            <xs:enumeration value="SQLITE"/>
            <xs:enumeration value="SYBASE"/>
        </xs:restriction>
    </xs:simpleType>


    <xs:complexType name="thread-pool">
        <xs:attribute name="min-threads" type="xs:int" use="optional">
            <xs:annotation>
                <xs:documentation>Minimum thread pool size for the thread pool.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="max-threads" type="xs:int" use="optional">
            <xs:annotation>
                <xs:documentation>Maximum thread pool size for the thread pool.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="queue-length" type="xs:int" use="optional">
            <xs:annotation>
                <xs:documentation>Maximum queue length for the thread pool.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="keepalive-time" type="xs:long" use="optional">
            <xs:annotation>
                <xs:documentation>Timeout in milliseconds to remove idle thread from the pool.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>
</xs:schema>
