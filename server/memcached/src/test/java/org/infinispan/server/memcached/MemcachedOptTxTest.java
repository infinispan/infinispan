package org.infinispan.server.memcached;

import static java.lang.String.format;
import static org.infinispan.configuration.global.GlobalConfigurationBuilder.defaultClusteredBuilder;
import static org.infinispan.test.TestingUtil.k;
import static org.infinispan.test.TestingUtil.v;
import static org.infinispan.test.fwk.TestCacheManagerFactory.createClusteredCacheManager;
import static org.testng.AssertJUnit.assertEquals;
import static org.testng.AssertJUnit.assertNotNull;
import static org.testng.AssertJUnit.assertTrue;
import static org.testng.AssertJUnit.fail;

import java.lang.reflect.Method;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import org.infinispan.configuration.cache.CacheMode;
import org.infinispan.configuration.cache.ConfigurationBuilder;
import org.infinispan.container.DataContainer;
import org.infinispan.container.entries.CacheEntry;
import org.infinispan.container.versioning.EntryVersion;
import org.infinispan.container.versioning.SimpleClusteredVersion;
import org.infinispan.manager.EmbeddedCacheManager;
import org.infinispan.metadata.Metadata;
import org.infinispan.server.core.ServerMetadata;
import org.infinispan.transaction.LockingMode;
import org.infinispan.util.concurrent.IsolationLevel;
import org.testng.annotations.Test;

import net.spy.memcached.CASResponse;
import net.spy.memcached.CASValue;
import net.spy.memcached.MemcachedClient;
import net.spy.memcached.internal.OperationFuture;

/**
 * Tests if the version generated by Optimistic Locking and Write-Skew doesn't conflict with the data version generated
 * by hot rod.
 *
 * @author Pedro Ruivo
 * @since 9.0
 */
@Test(groups = "functional", testName = "server.hotrod.HotRodOptTxTest")
public class MemcachedOptTxTest extends MemcachedMultiNodeTest {

   @Override
   protected EmbeddedCacheManager createCacheManager(int index) {
      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.REPL_SYNC, true);
      builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);
      builder.transaction().lockingMode(LockingMode.OPTIMISTIC);
      return createClusteredCacheManager(defaultClusteredBuilder().defaultCacheName(cacheName), builder);
   }

   public void testPut(Method method) throws Exception {
      performTest(method, TestOperation.PUT);
   }

   public void testReplace(Method method) throws Exception {
      performTest(method, TestOperation.REPLACE);
   }

   public void testReplaceIfUnmodified(Method method) throws Exception {
      performTest(method, TestOperation.REPLACE_IF_UNMODIFIED);
   }

   public void testRemove(Method method) throws Exception {
      performTest(method, TestOperation.REMOVE);
   }

   private void performTest(Method method, TestOperation testOperation) throws Exception {
      final String key = k(method);
      final String value1 = v(method, "v1-");
      final String value2 = v(method, "v1-");

      final MemcachedClient client = clients.get(0);

      OperationFuture<Boolean> fut = client.set(key, 1, value1);
      assertTrue("Initial operation failed.", fut.get(10, TimeUnit.SECONDS));
      assertContainerEntry(key);

      testOperation.perform(client, key, value2);
      if (testOperation.keyExists()) {
         assertContainerEntry(key);
      }
   }

   private void assertContainerEntry(String key) {
      DataContainer<Object, Object> container = advancedCache(0, cacheName).getDataContainer();
      CacheEntry<Object, Object> entry = container.get(key);
      assertNotNull(format("Entry should be not null. key=%s", key), entry);

      checkMetadata(key, entry.getMetadata());
   }

   private void checkStreamVersion(String key, Metadata metadata) {
      if (metadata instanceof ServerMetadata) {
         long streamVersion = ((ServerMetadata) metadata).streamVersion();
         assertTrue(format("Stream Version must be non-zero. key=%s", key), streamVersion != 0);
      } else {
         fail(format("Metadata must be instance of ServerMetadata. metadata=%s. key=%s", metadata, key));
      }
   }

   private void checkEntryVersion(String key, Metadata metadata) {
      EntryVersion version = metadata.version();
      if (!(version instanceof SimpleClusteredVersion)) {
         fail(format("EntryVersion must be instance of SimpleClusteredVersion. version=%s. key=%s", version, key));
      }
   }

   private void checkMetadata(String key, Metadata metadata) {
      assertNotNull(format("Metadata should be not null. key=%s", key), metadata);
      checkStreamVersion(key, metadata);
      checkEntryVersion(key, metadata);
   }

   private enum TestOperation {
      PUT {
         @Override
         void perform(MemcachedClient client, String key, String value) throws InterruptedException, ExecutionException, TimeoutException {
            OperationFuture<Boolean> fut = client.set(key, 2, value);
            assertTrue("Put operation failed.", fut.get(10, TimeUnit.SECONDS));
         }
      },
      REPLACE {
         @Override
         void perform(MemcachedClient client, String key, String value) throws InterruptedException, ExecutionException, TimeoutException {
            OperationFuture<Boolean> fut = client.replace(key, 1, value);
            assertTrue("Replace operation failed.", fut.get(10, TimeUnit.SECONDS));
         }
      },
      REPLACE_IF_UNMODIFIED {
         @Override
         void perform(MemcachedClient client, String key, String value) {
            CASValue<Object> cas = client.gets(key);
            assertTrue("CAS can't be zero.", cas.getCas() != 0);
            CASResponse rsp = client.cas(key, cas.getCas(), value);
            assertEquals("Wrong replace_if response.", CASResponse.OK, rsp);
         }
      },
      REMOVE {
         @Override
         void perform(MemcachedClient client, String key, String value) throws InterruptedException, ExecutionException, TimeoutException {
            OperationFuture<Boolean> fut = client.delete(key);
            assertTrue("Remove operation failed.", fut.get(10, TimeUnit.SECONDS));
         }

         @Override
         boolean keyExists() {
            return false;
         }
      };

      abstract void perform(MemcachedClient client, String key, String value) throws InterruptedException, ExecutionException, TimeoutException;

      boolean keyExists() {
         return true;
      }
   }

}
