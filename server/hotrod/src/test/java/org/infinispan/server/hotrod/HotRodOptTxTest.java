package org.infinispan.server.hotrod;

import static java.lang.String.format;
import static org.infinispan.commons.util.Util.printArray;
import static org.infinispan.server.hotrod.OperationStatus.Success;
import static org.infinispan.server.hotrod.test.HotRodTestingUtil.assertStatus;
import static org.infinispan.server.hotrod.test.HotRodTestingUtil.k;
import static org.infinispan.server.hotrod.test.HotRodTestingUtil.v;
import static org.testng.AssertJUnit.assertArrayEquals;
import static org.testng.AssertJUnit.assertEquals;
import static org.testng.AssertJUnit.assertNotNull;
import static org.testng.AssertJUnit.assertTrue;
import static org.testng.AssertJUnit.fail;

import java.lang.reflect.Method;

import org.infinispan.commons.marshall.WrappedByteArray;
import org.infinispan.configuration.cache.CacheMode;
import org.infinispan.configuration.cache.ConfigurationBuilder;
import org.infinispan.container.DataContainer;
import org.infinispan.container.entries.CacheEntry;
import org.infinispan.container.versioning.EntryVersion;
import org.infinispan.container.versioning.SimpleClusteredVersion;
import org.infinispan.metadata.Metadata;
import org.infinispan.server.core.ServerMetadata;
import org.infinispan.server.hotrod.test.HotRodClient;
import org.infinispan.server.hotrod.test.TestGetWithVersionResponse;
import org.infinispan.server.hotrod.test.TestResponse;
import org.infinispan.transaction.LockingMode;
import org.infinispan.util.concurrent.IsolationLevel;
import org.testng.annotations.Test;

/**
 * Tests if the version generated by Optimistic Locking and Write-Skew doesn't conflict with the data version generated
 * by hot rod.
 *
 * @author Pedro Ruivo
 * @since 9.0
 */
@Test(groups = "functional", testName = "server.hotrod.HotRodOptTxTest")
public class HotRodOptTxTest extends HotRodMultiNodeTest {
   @Override
   protected String cacheName() {
      return getClass().getSimpleName();
   }

   @Override
   protected ConfigurationBuilder createCacheConfig() {
      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.REPL_SYNC, true);
      builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);
      builder.transaction().lockingMode(LockingMode.OPTIMISTIC);
      return builder;
   }

   public void testPut(Method method) {
      performTest(method, TestOperation.PUT);
   }

   public void testPutIfAbsent(Method method) {
      performTest(method, TestOperation.PUT_IF_ABSENT);
   }

   public void testReplace(Method method) {
      performTest(method, TestOperation.REPLACE);
   }

   public void testReplaceIfUnmodified(Method method) {
      performTest(method, TestOperation.REPLACE_IF_UNMODIFIED);
   }

   public void testRemove(Method method) {
      performTest(method, TestOperation.REMOVE);
   }

   public void testRemoveIfUnmodified(Method method) {
      performTest(method, TestOperation.REMOVE_IF_UNMODIFIED);
   }

   private void performTest(Method method, TestOperation testOperation) {
      final byte[] key = k(method);
      final byte[] value1 = v(method, "v1-");
      final byte[] value2 = v(method, "v1-");

      final HotRodClient client = clients().get(0);

      if (testOperation.needsPreviousValue()) {
         client.put(key, 0, 0, value1);
         assertContainerEntry(key, value1);
      }

      testOperation.perform(client, key, value2);
      if (testOperation.keyExists()) {
         assertContainerEntry(key, value2);
      }
   }

   private void assertContainerEntry(byte[] key, byte[] value) {
      final String keyString = printArray(key);
      DataContainer<Object, Object> container = advancedCache(0, cacheName()).getDataContainer();
      CacheEntry<Object, Object> entry = container.get(new WrappedByteArray(key));
      assertNotNull(format("Entry should be not null. key=%s", keyString), entry);

      checkValue(keyString, value, entry.getValue());
      checkMetadata(keyString, entry.getMetadata());
   }

   private void checkValue(String keyString, byte[] expectedValue, Object valueObj) {
      assertNotNull(format("Value should be not null. key=%s", keyString), valueObj);
      assertEquals(format("Wrong value class. key=%s", keyString), WrappedByteArray.class, valueObj.getClass());
      assertArrayEquals(format("Wrong value. key=%s", keyString), expectedValue, ((WrappedByteArray) valueObj).getBytes());
   }

   private void checkStreamVersion(String key, Metadata metadata) {
      if (metadata instanceof ServerMetadata) {
         long streamVersion = ((ServerMetadata) metadata).streamVersion();
         assertTrue(format("Stream Version must be non-zero. key=%s", key), streamVersion != 0);
      } else {
         fail(format("Metadata must be instance of ServerMetadata. metadata=%s. key=%s", metadata, key));
      }
   }

   private void checkEntryVersion(String key, Metadata metadata) {
      EntryVersion version = metadata.version();
      if (!(version instanceof SimpleClusteredVersion)) {
         fail(format("EntryVersion must be instance of SimpleClusteredVersion. version=%s. key=%s", version, key));
      }
   }

   private void checkMetadata(String key, Metadata metadata) {
      assertNotNull(format("Metadata should be not null. key=%s", key), metadata);
      checkStreamVersion(key, metadata);
      checkEntryVersion(key, metadata);
   }

   private enum TestOperation {
      PUT {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestResponse rsp = client.put(key, 0, 0, value);
            assertStatus(rsp, Success);
         }
      },
      PUT_IF_ABSENT {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestResponse rsp = client.putIfAbsent(key, 0, 0, value);
            assertStatus(rsp, Success);
         }

         @Override
         boolean needsPreviousValue() {
            return false;
         }
      },
      REPLACE {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestResponse rsp = client.replace(key, 0, 0, value);
            assertStatus(rsp, Success);
         }
      },
      REPLACE_IF_UNMODIFIED {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestGetWithVersionResponse rsp = client.getWithVersion(key, 0);
            assertStatus(rsp, Success);
            assertTrue(format("Data Version must be non-zero. key=%s", printArray(key)), rsp.dataVersion != 0);
            TestResponse rsp2 = client.replaceIfUnmodified(key, 0, 0, value, rsp.dataVersion);
            assertStatus(rsp2, Success);
         }
      },
      REMOVE {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestResponse rsp = client.remove(key);
            assertStatus(rsp, Success);
         }

         @Override
         boolean keyExists() {
            return false;
         }
      },
      REMOVE_IF_UNMODIFIED {
         @Override
         void perform(HotRodClient client, byte[] key, byte[] value) {
            TestGetWithVersionResponse rsp = client.getWithVersion(key, 0);
            assertStatus(rsp, Success);
            assertTrue(format("Data Version must be non-zero. key=%s", printArray(key)), rsp.dataVersion != 0);
            TestResponse rsp2 = client.removeIfUnmodified(key, rsp.dataVersion, 0);
            assertStatus(rsp2, Success);
         }

         @Override
         boolean keyExists() {
            return false;
         }
      };

      abstract void perform(HotRodClient client, byte[] key, byte[] value);

      boolean keyExists() {
         return true;
      }

      boolean needsPreviousValue() {
         return true;
      }
   }

}
