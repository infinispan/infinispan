[id='off-heap-memory_{context}']
= JVM heap and off-heap memory

{brandname} stores cache entries in JVM heap memory by default.
You can configure {brandname} to use off-heap storage, which means your data occupies native memory outside the managed JVM memory space with the following benefits:

* Uses less memory than JVM heap memory for the same amount of data.
* Can improve overall JVM performance by avoiding Garbage Collector (GC) runs.

However, there are some trade-offs with off-heap storage; for example, JVM heap dumps do not show entries stored in off-heap memory.

The following diagram illustrates the memory space for a JVM process where {brandname} is running:

.JVM memory space
image::jvm_memory_space.png[Illustration of JVM memory space]

[discrete]
== JVM heap memory

The heap is divided into young and old generations that help keep referenced Java objects and other application data in memory.
The GC process reclaims space from unreachable objects, running more frequently on the young generation memory pool.

When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.
Because GC is an intensive process, longer and more frequent runs can degrade application performance.

[discrete]
== Off-heap memory

Off-heap memory is native available system memory outside JVM memory management.
The _JVM memory space_ diagram shows the `Metaspace` memory pool that holds class metadata and is allocated from native memory.
The diagram also represents a section of native memory that holds {brandname} cache entries.
