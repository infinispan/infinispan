[[sid-68355091]]

==  Java Hot Rod client

[[sid-68355091_JavaHotRodclient-Introduction]]


=== Introduction

Hot Rod is a binary, language neutral protocol. This article explains how a Java client can interact with a server via the Hot Rod protocol. A reference implementation of the protocol written in Java can be found in all Infinispan distributions since 4.1, and this article focuses on the capabilities of this java client.

[[sid-68355091_JavaHotRodclient-BasicAPI]]


=== Basic API

 Bellow is a sample code snippet on how the client API can be used to store or retrieve information from a Hot Rod server using the Java Hot Rod client. It assumes that a Hot Rod server has been started bound to the default location (localhost:11222) 


----
//API entry point, by default it connects to localhost:11222
CacheContainer cacheContainer = new RemoteCacheManager();

//obtain a handle to the remote default cache
Cache<String, String> cache = cacheContainer.getCache();

//now add something to the cache and make sure it is there
cache.put("car", "ferrari");
assert cache.get("car").equals("ferrari");

//remove the data
cache.remove("car");
assert !cache.containsKey("car") : "Value must have been removed!";

----

 The client API maps the local API: link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] corresponds to link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/DefaultCacheManager.html$$[DefaultCacheManager] (both implement link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/manager/CacheContainer.html$$[CacheContainer] ). This common API facilitates an easy migration from local calls to remote calls through Hot Rod: all one needs to do is switch between link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/manager/DefaultCacheManager.html$$[DefaultCacheManager] and link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] - which is further simplified by the common link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/manager/CacheContainer.html$$[CacheContainer] interface that both inherit. 

Starting from Infinispan 5.2, all keys can be retrieved from the remote cache (whether it's local, replicated, or distributed) by using keySet() method. If the remote cache is a distributed cache, the server will start a map/reduce job to retrieve all keys from clustered nodes, and return all keys to the client.  Please use this method with care if there are large number of keys.


----
Set keys = remoteCache.keySet();

----

[[sid-68355091_JavaHotRodclient-VersionedAPI]]


=== Versioned API

 A RemoteCacheManager provides instances of link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] interface that represents a handle to the named or default cache on the remote cluster. API wise, it extends the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface to which it also adds some new methods, including the so called versioned API. Please find below some examples of this API link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737101$$[but to understand the motivation behind it, make sure you read this article] . 

 The code snippet bellow depicts the usage of these versioned methods: 


----
// To use the versioned API, remote classes are specifically needed
RemoteCacheManager remoteCacheManager = new RemoteCacheManager();
RemoteCache<String, String> cache = remoteCacheManager.getCache();

remoteCache.put("car", "ferrari");
RemoteCache.VersionedValue valueBinary = remoteCache.getVersioned("car");

// removal only takes place only if the version has not been changed
// in between. (a new version is associated with 'car' key on each change)
assert remoteCache.remove("car", valueBinary.getVersion());
assert !cache.containsKey("car");

----

In a similar way, for replace:


----
remoteCache.put("car", "ferrari");
RemoteCache.VersionedValue valueBinary = remoteCache.getVersioned("car");
assert remoteCache.replace("car", "lamborghini", valueBinary.getVersion());

----

 For more details on versioned operations refer to link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] 's javadoc. 

[[sid-68355091_JavaHotRodclient-AsyncAPI]]


=== Async API

 This cool feature is "borrowed" from the Infinispan core and it is largely discussed link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737045$$[here] . 

[[sid-68355091_JavaHotRodclient-Unsupportedmethods]]


=== Unsupported methods

 Some of the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] methods are not being supported by the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] . Calling one of these methods results in an link:$$http://download.oracle.com/javase/6/docs/api/java/lang/UnsupportedOperationException.html$$[UnsupportedOperationException] being thrown. Most of these methods do not make sense on the remote cache (e.g. listener management operations), or correspond to methods that are not supported by local cache as well (e.g. containsValue). Another set of unsupported operations are some of the atomic operations inherited from link:$$http://java.sun.com/j2se/1.5.0/docs/api/java/util/concurrent/ConcurrentMap.html$$[ConcurrentMap] : 


----
boolean remove(Object key, Object value);
boolean replace(Object key, Object value);
boolean replace(Object key, Object oldValue, Object value);

----

 link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] offers alternative versioned methods for these atomic operations, that are also network friendly, by not sending the whole value object over the network, but a version identifier. See the section on versioned API. 

 Each one of these unsupported operation is documented in the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] javadoc. 

[[sid-68355091_JavaHotRodclient-Returnvalues]]


=== Return values

 There is a set of methods that alter an cached entry and return the previous existing value, e.g.: 


----
V remove(Object key);
V put(K key, V value);
----

 By default on RemoteCache, these operations return null even if such a previous value exists. This approach reduces the amount of data sent over the network. However, if these return values are needed they can be enforced on an per invocation basis using flags: 


----
cache.put("aKey", "initialValue");
assert null == cache.put("aKey", "aValue");
assert "aValue".equals(cache.withFlags(Flag.FORCE_RETURN_VALUE).put("aKey",
   "newValue"));

----

This default behaviour can can be changed through force-return-value=true configuration parameter (see configuration section bellow).

[[sid-68355091_JavaHotRodclient-Intelligence]]


=== Intelligence

HotRod defines three level of intelligence for the clients:


* basic client, interested in neither cluster nor hash information


* topology-aware client, interested in cluster information


* hash-distribution-aware client, that is interested in both cluster and hash information

The java client supports all 3 levels of intelligence. It is transparently notified whenever a new server is added/removed from the HotRod cluster. At startup it only needs to know the address of one HotRod server (ip:host). On connection to the server the cluster topology is piggybacked to the client, and all further requests are being dispatched to all available servers. Any further topology change is also piggybacked.

Hash-distribution-aware client is discussed in the next section.

[[sid-68355091_JavaHotRodclient-Hashdistributionawareclient]]


=== distribution-aware client

Another aspect of the 3rd level of intelligence is the fact that it is hash-distribution-aware. This means that, for each operation, the client chooses the most appropriate remote server to go to: the data owner. As an example, for a put(k,v) operation, the client calculates k's hash value and knows exactly on which server the data resides on. Then it picks up a tcp connection to that particular server and dispatches the operation to it. This means less burden on the server side which would otherwise need to lookup the value based on the key's hash. It also results in a quicker response from the server, as an additional network roundtrip is skipped. This hash-distribution-aware aspect is only relevant to the distributed HotRod clusters and makes no difference for replicated server deployments.

[[sid-68355091_JavaHotRodclient-RequestBalancing]]


=== Request Balancing

Request balancing is only relevant when the server side is configured with replicated infinispan cluster (on distributed clusters the hash-distribution-aware client logic is used, as discussed in the previos paragraph). Because the client is topology-aware, it knows the list of available servers at all the time. Request balancing has to do with how the client dispatches requests to the available servers.

 The default strategy is round-robin: requests are being dispatched to all existing servers in a circular manner. E.g. given a cluster of servers {s1, s2, s3} here is how request will be dispatched: 


----
CacheContainer cacheContainer = new RemoteCacheManager();
Cache<String, String> cache = cacheContainer.getCache();

cache.put("key1", "aValue"); //this goes to s1
cache.put("key2", "aValue"); //this goes to s2
String value = cache.get("key1"); //this goes to s3

cache.remove("key2"); //this is dispatched to s1 again, and so on...

----

 Custom types of balancing policies can defined by implementing the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/impl/transport/tcp/RequestBalancingStrategy.html$$[RequestBalancingStrategy] and by specifying it through the infinispan.client.hotrod.request-balancing-strategy configuration property. Please refer to configuration section for more details on this. 

[[sid-68355091_JavaHotRodclient-Persistentconnections]]


=== Persistent connections

In order to avoid creating a TCP connection on each request (which is a costly operation), the client keeps a pool of persistent connections to all the available servers and it reuses these connections whenever it is possible. The validity of the connections is checked using an async thread that iterates over the connections in the pool and sends a HotRod ping command to the server. By using this connection validation process the client is being proactive: there's a hight chance for broken connections to be found while being idle in the pool and no on actual request from the application.

 The number of connections per server, total number of connections, how long should a connection be kept idle in the pool before being closed - all these (and more) can be configured. Please refer to the javadoc of link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] for a list of all possible configuration elements. 

[[sid-68355091_JavaHotRodclient-Marshallingdata]]


=== Marshalling data

The Hot Rod client allows one to plug in a custom marshaller for transforming user objects into byte arrays and the other way around. This transformation is needed because of Hot Rod's binary nature - it doesn't know about objects.

 The marshaller can be plugged through the "marshaller" configuration element (see Configuration section): the value should be the fully qualified name of a class implementing the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/Marshaller.html$$[Marshaller] interface. This is a optional parameter, if not specified it defaults to the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/marshall/jboss/GenericJBossMarshaller.html$$[GenericJBossMarshaller] - a highly optimized implementation based on the link:$$http://www.jboss.org/jbossmarshalling$$[JBoss Marshalling] library. 

 Since version 5.0, there's a new marshaller available to Java Hot Rod clients based on Apache Avro which generates portable payloads. You can find more information about it <<sid-68355061,here>> 

[[sid-68355091_JavaHotRodclient-Statistics]]


=== Statistics

 Various server usage statistics can be obtained through the link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] .stats() method. This returns an link:$$http://docs.jboss.org/infinispan/4.1/apidocs/org/infinispan/client/hotrod/ServerStatistics.html$$[ServerStatistics] object - please refer to javadoc for details on the available statistics. 

[[sid-68355091_JavaHotRodclient-Configuration]]


=== Configuration

 All the configurations are passed to the RemoteCacheManager's constructor as key-value pairs, through an instance of link:$$http://download.oracle.com/javase/6/docs/api/java/util/Properties.html$$[java.util.Properties] or reference to a .properties file. Please refer to the javadoc of RemoteCacheManager for a exhaustive list of the possible configuration elements. 

[[sid-68355091_JavaHotRodclient-MultiGetOperations]]


=== Multi-Get Operations

 The Java Hot Rod client does not provide multi-get functionality out of the box but clients can build it themselves with the given APIs. More information on this topic can be found in the link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=9470083$$[Hot Rod protocol article] . 

[[sid-68355091_JavaHotRodclient-Moreinfo]]


=== More info

It is highly recommended to read the following Javadocs (this is pretty much all the public API of the client):


*  link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCacheManager.html$$[RemoteCacheManager] 


*  link:$$http://docs.jboss.org/infinispan/5.2/apidocs/org/infinispan/client/hotrod/RemoteCache.html$$[RemoteCache] 

