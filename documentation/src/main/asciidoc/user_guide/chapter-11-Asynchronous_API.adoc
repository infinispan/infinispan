[[sid-68355036]]

==  Asynchronous API

 In addition to synchronous API methods like link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html#put%28K,%20V%29$$[Cache.put()] , link:$$http://java.sun.com/javase/6/docs/api/java/util/Map.html#remove%28java.lang.Object%29$$[Cache.remove()] , etc., Infinispan also has an asynchronous, non-blocking API where you can achieve the same results in a non-blocking fashion. 

 These methods are named in a similar fashion to their blocking counterparts, with "Async" appended.  E.g., link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#putAsync%28K,%20V%29$$[Cache.putAsync()] , link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html#removeAsync%28java.lang.Object%29$$[Cache.removeAsync()] , etc.  These asynchronous counterparts return a link:$$http://download.oracle.com/javase/6/docs/api/java/util/concurrent/Future.html$$[Future] containing the actual result of the operation. 

For example, in a cache paramerized as Cache&lt;String, String&gt;, Cache.put(String key, String value) returns a String.  Cache.putAsync(String key, String value) would return a Future&lt;String&gt;.

[[sid-68355036_AsynchronousAPI-WhyusesuchanAPI%3F]]


=== Why use such an API?

Non-blocking APIs are powerful in that they provide all of the guarantees of synchronous communications - with the ability to handle communication failures and exceptions - with the ease of not having to block until a call completes.  This allows you to better harness parallelism in your system.  For example:


----
Set<Future<?>> futures = new HashSet<Future<?>>();
futures.add(cache.putAsync(key1, value1)); // does not block
futures.add(cache.putAsync(key2, value2)); // does not block
futures.add(cache.putAsync(key3, value3)); // does not block

// the remote calls for the 3 puts will effectively be executed
// in parallel, particularly useful if running in distributed mode
// and the 3 keys would typically be pushed to 3 different nodes
// in the cluster

// check that the puts completed successfully
for (Future<?> f: futures) f.get();

----

[[sid-68355036_AsynchronousAPI-Whichprocessesactuallyhappenasynchronously%3F]]


=== Which processes actually happen asynchronously?

 There are 4 things in Infinispan that can be considered to be on the critical path of a typical write operation.  These are, in terms of cost, network calls, marshalling, writing to a cache store (optional), and locking.  As of Infinispan 4.0, using the async methods will take the network calls and marshalling off the critical path.  For various technical reasons, writing to a cache store and acquiring locks, however, still happens in the caller's thread.  In future, we plan to take these offline as well.  See link:$$http://lists.jboss.org/pipermail/infinispan-dev/2010-January/002219.html$$[this developer mail list thread] about this topic. 

[[sid-68355036_AsynchronousAPI-Notifyingfutures]]


=== Notifying futures

 Strictly, these methods do not return JDK Futures, but rather a sub-interface known as a link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/util/concurrent/NotifyingFuture.html$$[NotifyingFuture] .  The main difference is that you can attach a listener to a NotifyingFuture such that you could be notified when the future completes.  Here is an example of making use of a notifying future: 


----

FutureListener futureListener = new FutureListener() {

   public void futureDone(Future future) {
      try {
         future.get();
      } catch (Exception e) {
         // Future did not complete successfully
         System.out.println("Help!");
      }
   }
};
      
cache.putAsync("key", "value").attachListener(futureListener);

----

[[sid-68355036_AsynchronousAPI-Furtherreading]]


=== Further reading

 The Javadocs on the link:$$http://docs.jboss.org/infinispan/4.0/apidocs/org/infinispan/Cache.html$$[Cache] interface has some examples on using the asynchronous API, as does link:$$http://infinispan.blogspot.com/2009/05/whats-so-cool-about-asynchronous-api.html$$[this article] by Manik Surtani introducing the API. 

