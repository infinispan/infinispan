[[sid-68355076]]

==  Using Infinispan as a Spring Cache provider


----
h1. Introduction

Starting with 3.1 Spring offers a [cache abstraction|<a href="http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/">http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/</a>], enabling users to declaratively add caching support to applications via two simple annotations, {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font}. While out of the box Spring 3.1's caching support is backed by [Ehcache|<a href="http://ehcache.org/">http://ehcache.org/</a>] it has been designed to easily support different cache providers. To that end Spring 3.1 defines a simple and straightforward SPI other caching solutions may implement. Infinispan's very own spring module does - amongst other things - exactly this and therefore users invested in Spring's programming model may easily have all their caching needs fulfilled through Infinispan. Here's how.

(Note that the following is based on a small but fully functional example that is part of Spring Infinispan's test suite. For further details you are encouraged to look at {font:monospace}org.infinispan.spring.provider.sample.CachingBookDaoContextTest{font} and its ilk.)

h1. Activating Spring Cache support

You activate Spring's cache support via putting
{code:xml}
<beans xmlns="<a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a>" 
            xmlns:xsi="<a href="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</a>"
            xmlns:cache="<a href="http://www.springframework.org/schema/cache">http://www.springframework.org/schema/cache</a>"
            xsi:schemaLocation="
                <a href="http://www.springframework.org/schema/beans">http://www.springframework.org/schema/beans</a> 
                <a href="http://www.springframework.org/schema/beans/spring-beans.xsd">http://www.springframework.org/schema/beans/spring-beans.xsd</a>
                <a href="http://www.springframework.org/schema/cache">http://www.springframework.org/schema/cache</a> 
                <a href="http://www.springframework.org/schema/cache/spring-cache.xsd">http://www.springframework.org/schema/cache/spring-cache.xsd</a>">

  <cache:annotation-driven />

</beans>

----

somewhere in your application context. This will tell Spring to be on the lookout for {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font} within your application code.Now, assuming you've already {font:monospace}infinispan.jar{font} and its dependencies on your classpath, all that's left to do is installing {font:monospace}infinispan-spring{font} and {font:monospace}spring{font}. For maven users this translates into


----

     <dependency>
         <groupId>org.springframework</groupId>
         <artifactId>spring-context</artifactId>
         <version>3.1.0.M1</version>
         <scope>compile</scope>
      </dependency>
      <dependency>
         <groupId>org.infinispan</groupId>
         <artifactId>infinispan-spring</artifactId>
         <version>5.0.0</version>
         <scope>compile</scope>
      </dependency>
 
----

{font:monospace}Gradle{font} users will most likely know how to adapt this to their needs. Those leaning towards a more ... pedestrian way of managing their dependencies will need to download {font:monospace}Spring 3.1.0 M1{font} and install it manually alongside {font:monospace}infinispan-spring.jar{font} from the Infinispan distribution.h1. Telling Spring to use Infinispan as its caching providerSpring 3.1's cache provider SPI comprises two interfaces, {font:monospace}org.springframework.cache.CacheManager{font} and {font:monospace}org.springframework.cache.Cache{font} where a {font:monospace}CacheManager{font} serves as a factory for named {font:monospace}Cache{font} instances. By default Spring will look at runtime for a {font:monospace}CacheManager{font} implementation having the bean name "cacheManager" in an application's application context. So by putting


----

<!-- Infinispan cache manager -->
<bean id="cacheManager" 
          class="org.infinispan.spring.provider.SpringEmbeddedCacheManagerFactoryBean"
          p:configurationFileLocation="classpath:/org/infinispan/spring/provider/sample/books-infinispan-config.xml" />

----

somewhere in your application context you tell Spring to henceforth use Infinispan as its caching provider.h1. Adding caching to your application codeAs outlined above enabling caching in your application code is as simple as adding {font:monospace}@Cacheable{font} and {font:monospace}@CacheEvict{font} to select methods. Suppose you've got a DAO for, say, books and you want book instances to be cached once they've been loaded from the underlying database using {font:monospace}BookDao#findBook(Integer bookId){font}. To that end you annotate {font:monospace}findBook(Integer bookId){font} with {font:monospace}@Cacheable{font}, as in


----

@Transactional
@Cacheable(value = "books", key = "#bookId")
Book findBook(Integer bookId) {...}

----

 This will tell Spring to cache Book instances returned from calls to {font:monospace}findBook(Integer bookId){font} in a named cache "books", using the parameter's "bookId" value as a cache key. Here, "#bookId" is an expression in the [Spring Expression Language| link:$$http://static.springsource.org/spring/docs/current/spring-framework-reference/html/expressions.html$$[] ] that evaluates to the {font:monospace}bookId{font} argument. If you don't specify the {font:monospace}key{font} attribute Spring will generate a hash from the supplied method arguments - in this case only {font:monospace}bookId{font} - and use that as a cache key. Essentially, you relinquish control over what cache key to use to Spring. Which may or may not be fine depending on your application's needs.Though the notion of actually deleting a book will undoubtedly seem alien and outright abhorrent to any sane reader there might come the time when your application needs to do just that. For whatever reason. In this case you will want for such a book to be removed not only from the underlying database but from the cache, too. So you annotate {font:monospace}deleteBook(Integer bookId){font} with {font:monospace}@CacheEvict{font} as in 


----

@Transactional
@CacheEvict(value = "books", key = "#bookId")
void deleteBook(Integer bookId) {...}

----

 and you may rest assured that no stray books be left in your application once you decide to remove them.h1. OutroHopefully you enjoyed our quick tour of Infinispan's support for Spring's cache abstraction and saw how easy it is for all your caching woes to be taken care of by Infinispan. More information may be found in Spring's as usual rather excellent [reference documentation| link:$$http://static.springsource.org/spring/docs/3.1.0.M1/spring-framework-reference/html/cache.html$$[] ] and [javadocs| link:$$http://static.springsource.org/spring/docs/3.1.0.M1/javadoc-api/index.html?org/springframework/cache/package-summary.html$$[] ]. Also see [this| link:$$http://blog.springsource.com/2011/02/23/spring-3-1-m1-caching/$$[] ] very nice posting on the official Spring blog for a somewhat more comprehensive introduction to Spring's cache abstraction.{code} 

