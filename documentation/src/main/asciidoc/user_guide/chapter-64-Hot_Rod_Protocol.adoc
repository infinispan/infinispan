==== Hot Rod Protocol
The following articles provides detailed information about each version of
the custom TCP client/server Hot Rod protocol.

* link:$$#_hot_rod_protocol_1_0$$[Hot Rod Protocol 1.0]
* link:$$#_hot_rod_protocol_1_1$$[Hot Rod Protocol 1.1]
* link:$$#_hot_rod_protocol_1_2$$[Hot Rod Protocol 1.2]
* link:$$#_hot_rod_protocol_1_3$$[Hot Rod Protocol 1.3]

===== Hot Rod Protocol 1.0

.Infinispan versions
TIP: This version of the protocol is implemented since Infinispan 4.1.0.Final

IMPORTANT: All key and values are sent and stored as byte arrays. Hot Rod
makes no assumptions about their types.

Some clarifications about the other types:

* vInt : Variable-length integers are defined defined as compressed,
positive integers  where the high-order bit of each byte indicates whether
more bytes need to be  read. The low-order seven bits are appended as
increasingly more significant bits in the resulting integer value making it
efficient to decode. Hence, values from zero to 127 are  stored in a single
byte, values from 128 to 16,383 are stored in two bytes, and so on:
+
[options="header"]
|==============================================================================
| `Value`     | `First byte`    | `Second byte`     | `Third byte`

| `0`         | `00000000`      |                   |
| `1`         | `00000001`      |                   |
| `2`         | `00000010`      |                   |
| `...`       |                 |                   |
| `127`       | `01111111`      |                   |
| `128`       | `10000000`      | `00000001`        |
| `129`       | `10000001`      | `00000001`        |
| `130`       | `10000010`      | `00000001`        |
| `...`       |                 |                   |
| `16,383`    | `11111111`      | `01111111`        |
| `16,384`    | `10000000`      | `10000000`        | `00000001`
| `16,385`    | `10000001`      | `10000000`        | `00000001`
| `...`       |                 |                   |
|==============================================================================
+

* vLong : Refers to unsigned variable length long values similar to vInt but
applied to longer values. They're between 1 and 9 bytes long.
* String : Strings are always represented using UTF-8 encoding.

====== Request Header

The header for a request is composed of:

.Request header

[cols="3,^2,10",options="header"]
|==============================================================================
|Field Name           | Size       | Value

| Magic               | 1 byte     | +0xA0+ = request
| Message ID          | vLong      | ID of the message that will be copied
back in the response. This allows for hot rod clients to implement the
protocol in an asynchronous way.
| Version             | 1 byte     | Infinispan hot rod server version.
In this particular case, this is +10+
| Opcode              | 1 byte     | Request operation code: +
+0x01+ = put request +
+0x03+ = get +
+0x05+ = putIfAbsent +
+0x07+ = replace +
+0x09+ = replaceIfUnmodified +
+0x0B+ = remove +
+0x0D+ = removeIfUnmodified +
+0x0F+ = containsKey +
+0x11+ = getWithVersion +
+0x13+ = clear +
+0x15+ = stats +
+0x17+ = ping +
+0x19+ = bulkGet +
| Cache Name Length   | vInt       | Length of cache name. If the passed
length is +0+ (followed by no cache name), the operation will interact with
the default cache.
| Cache Name          | string     | Name of cache on which to operate.
This name must match the name of predefined cache in the Infinispan
configuration file.
| Flags               | vInt       |  A variable length number representing
flags passed to the system. Each flags is represented by a bit. Note that
since this field is sent as variable length, the most significant bit in a
byte is used to determine whether more bytes need to be read, hence this bit
does not represent any flag. Using this model allows for flags to be combined
in a short space. Here are the current values for each flag: +
+0x0001+ = force return previous value
| Client Intelligence | 1 byte     |  This byte hints the server on the client capabilities: +
+0x01+ = basic client, interested in neither cluster nor hash information +
+0x02+ = topology-aware client, interested in cluster information +
+0x03+ = hash-distribution-aware client, that is interested in both cluster and hash information +
| Topology Id         | vInt       | This field represents the last known
view in the client. Basic clients will only send 0 in this field.
When topology-aware or hash-distribution-aware clients will send 0 until they
have received a reply from the server with the current view id.
Afterwards, they should send that view id until they receive a new view id
in a response.
| Transaction Type    | 1 byte     | This is a 1 byte field, containing one
of the following well-known supported transaction types (For this version of
the protocol, the only supported transaction type is 0): +
+0+ = Non-transactional call, or client does not support transactions.
The subsequent TX_ID field will be omitted. +
+1+ = X/Open XA transaction ID (XID). This is a well-known, fixed-size format.
| Transaction Id      | byte array |  The byte array uniquely identifying the
transaction associated to this call. Itâ€™s length is determined by the
transaction type. If transaction type is 0, no transaction id will be present.
|==============================================================================

====== Response Header

The header for a response is composed of:

.Response header

[cols="3,^2,10",options="header"]
|==============================================================================
|Field Name           | Size       | Value

| Magic                  | 1 byte     | +0xA1+ = response
| Message ID             | vLong      | ID of the message, matching the request
for which the response is sent.
| Opcode                 | 1 byte     | Response operation code: +
+0x02+ = put +
+0x04+ = get +
+0x06+ = putIfAbsent +
+0x08+ = replace +
+0x0A+ = replaceIfUnmodified +
+0x0C+ = remove +
+0x0E+ = removeIfUnmodified +
+0x10+ = containsKey +
+0x12+ = getWithVersion +
+0x14+ = clear +
+0x16+ = stats +
+0x18+ = ping +
+0x1A+ = bulkGet +
+0x50+ = error +
| Status                 | 1 byte     | Status of the response, possible values: +
+0x00+ = No error +
+0x01+ = Not put/removed/replaced +
+0x02+ = Key does not exist +
+0x81+ = Invalid magic or message id +
+0x82+ = Unknown command +
+0x83+ = Unknown version +
+0x84+ = Request parsing error +
+0x85+ = Server Error +
+0x86+ = Command timed out +
| Topology Change Marker | string     | This is a marker byte that indicates
whether the response is prepended with topology change information.
When no topology change follows, the content of this byte is +0+.
If a topology change follows, its contents are +1+.
|==============================================================================

CAUTION: Exceptional error status responses, those that start with 0x8 ...,
are followed by the length of the error message (as a vInt ) and
error message itself as String.

====== Topology Change Headers
The following section discusses how the response headers look for
topology-aware or hash-distribution-aware clients when there's been a cluster
or view formation change. Note that it's the server that makes the decision on
whether it sends back the new topology based on the current topology id and
the one the client sent. If they're different, it will send back the new topology.

====== Topology-Aware Client Topology Change Header
This is what topology-aware clients receive as response header when a
topology change is sent back:

[cols="3,^2,10",options="header"]
|==============================================================================
|Field Name                                    | Size                     | Value

| Response header with topology change marker  | variable                 | See previous section.
| Topology Id                                  | vInt                     | Topology ID
| Num servers in topology                      | vInt                     |
Number of Infinispan Hot Rod servers running within the cluster.
This could be a subset of the entire cluster if only a fraction of those
nodes are running Hot Rod servers.
| m1: Host/IP length                           | vInt                     |
Length of hostname or IP address of individual cluster member that Hot Rod
client can use to access it. Using variable length here allows for covering
for hostnames, IPv4 and IPv6 addresses.
| m1: Host/IP address                          | string                   |
String containing hostname or IP address of individual cluster member
that Hot Rod client can use to access it.
| m1: Port                                     | 2 bytes (Unsigned Short) |
Port that Hot Rod clients can use to communicate with this cluster member.
| m2: Host/IP length                           | vInt                     |
| m2: Host/IP address                          | string                   |
| m2: Port                                     | 2 bytes (Unsigned Short) |
| ...etc||
|==============================================================================

====== Distribution-Aware Client Topology Change Header
This is what hash-distribution-aware clients receive as response header
when a topology change is sent back:

[cols="3,^2,10",options="header"]
|==============================================================================
|Field Name                                    | Size                     | Value

| Response header with topology change marker  | variable                 |
See previous section.
| Topology Id                                  | vInt                     |
Topology ID
| Num Key Owners                               | 2 bytes (Unsigned Short) |
Globally configured number of copies for each Infinispan distributed key
| Hash Function Version                        | 1 byte                   |
Hash function version, pointing to a specific hash function in use.
See link:#_hot_rod_hash_functions[Hot Rod hash functions] for details.
| Hash space size                              | vInt                     |
Modulus used by Infinispan for for all module arithmetic related to hash
code generation. Clients will likely require this information in order to
apply the correct hash calculation to the keys.
| Num servers in topology                      | vInt                     |
Number of Infinispan Hot Rod servers running within the cluster.
This could be a subset of the entire cluster if only a fraction of those
nodes are running Hot Rod servers.
| m1: Host/IP length                           | vInt                     |
Length of hostname or IP address of individual cluster member that Hot Rod
client can use to access it. Using variable length here allows for covering
for hostnames, IPv4 and IPv6 addresses.
| m1: Host/IP address                          | string                   |
String containing hostname or IP address of individual cluster member
that Hot Rod client can use to access it.
| m1: Port                                     | 2 bytes (Unsigned Short) |
Port that Hot Rod clients can use to communicat with this cluster member.
| m1: Hashcode                                 | 4 bytes                  |
32 bit integer representing the hashcode of a cluster member that a Hot Rod
client can use indentify in which cluster member a key is located having
applied the CSA to it.
| m2: Host/IP length                           | vInt                     |
| m2: Host/IP address                          | string                   |
| m2: Port                                     | 2 bytes (Unsigned Short) |
| m2: Hashcode                                 | 4 bytes                  |
| ...etc||
|==============================================================================

It's important to note that since hash headers rely on the consistent hash
algorithm used by the server and this is a factor of the cache interacted with,
hash-distribution-aware headers can only be returned to operations that target
a particular cache. Currently ping command does not target any cache
(this is to change as per link:$$https://jira.jboss.org/jira/browse/ISPN-424$$[ISPN-424])
, hence calls to ping command with hash-topology-aware client settings will
return a hash-distribution-aware header with "Num Key Owners",
"Hash Function Version", "Hash space size" and each individual host's hash
code all set to 0. This type of header will also be returned as response to
operations with hash-topology-aware client settings that are targeting caches
that are not configured with distribution.


====== Operations

.Get/Remove/ContainsKey/GetWithVersion

Common request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Key Length          | vInt       | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array thatâ€™s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key                 | byte array | Byte array containing the key whose value is being requested.
|==============================================================================

Get response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if key retrieved +
+0x02+ = if key does not exist +
| Value Length        | vInt       | If success, length of value
| Value               | byte array | If success, the requested value
|==============================================================================

Remove response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name             | Size       | Value

| Header                 | variable   | Response header
| Response status        | 1 byte     |
+0x00+ = success, if key removed +
+0x02+ = if key does not exist +
| Previous value Length  | vInt       | If force return previous value flag was
sent in the request and the key was removed, the length of the previous value
will be returned. If the key does not exist, value length would be 0.
If no flag was sent, no value length would be present.
| Previous value         | byte array | If force return previous value flag was
sent in the request and the key was removed, previous value.
|==============================================================================

ContainsKey response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if key exists +
+0x02+ = if key does not exist +
|==============================================================================

GetWithVersion response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if key retrieved +
+0x02+ = if key does not exist +
| Entry Version       | 8 bytes    | Unique value of an existing entry's modification.
The protocol does not mandate that entry_version values are sequential.
They just need to be unique per update at the key level.
| Value Length        | vInt       | If success, length of value
| Value               | byte array | If success, the requested value
|==============================================================================

.BulkGet

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Entry count         | vInt       | Maximum number of Infinispan entries to
be returned by the server (entry == key + associated value).
Needed to support CacheLoader.load(int). If 0 then all entries are returned
(needed for CacheLoader.loadAll()).
|==============================================================================

Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, data follows +
| More                | 1 byte     | One byte representing whether more
entries need to be read from the stream. So, when it's set to 1, it means
that an entry follows, whereas when it's set to 0, it's the end of stream and
no more entries are left to read. For more information on BulkGet look
link:$$http://community.jboss.org/docs/DOC-15592$$[here]
| Key 1 Length        | vInt       | Length of key
| Key 1               | byte array | Retrieved key
| Value 1 Length      | vInt       | Length of value
| Value 1             | byte array | Retrieved value
| More                | 1 byte     |
| Key 2 Length        | vInt       |
| Key 2               | byte array |
| Value 2 Length      | vInt       |
| Value 2             | byte array |
|... etc||
|==============================================================================


.Put/PutIfAbsent/Replace

Common request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Key Length          | vInt       | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array thatâ€™s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key                 | byte array | Byte array containing the key whose value is being requested.
| Lifespan            | vInt       | Number of seconds that a entry during
which the entry is allowed to life. If number of seconds is bigger than 30 days,
this number of seconds is treated as UNIX time and so, represents the number
of seconds since 1/1/1970. If set to 0, lifespan is unlimited.
| Max Idle            | vInt       | Number of seconds that a entry can be
idle before it's evicted from the cache. If 0, no max idle time.
| Value Length        | vInt       | Length of value
| Value               | byte-array | Value to be stored
|==============================================================================

Put response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name             | Size       | Value

| Header                 | variable   | Response header
| Response status        | 1 byte     |
+0x00+ = success, if stored +
| Previous value Length  | vInt       | If force return previous value flag was
sent in the request and the key was put, the length of the previous value
will be returned. If the key does not exist, value length would be 0.
If no flag was sent, no value length would be present.
| Previous value         | byte array | If force return previous value flag was
sent in the request and the key was put, previous value.
|==============================================================================

Replace response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name             | Size       | Value

| Header                 | variable   | Response header
| Response status        | 1 byte     |
+0x00+ = success, if stored +
+0x01+ = if store did not happen because key does not exist +
| Previous value Length  | vInt       | If force return previous value flag was
sent in the request and the key was replaced, the length of the previous value
will be returned. If the key does not exist, value length would be 0.
If no flag was sent, no value length would be present.
| Previous value         | byte array | If force return previous value flag was
sent in the request and the key was replaced, previous value.
|==============================================================================

PutIfAbsent response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if stored +
+0x01+ = if store did not happen because key was present +
|==============================================================================

.ReplaceIfUnmodified

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Key Length          | vInt       | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array thatâ€™s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key                 | byte array | Byte array containing the key whose value is being requested.
| Lifespan            | vInt       | Number of seconds that a entry during
which the entry is allowed to life. If number of seconds is bigger than 30 days,
this number of seconds is treated as UNIX time and so, represents the number
of seconds since 1/1/1970. If set to 0, lifespan is unlimited.
| Max Idle            | vInt       | Number of seconds that a entry can be
idle before it's evicted from the cache. If 0, no max idle time.
| Entry Version       | 8 bytes    | Use the value returned by GetWithVersion operation.
| Value Length        | vInt       | Length of value
| Value               | byte-array | Value to be stored
|==============================================================================

Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if replaced +
+0x01+ = if replace did not happen because key had been modified +
+0x02+ = if not replaced because if key does not exist
| Previous value Length  | vInt       | If force return previous value flag was
sent in the request and the key was replaced, the length of the previous value
will be returned. If the key does not exist, value length would be 0.
If no flag was sent, no value length would be present.
| Previous value         | byte array | If force return previous value flag was
sent in the request and the key was replaced, previous value.
|==============================================================================

.RemoveIfUnmodified

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Key Length          | vInt       | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array thatâ€™s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key                 | byte array | Byte array containing the key whose value is being requested.
| Entry Version       | 8 bytes    | Use the value returned by GetWithVersion operation.
|==============================================================================

Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if removed +
+0x01+ = if remove did not happen because key had been modified +
+0x02+ = if not removed because key does not exist +
| Previous value Length  | vInt       | If force return previous value flag was
sent in the request and the key was removed, the length of the previous value
will be returned. If the key does not exist, value length would be 0.
If no flag was sent, no value length would be present.
| Previous value         | byte array | If force return previous value flag was
sent in the request and the key was removed, previous value.
|==============================================================================


.Clear

Request:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
|==============================================================================

Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if cleared +
|==============================================================================

.Stats

Returns a summary of all available statistics. For each statistic returned,
a name and a value is returned both in String UTF-8 format.
The supported stats are the following:

[options="header"]
|===============
|Name|Explanation
| timeSinceStart |Number of seconds since Hot Rod started.
| currentNumberOfEntries |Number of entries currently in the Hot Rod server.
| totalNumberOfEntries |Number of entries stored in Hot Rod server.
| stores |Number of put operations.
| retrievals |Number of get operations.
| hits |Number of get hits.
| misses |Number of get misses.
| removeHits |Number of removal hits.
| removeMisses |Number of removal misses.
|===============

Request:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
|==============================================================================


Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if stats retrieved +
| Number of stats     | vInt       | Number of individual stats returned.
| Name 1 length       | vInt       | Length of named statistic.
| Name 1              | string     | String containing statistic name.
| Value 1 length      | vInt       | Length of value field.
| Value 1             | string     | String containing statistic value.
| Name 2 length       | vInt       |
| Name 2              | string     |
| Value 2 length      | vInt       |
| Value 2             | String     |
| ...etc||
|==============================================================================

.Ping

Application level request to see if the server is available.

Request:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
|==============================================================================

Response:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if no errors +
|==============================================================================

.Error Handling

Error response

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name            | Size       | Value

| Header                | variable   | Response header
| Response status       | 1 byte     |
+0x8x+ = error response code +
| Error Message Length  | vInt       | Length of error message
| Error Message         | string     | Error message. In the case of 0x84 ,
this error field contains the latest version supported by the hot rod server.
Length is defined by total body length.
|==============================================================================

.Multi-Get Operations
A multi-get operation is a form of get operation that instead of requesting a
single key, requests a set of keys. The Hot Rod protocol does not include such
operation but remote Hot Rod clients could easily implement this type of
operations by either parallelizing/pipelining individual get requests.
Another possibility would be for remote clients to use async or non-blocking
get requests. For example, if a client wants N keys, it could send send N
async get requests and then wait for all the replies. Finally, multi-get is
not to be confused with bulk-get operations. In bulk-gets, either all or a
number of keys are retrieved, but the client does not know which keys to
retrieve, whereas in multi-get, the client defines which keys to retrieve.

====== Example - Put request

* Coded request

[options="header"]
|===============
|Byte|0|1|2|3|4|5|6|7
|8| 0xA0 | 0x09 | 0x41 | 0x01 | 0x07 | 0x4D ('M') | 0x79 ('y') | 0x43 ('C')
|16| 0x61 ('a') | 0x63 ('c') | 0x68 ('h') | 0x65 ('e') | 0x00 | 0x03 | 0x00 | 0x00
|24| 0x00 | 0x05 | 0x48 ('H') | 0x65 ('e') | 0x6C ('l') | 0x6C ('l') | 0x6F ('o') | 0x00
|32| 0x00 | 0x05 | 0x57 ('W') | 0x6F ('o') | 0x72 ('r') | 0x6C ('l') | 0x64 ('d') |Â 

|===============

* Field explanation

[options="header"]
|===============
|Field Name|Value|Field Name|Value
|Magic (0)| 0xA0 |Message Id (1)| 0x09
|Version (2)| 0x41 |Opcode (3)| 0x01
|Cache name length (4)| 0x07 |Cache name(5-11)| 'MyCache'
|Flag (12)| 0x00 |Client Intelligence (13)| 0x03
|Topology Id (14)| 0x00 |Transaction Type (15)| 0x00
|Transaction Id (16)| 0x00 |Key field length (17)| 0x05
|Key (18 - 22)| 'Hello' |Lifespan (23)| 0x00
|Max idle (24)| 0x00 |Value field length (25)| 0x05
|Value (26-30)| 'World' ||

|===============



* Coded response

[options="header"]
|===============
|Byte|0|1|2|3|4|5|6|7
|8| 0xA1 | 0x09 | 0x01 | 0x00 | 0x00 |Â |Â |Â 

|===============



* Field Explanation

[options="header"]
|===============
|Field Name|Value|Field Name|Value
|Magic (0)| 0xA1 |Message Id (1)| 0x09
|Opcode (2)| 0x01 |Status (3)| 0x00
|Topology change marker (4)| 0x00 |Â |

|===============

===== Hot Rod Protocol 1.1

.Infinispan versions
TIP: This version of the protocol is implemented since Infinispan 5.1.0.FINAL

====== Request Header
The `version` field in the header is updated to `11`.

===== Distribution-Aware Client Topology Change Header

.Updated for 1.1
IMPORTANT: This section has been modified to be more efficient when talking
to distributed caches with virtual nodes enabled.

This is what hash-distribution-aware clients receive as response header when
a topology change is sent back:

[cols="3,^2,10",options="header"]
|==============================================================================
|Field Name                                    | Size                     | Value

| Response header with topology change marker  | variable                 |
See previous section.
| Topology Id                                  | vInt                     |
Topology ID
| Num Key Owners                               | 2 bytes (Unsigned Short) |
Globally configured number of copies for each Infinispan distributed key
| Hash Function Version                        | 1 byte                   |
Hash function version, pointing to a specific hash function in use.
See link:#_hot_rod_hash_functions[Hot Rod hash functions] for details.
| Hash space size                              | vInt                     |
Modulus used by Infinispan for for all module arithmetic related to hash
code generation. Clients will likely require this information in order to
apply the correct hash calculation to the keys.
| Num servers in topology                      | vInt                     |
Number of Infinispan Hot Rod servers running within the cluster.
This could be a subset of the entire cluster if only a fraction of those
nodes are running Hot Rod servers.
| Num Virtual Nodes Owners                     | vInt                     |
Field added in version +1.1+ of the protocol that represents the number of
configured virtual nodes. If no virtual nodes are configured or the cache
is not configured with distribution, this field will contain 0.
| m1: Host/IP length                           | vInt                     |
Length of hostname or IP address of individual cluster member that Hot Rod
client can use to access it. Using variable length here allows for covering
for hostnames, IPv4 and IPv6 addresses.
| m1: Host/IP address                          | string                   |
String containing hostname or IP address of individual cluster member
that Hot Rod client can use to access it.
| m1: Port                                     | 2 bytes (Unsigned Short) |
Port that Hot Rod clients can use to communicat with this cluster member.
| m1: Hashcode                                 | 4 bytes                  |
32 bit integer representing the hashcode of a cluster member that a Hot Rod
client can use indentify in which cluster member a key is located having
applied the CSA to it.
| m2: Host/IP length                           | vInt                     |
| m2: Host/IP address                          | string                   |
| m2: Port                                     | 2 bytes (Unsigned Short) |
| m2: Hashcode                                 | 4 bytes                  |
| ...etc||
|==============================================================================

===== Server node hash code calculation

Adding support for virtual nodes has made version +1.0+ of the Hot Rod protocol
impractical due to bandwidth it would have taken to return hash codes for all
virtual nodes in the clusters (this number could easily be in the millions).
So, as of version +1.1+ of the Hot Rod protocol, clients are given the base
hash id or hash code of each server, and then they have to calculate the real
hash position of each server both with and without virtual nodes configured.
Here are the rules clients should follow when trying to calculate a node's
hash code:

$$1.$$  With _virtual nodes disabled_ : Once clients have received the base
hash code of the server, they need to normalize it in order to find the exact
position of the hash wheel. The process of normalization involves passing the
base hash code to the hash function, and then do a small calculation to avoid
negative values. The resulting number is the node's position in the hash wheel:

[source,java]
----
public static int getNormalizedHash(int nodeBaseHashCode, Hash hashFct) {
   return hashFct.hash(nodeBaseHashCode) & Integer.MAX_VALUE; // make sure no negative numbers are involved.
}
----

$$2.$$  With _virtual nodes enabled_ : In this case, each node represents N
different virtual nodes, and to calculate each virtual node's hash code, we
need to take the the range of numbers between 0 and N-1 and apply the
following logic:

* For virtual node with 0 as id, use the technique used to retrieve a node's
hash code, as shown in the previous section.

* For virtual nodes from 1 to N-1 ids, execute the following logic:

[source,java]
----
public static int virtualNodeHashCode(int nodeBaseHashCode, int id, Hash hashFct) {
   int virtualNodeBaseHashCode = id;
   virtualNodeBaseHashCode = 31 * virtualNodeBaseHashCode + nodeBaseHashCode;
   return getNormalizedHash(virtualNodeBaseHashCode, hashFct);
}
----


===== Hot Rod Protocol 1.2

.Infinispan versions
TIP: This version of the protocol is implemented since Infinispan 5.2.0.Final. Since Infinispan 5.3.0, HotRod supports encryption via SSL. However, since this only affects the transport, the version number of the protocol has not been incremented.

====== Request Header
The `version` field in the header is updated to `12`.

Two new request operation codes have been added:

* +0x1B+ = getWithMetadata request
* +0x1D+ = bulkKeysGet request

Two new flags have been added too:

* +0x0002+	= use cache-level configured default lifespan
* +0x0004+	= use cache-level configured default max idle

====== Response Header

Two new response operation codes have been added:

* +0x1C+ = getWithMetadata response
* +0x1E+ = bulkKeysGet response

====== Operations

.GetWithMetadata

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Key Length          | vInt       | Length of key. Note that the size of a
vint can be up to 5 bytes which in theory can produce bigger numbers than
Integer.MAX_VALUE. However, Java cannot create a single array thatâ€™s bigger
than Integer.MAX_VALUE, hence the protocol is limiting vint array lengths to
Integer.MAX_VALUE.
| Key                 | byte array | Byte array containing the key whose value is being requested.
|==============================================================================

Response format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, if key retrieved +
+0x02+ = if key does not exist +
| Flag                | 1 byte     | A flag indicating whether the response
contains expiration information. The value of the flag is obtained as a
bitwise OR operation between +INFINITE_LIFESPAN (0x01)+ and
`INFINITE_MAXIDLE (0x02)`.
| Created             | Long       | (optional) a Long representing the
timestamp when the entry was created on the server. This value is returned
only if the flag's +INFINITE_LIFESPAN+ bit is not set.
| Lifespan            | vInt       | (optional) a vInt representing the
lifespan of the entry in seconds. This value is returned only if the flag's
+INFINITE_LIFESPAN+ bit is not set.
| LastUsed            | Long       | (optional) a Long representing the
timestamp when the entry was last accessed on the server. This value is
returned only if the flag's `INFINITE_MAXIDLE` bit is not set.
| MaxIdle             | vInt       | (optional) a vInt representing the
maxIdle of the entry in seconds. This value is returned only if the flag's
`INFINITE_MAXIDLE` bit is not set.
| Entry Version       | 8 bytes    | Unique value of an existing entry's modification.
The protocol does not mandate that entry_version values are sequential.
They just need to be unique per update at the key level.
| Value Length        | vInt       | If success, length of value
| Value               | byte array | If success, the requested value
|==============================================================================

.BulkKeysGet

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Request header
| Scope               | vInt       |
+0+ = Default Scope - This scope is used by RemoteCache.keySet() method.
If the remote cache is a distributed cache, the server launch a map/reduce
operation to retrieve all keys from all of the nodes. (Remember, a
topology-aware Hot Rod Client could be load balancing the request to any
one node in the cluster). Otherwise, it'll get keys from the cache instance
local to the server receiving the request (that is because the keys should
be the same across all nodes in a replicated cache). +
+1+ = Global Scope - This scope behaves the same to Default Scope. +
+2+ = Local Scope - In case when remote cache is a distributed cache,
the server will not launch a map/reduce operation to retrieve keys from
all nodes. Instead, it'll only get keys local from the cache instance local
to the server receiving the request. +
|==============================================================================

Response format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value

| Header              | variable   | Response header
| Response status     | 1 byte     |
+0x00+ = success, data follows +
| More                | 1 byte     | One byte representing whether more
keys need to be read from the stream. So, when it's set to 1, it means
that an entry follows, whereas when it's set to 0, it's the end of stream and
no more entries are left to read. For more information on BulkGet look
link:$$http://community.jboss.org/docs/DOC-15592$$[here]
| Key 1 Length        | vInt       | Length of key
| Key 1               | byte array | Retrieved key
| More                | 1 byte     |
| Key 2 Length        | vInt       |
| Key 2               | byte array |
|... etc||
|==============================================================================

===== Hot Rod Protocol 1.3

.Infinispan versions
TIP: This version of the protocol is implemented since Infinispan 6.0.0.Final.

====== Request Header
The `version` field in the header is updated to `13`.

A new request operation code has been added:

* +0x1F+ = query request

====== Response Header

A new response operation code has been added:

* +0x20+ = query response

====== Operations

.Query

Request format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value
| Header | variable | Request header
| Query Length | vInt | The length of the protobuf encoded query object
| Query | byte array | Byte array containing the protobuf encoded query object, having a length specified by previous field.
|==============================================================================

Response format:

[cols="3,^2,10",options="header"]
|==============================================================================
| Field Name          | Size       | Value
| Header | variable | Response header
| Response payload Length | vInt | The length of the protobuf encoded response object
| Response payload | byte array | Byte array containing the protobuf encoded response object, having a length specified by previous field.
|==============================================================================

As of Infinispan 6.0, the query and response objects are specified by the protobuf message types 'org.infinispan.client.hotrod.impl.query.QueryRequest' and 'org.infinispan.client.hotrod.impl.query.QueryResponse'
respectively defined in link:$$https://github.com/infinispan/infinispan/blob/master/remote-query/remote-query-client/src/main/resources/query.proto$$[remote-query/remote-query-client/src/main/resources/query.proto].
These definitions could change in future Infinispan versions, but as long as these evolutions will be kept backward
compatible (according to the rules defined link:$$https://developers.google.com/protocol-buffers/docs/proto#updating$$[here]) no new Hot Rod
protocol version will be introduced to accommodate this.

==== Hot Rod Hash Functions
Infinispan makes use of a consistent hash function to place nodes on a hash
wheel, and to place keys of entries on the same wheel to determine where
entries live.

In Infinispan 4.2 and earlier, the hash space was hardcoded to 10240, but
since 5.0, the hash space is
link:$$http://docs.oracle.com/javase/6/docs/api/java/lang/Integer.html#MAX_VALUE$$[Integer.MAX_INT] .
Please note that since Hot Rod clients should not assume a particular hash
space by default, every time a hash-topology change is detected, this value is
sent back to the client via the Hot Rod protocol.

When interacting with Infinispan via the Hot Rod protocol, it is mandated
that keys (and values) are byte arrays, to ensure platform neutral behavior.
As such, smart-clients which are aware of hash distribution on the backend
would need to be able to calculate the hash codes of such byte array keys,
again in a platform-neutral manner. To this end, the hash functions used by
Infinispan are versioned and documented, so that it can be re-implemented by
non-Java clients if needed.

The version of the hash function in use is provided in the Hot Rod protocol,
as the hash function version parameter.

.  Version 1 (single byte, 0x01) The initial version of the hash function in
use is link:$$https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/hash/MurmurHash2.java$$[Austin Appleby's MurmurHash 2.0 algorithm] , a fast, non-cryptographic hash that exhibits excellent distribution, collision resistance and avalanche behavior.  The specific version of the algorithm used is the slightly slower, endian-neutral version that allows consistent behavior across both big- and little-endian CPU architectures.  Infinispan's version also hard-codes the hash seed as -1. For details of the algorithm, please visit link:$$http://sites.google.com/site/murmurhash/$$[Austin Appleby's MurmurHash 2.0 page] .  Other implementations are detailed on link:$$http://en.wikipedia.org/wiki/MurmurHash$$[Wikipedia] .
This hash function was the default one used by the Hot Rod server until Infinispan 4.2.1.

.  Version 2 (single byte, 0x02) Since Infinispan 5.0, a new hash function is
used by default which is
link:$$https://github.com/infinispan/infinispan/blob/master/commons/src/main/java/org/infinispan/commons/hash/MurmurHash3.java$$[Austin Appleby's MurmurHash 3.0 algorithm] . Detailed information about the hash function can be found in this link:$$http://code.google.com/p/smhasher/wiki/MurmurHash3$$[wiki] .
Compared to 2.0, it provides better performance and spread.
