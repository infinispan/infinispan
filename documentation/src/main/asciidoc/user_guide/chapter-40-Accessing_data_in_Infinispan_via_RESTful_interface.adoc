[[sid-68355085]]

==  Accessing data in Infinispan via RESTful interface

 
.TODO Gliffy image title empty
image::[]

 _Standards_ Red Hat is working towards standardization of the REST API as a part of the link:$$http://www.rest-star.org$$[REST-*] effort.  To participate in this standard, please visit link:$$http://groups.google.com/group/reststar-caching$$[this Google Group] 

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Puttingdatain]]


=== Putting data in

 HTTP PUT and POST methods are used to place data in the cache - the data being the body of the request (the data can be anything you like). It is important that a Content-Type header is set. 

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-PUT%2F%5C%2F%5C]]


==== PUT /{cacheName}/{cacheKey}

 A PUT request of the above URL form will place the payload (body) in the given cache, with the given key (the named cache must exist on the server). For example link:$$http://someserver/hr/payRoll/3$$[] (in which case "hr" is the cache name, and "payRoll/3" is the key). Any existing data will be replaced, and Time-To-Live and Last-Modified values etc will updated (if applicable). 

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-POST%2F%5C%2F%5C]]


==== POST /{cacheName}/{cacheKey}

 Exactly the same as PUT, only if a value in a cache/key already exists, it will return a Http CONFLICT status (and the content will not be updated). 

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Headers%3A]]


==== Headers:


*  Content-Type : MANDATORY (use link:$$http://www.iana.org/assignments/media-types/$$[media/mime-types] for example: "application/json"). 


[NOTE]
.Special case
==== 
 If you set the Content-Type to application/x-java-serialized-object , then it will be stored as a Java object 


==== 



*  performAsync : OPTIONAL true/false (if true, this will return immediately, and then replicate data to the cluster on its own. Can help with bulk data inserts/large clusters.) 


*  timeToLiveSeconds : OPTIONAL number (the number of seconds before this entry will automatically be deleted) 


* If no parameter is sent, Infinispan assumes -1 as default value, which means that the entry will not expire as a result of ttl. Passing any negative value will have the same effect.


*  maxIdleTimeSeconds : OPTIONAL number (the number of seconds after last usage of this entry when it will automatically be deleted) 


* If no  parameter is sent, Infinispan assumes -1 as default value, which means that the entry will not expire as a result of idle time. Passing any negative value will have the same effect.


[NOTE]
.Passing 0 as parameter for timeToLiveSeconds and/or maxIdleTimeSeconds
==== 

*  If both timeToLiveSeconds and maxIdleTimeSeconds are 0, the cache will use the default lifespan and maxIdle values configured in XML/programmatically 


*  If _only_ maxIdleTimeSeconds is 0, it uses the timeToLiveSeconds value passed as parameter (or -1 if not present), and default maxIdle configured in XML/programmatically 


*  If _only_ timeToLiveSeconds is 0, it uses 0 as timeToLiveSeconds meaning that it will expire immediately, and maxIdle is set whatever came as parameter (or -1 if not present) 


==== 


[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Gettingdatabackout]]


=== Getting data back out

 HTTP GET and HEAD are used to retrieve data from entries. 

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-GET%2F%5C%2F%5C]]


==== GET /{cacheName}/{cacheKey}

 This will return the data found in the given cacheName, under the given key - as the body of the response. A Content-Type header will be supplied which matches what the data was inserted as (other then if it is a Java object, see below). Browsers can use the cache directly of course (eg as a CDN). An link:$$http://en.wikipedia.org/wiki/HTTP_ETag$$[ETag] will be returned unique for each entry, as will the Last-Modified and Expires headers field indicating the state of the data at the given URL. ETags allow browsers (and other clients) to ask for data only in the case where it has changed (to save on bandwidth) - this is standard HTTP and is honoured by Infinispan. 

Since Infinispan 5.3 it is possible to obtain additional information by appending the "extended" parameter on the query string, as follows:


----

GET /cacheName/cacheKey?extended

----

This will return the following custom headers:


* Cluster-Primary-Owner: the node name of the primary owner for this key


* Cluster-Node-Name: the JGroups node name of the server that has handled the request


* Cluster-Physical-Address: the physical JGroups address of the server that has handled the request.

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-HEAD%2F%5C%2F%5C]]


==== HEAD /{cacheName}/{cacheKey}

The same as GET, only no content is returned (only the header fields). You will receive the same content that you stored. E.g., if you stored a String, this is what you get back. If you stored some XML or JSON, this is what you will receive. If you stored a binary (base 64 encoded) blob, perhaps a serialized; Java; object - you will need to; deserialize this yourself.


[WARNING]
.Prior to Infinispan 4.2
==== 
 The behaviour was as follows: If the data in the grid is a Java object - there are a few options in how it can be returned, which use the HTTP Accept header: 


*  application/xml - the object will be serialized via XStream to XML representation 


*  application/json - the object will be sent via a JSON format (via Jackson) 


*  application/x-java-serialized-object - if the object is Serializable, you can use this and get a stream of the Java Serialization form of the object (obviously only makes sense for java clients with a suitable class loaded). If its not Serializable, you have to use one of the other options. 


==== 


Similarly to the GET method, the HEAD method also supports returning extended information via headers. See above.

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-GET%2F%5C]]


==== GET /{cacheName}

This will return a list of keys present in the given cacheName as the body of the response. The format of the response can be controlled via the Accept header as follows:


* application/xml - the list of keys will be returned in XML format.


* application/json - the list of keys will be return in JSON format.


* text/html - the list of keys will be returned in HTML format.


* text/plain - the list of keys will be returned in plain text format, one key per line

If the cache identified by cacheName is distributed, only the keys owned by the node handling the request will be returned. To return all keys, append the "global" parameter to the query, as follows:


----

GET /cacheName?global

----

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-Removingdata]]


=== Removing data

Data can be removed at the cache key/element level, or via a whole cache name using the HTTP delete method.

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-DELETE%2F%5C%2F%5C]]


==== DELETE /{cacheName}/{cacheKey}

Removes the given key name from the cache.

[[sid-68355085_AccessingdatainInfinispanviaRESTfulinterface-DELETE%2F%5C]]


==== DELETE /{cacheName}

Removes ALL the entries in the given cache name (ie everything from that path down). If the operation is successful, it returns 200 code.


[TIP]
.Make it quicker!
==== 
Set the header performAsync to true to return immediately and let the removal happen in the background.


==== 


