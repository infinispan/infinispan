[[sid-68355078]]

==  Invocation Flags

 An important aspect of getting the most of Infinispan is the use of per-invocation flags in order to provide specific behaviour to each particular cache call. By doing this, some important optimizations can be implemented potentially saving precious time and network resources. One of the most popular usages of flags can be found right in Cache API, underneath the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/Cache.html#putForExternalRead(K, V)$$[putForExternalRead()] method which is used to load an Infinispan cache with data read from an external resource. In order to make this call efficient, Infinispan basically calls a normal put operation passing the following flags: link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#FAIL_SILENTLY$$[FAIL_SILENTLY] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#FORCE_ASYNCHRONOUS$$[FORCE_ASYNCHRONOUS] , link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html#ZERO_LOCK_ACQUISITION_TIMEOUT$$[ZERO_LOCK_ACQUISITION_TIMEOUT] 

 What Infinispan is doing here is effectively saying that when putting data read from external read, it will use an almost-zero lock acquisition time and that if the locks cannot be acquired, it will fail silently without throwing any exception related to lock acquisition. It also specifies that regardless of the cache mode, if the cache is clustered, it will replicate asynchronously and so won't wait for responses from other nodes. The combination of all these flags make this kind of operation very efficient, and the efficiency comes from the fact this type of _putForExternalRead_ calls are used with the knowledge that client can always head back to a persistent store of some sorts to retrieve the data that should be stored in memory. So, any attempt to store the data is just a best effort and if not possible, the client should try again if there's a cache miss. 

[[sid-68355078_Per-InvocationFlags-Examples]]


=== Examples

 If you want to use these or any other flags available, which by the way are described in detail the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html$$[Flag enumeration] , you simply need to get hold of the advanced cache and add the flags you need via the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/AdvancedCache.html#withFlags(org.infinispan.context.Flag...)$$[withFlags()] method call. For example: 


----
Cache cache = ...
cache.getAdvancedCache()
   .withFlags(Flag.SKIP_CACHE_STORE, Flag.CACHE_MODE_LOCAL)
   .put("local", "only"); 

----

 It's worth noting that these flags are only active for the duration of the cache operation. If the same flags need to be used in several invocations, even if they're in the same transaction, link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/AdvancedCache.html#withFlags(org.infinispan.context.Flag...)$$[withFlags()] needs to be called repeatedly. Clearly, if the cache operation is to be replicated in another node, the flags are carried over to the remote nodes as well. 

[[sid-68355078_Per-InvocationFlags-DecoratedCache]]


=== DecoratedCache

 Another approach would be to use the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/DecoratedCache.html$$[DecoratedCache] wrapper. This allows you to reuse flags. For example: 


----
AdvancedCache cache = ...
DecoratedCache strictlyLocal = new DecoratedCache(cache, Flag.CACHE_MODE_LOCAL, Flag.SKIP_CACHE_STORE);
strictlyLocal.put("local_1", "only");
strictlyLocal.put("local_2", "only");
strictlyLocal.put("local_3", "only");

----

This approach makes your code more readable.

[[sid-68355078_Per-InvocationFlags-Suppressingreturnvaluesfromaput%28%29orremove%28%29]]


=== Suppressing return values from a put() or remove()

 Another very important use case is when you want a write operation such as put() to _not_ return the previous value. To do that, you need to use two flags to make sure that in a distributed environment, no remote lookup is done to potentially get previous value, and if the cache is configured with a cache loader, to avoid loading the previous value from the cache store. You can see these two flags in action in the following example: 


----
Cache cache = ...
cache.getAdvancedCache()
   .withFlags(Flag.SKIP_REMOTE_LOOKUP, Flag.SKIP_CACHE_LOAD)
   .put("local", "only")

----

 For more information, please check the link:$$http://docs.jboss.org/infinispan/5.1/apidocs/org/infinispan/context/Flag.html$$[Flag enumeration] javadoc. 

