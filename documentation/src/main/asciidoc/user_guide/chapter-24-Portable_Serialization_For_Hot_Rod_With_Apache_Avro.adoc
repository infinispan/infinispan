[[sid-68355061]]

==  Portable Serialization For Hot Rod With Apache Avro

[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-Introduction]]


=== Introduction

 Starting with Infinispan 5.0, Hot Rod clients can be configured with a marshaller that produces plattform independent payloads using link:$$http://avro.apache.org/$$[Apache Avro] . This means that payloads generated by a Java, Avro-based, marshaller could be read by a Python, Avro-based, marshaller. When Hot Rod clients in other languages such as Python or Ruby become available, this will mean that for example, data stored via Java Hot Rod client will be readable by a Python Hot Rod client. 

[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-LanguagesSupported]]


=== Languages Supported

Avro currently supports providing portable serialization payloads for the following languages:


* C


* $$C++$$


* Java


* Python


* Ruby

So interoperability of payloads is limited to these languages. The choice of Avro over other existing portable serialization libraries (i.e. Google Protocol Buffers, Apache Thrift, MessagePack...etc) was done based languages supported, ease of use, and payload size.

[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-ObjectTypesSupported]]


=== Object Types Supported

Avro based marshaller currently supports basic type and collection marshalling:


* Basic types include:


* UTF-8 string


* Integer


* Long


* Float


* Double


* Boolean


* Byte Array


* Collections composed of the basic types :


* Arrays


* Lists


* Maps


* Sets

 Marshalling of complex objects is not supported because it's not fully solvable as some language don't support some concepts other languages offer. Instead, it is recommended that for any complex object marshalling requirements, users serialize these complex objects into byte arrays using portable serialization libraries such as link:$$http://code.google.com/apis/protocolbuffers/$$[Google Protocol Buffers] , link:$$http://incubator.apache.org/thrift/$$[Apache Thrift] , link:$$http://msgpack.org/$$[MessagePack] , or link:$$http://avro.apache.org/$$[Apache Avro] . Once the byte array has been created, simply pass it to the Hot Rod client API which will handle it accordingly. 

Therefore, it's clear that users are free to use any portable serialization library to transform their complex objects into byte arrays, regardless of the fact that Infinispan uses Apache Avro for basic type and collection marshalling. The only limitation here is that the target language used to serialize complex objects needs to be amongst the languages that Apache Avro supports.

 Short and Byte Java primitive types are not supported per se. Instead, clients should pass integers which will be encoded efficiently using link:$$http://lucene.apache.org/java/2_4_0/fileformats.html#VInt$$[variable-length] link:$$http://code.google.com/apis/protocolbuffers/docs/encoding.html#types$$[zig zag] coding. Primitive arrays not supported except byte arrays. Instead, use their object counter partners, i.e. Integer...etc. 

[[sid-68355061_PortableSerializationForHotRodWithApacheAvro-JavaConfiguration]]


=== Java Configuration

 To configure a Java Hot Rod client with Avro marshaller, simply pass a infinispan.client.hotrod.marshaller property to the RemoteCacheManager constructor containing the value of org.infinispan.client.hotrod.marshall.ApacheAvroMarshaller . For example: 


----
Properties props = new Properties();
props.put("infinispan.client.hotrod.marshaller",
   "org.infinispan.client.hotrod.marshall.ApacheAvroMarshaller");
RemoteCacheManager remoteCacheManager = new RemoteCacheManager(props);

----

Note however that if all you're gonna be using are Java Hot Rod clients, there's no need to configure Avro based marshaller. The default marshaller is capable of transforming any Serializable or Externalizable java object into a byte array in a quick and efficient manner.

Please remember as well that when remote java clients are configured with the apache avro marshaller, the server's marshaller does not need changing. This is because the server does not make any attempt at unmarshalling the data that's been passed to it. Internally, it keeps the data as byte arrays.

