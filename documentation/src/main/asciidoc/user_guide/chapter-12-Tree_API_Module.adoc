[[sid-68355037]]

==  Tree API Module

[[sid-68355037_TreeAPIModule-Introduction]]


=== Introduction

 link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/package-summary.html$$[Infinispan's tree API module] offers clients the possibility of storing data using a tree-structure like API. This API is similar to the one link:$$http://docs.jboss.org/jbosscache/3.2.1.GA/apidocs/org/jboss/cache/package-summary.html$$[provided by JBoss Cache] , hence the tree module is perfect for those users wanting to migrate their applications from JBoss Cache to Infinispan, who want to limit changes their codebase as part of the migration. Besides, it's important to understand that Infinispan provides this tree API much more efficiently than JBoss Cache did, so if you're a user of the tree API in JBoss Cache, you should consider migrating to Infinispan. 

[[sid-68355037_TreeAPIModule-WhatisTreeAPIabout%3F]]


=== What is Tree API about?

 The aim of this API is to store information in a hierarchical way. The hierarchy is defined using paths represented as link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/Fqn.html$$[Fqn or fully qualified names] , for example: _/this/is/a/fqn/path_ or _/another/path_ . In the hierarchy, there's an special path called root which represents the starting point of all paths and it's represented as: _/_ 

 Each FQN path is represented as a node where users can store data using a key/value pair style API (i.e. a Map). For example, in _/persons/john_ , you could store information belonging to John, for example: surname=Smith, birthdate=05/02/1980...etc. 

Please remember that users should not use root as a place to store data. Instead, users should define their own paths and store data there. The following sections will delve into the practical aspects of this API.

[[sid-68355037_TreeAPIModule-UsingTreeAPI]]


=== Using Tree API

[[sid-68355037_TreeAPIModule-Dependencies]]


==== Dependencies

 For your application to use the tree API, you need to import infinispan-tree.jar which can be located in the Infinispan binary distributions, or you can simply add a dependency to this module in your pom.xml: 


----

<dependencies>
  ...
  <dependency>
    <groupId>org.infinispan</groupId>
    <artifactId>infinispan-tree</artifactId>
    <version>$put-infinispan-version-here</version>
  </dependency>
  ...
</dependencies>

----

[[sid-68355037_TreeAPIModule-CreatingaTreeCache]]


==== Creating a Tree Cache

 The first step to use the tree API is to actually create a tree cache. To do so, you need to link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737143$$[create an Infinispan Cache as you'd normally do] , and using the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCacheFactory.html$$[TreeCacheFactory] , create an instance of link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html$$[TreeCache] . A very important note to remember here is that the Cache instance passed to the factory must be configured with link:$$https://docs.jboss.org/author/pages/viewpage.action?pageId=3737131$$[invocation batching] . For example: 


----
import org.infinispan.config.Configuration;
import org.infinispan.tree.TreeCacheFactory;
import org.infinispan.tree.TreeCache;
...
Configuration config = new Configuration();
config.setInvocationBatchingEnabled(true);
Cache cache = new DefaultCacheManager(config).getCache();
TreeCache treeCache = TreeCacheFactory.createTreeCache(cache);

----

[[sid-68355037_TreeAPIModule-ManipulatingdatainaTreeCache]]


==== Manipulating data in a Tree Cache

The Tree API effectively provides two ways to interact with the data:


.  Via link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html$$[TreeCache] convenience methods: These methods are located within the TreeCache interface and enable users to link:$$http://docs.jboss.org/infinispan/4.2/apidocs/org/infinispan/tree/TreeCache.html#put(java.lang.String, K, V)$$[store] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#get(org.infinispan.tree.Fqn, K)$$[retrieve] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#move(org.infinispan.tree.Fqn, org.infinispan.tree.Fqn)$$[move] , link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/TreeCache.html#remove(org.infinispan.tree.Fqn, K)$$[remove] ...etc data with a single call that takes the link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Fqn.html$$[Fqn] , in String or Fqn format, and the data involved in the call. For example: 


----
treeCache.put("/persons/john", "surname", "Smith");
----

Or:


----
import org.infinispan.tree.Fqn;
...
Fqn johnFqn = Fqn.fromString("persons/john");
Calendar calendar = Calendar.getInstance();
calendar.set(1980, 5, 2);
treeCache.put(johnFqn, "birthdate", calendar.getTime()));

----


.  Via link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html$$[Node] API: It allows finer control over the individual nodes that form the FQN, allowing manipulation of nodes relative to a particular node. For example: 


----
import org.infinispan.tree.Node;
...
TreeCache treeCache = ...
Fqn johnFqn = Fqn.fromElements("persons", "john"); 
Node<String, Object> john = treeCache.getRoot().addChild(johnFqn);
john.put("surname", "Smith");

----

Or:


----
Node persons = treeCache.getRoot().addChild(Fqn.fromString("persons"));
Node<String, Object> john = persons.addChild(Fqn.fromString("john"));
john.put("surname", "Smith");

----

Or even:


----
Fqn personsFqn = Fqn.fromString("persons");
Fqn johnFqn = Fqn.fromRelative(personsFqn, Fqn.fromString("john"));
Node<String, Object> john = treeCache.getRoot().addChild(johnFqn);
john.put("surname", "Smith");

----

 A node also provides the ability to access its link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html#getParent()$$[parent] or link:$$http://docs.jboss.org/infinispan/5.0/apidocs/org/infinispan/tree/Node.html#getChildren()$$[children] . For example: 


----
Node<String, Object> john = ...
Node persons = john.getParent();

----

Or:


----
Set<Node<String, Object>> personsChildren = persons.getChildren();
----

[[sid-68355037_TreeAPIModule-CommonOperations]]


==== Common Operations

In the previous section, some of the most used operations, such as addition and retrieval, have been shown. However, there are other important operations that are worth mentioning, such as remove:

 You can for example remove an entire node, i.e. _/persons/john_ , using: 


----
treeCache.removeNode("/persons/john");
----

Or remove a child node, i.e. persons that a child of root, via:


----
treeCache.getRoot().removeChild(Fqn.fromString("persons"));
----

You can also remove a particular key/value pair in a node:


----
Node john = treeCache.getRoot().getChild(Fqn.fromElements("persons", "john"));
john.remove("surname");
----

Or you can remove all data in a node with:


----
Node john = treeCache.getRoot().getChild(Fqn.fromElements("persons", "john"));
john.clearData();
----

Another important operation supported by Tree API is the ability to move nodes around in the tree. Imagine we have a node called "john" which is located under root node. The following example is going to show how to we can move "john" node to be under "persons" node:

Current tree structure:


----

   /persons
   /john

----

Moving trees from one FQN to another:


----

Node john = treeCache.getRoot().addChild(Fqn.fromString("john"));
Node persons = treeCache.getRoot().getChild(Fqn.fromString("persons"));
treeCache.move(john.getFqn(), persons.getFqn());

----

Final tree structure:


----

   /persons/john

----

[[sid-68355037_TreeAPIModule-LockingInTreeAPI]]


=== Locking In Tree API

Understanding when and how locks are acquired when manipulating the tree structure is important in order to maximise the performance of any client application interacting against the tree, while at the same time maintaining consistency.

Locking on the tree API happens on a per node basis. So, if you're putting or updating a key/value under a particular node, a write lock is acquired for that node. In such case, no write locks are acquired for parent node of the node being modified, and no locks are acquired for children nodes.

If you're adding or removing a node, the parent is not locked for writing. In JBoss Cache, this behaviour was configurable with the default being that parent was not locked for insertion or removal.

Finally, when a node is moved, the node that's been moved and any of its children are locked, but also the target node and the new location of the moved node and its children. To understand this better, let's look at an example:

Imagine you have a hierarchy like this and we want to move c/ to be underneath b/:


----
        /
      --|--
     /     \
     a     c
     |     |
     b     e
     |
     d

----

The end result would be something like this:


----
        /
        |          
        a     
        |     
        b     
      --|--
     /     \
     d     c
           |
           e

----

To make this move, locks would have been acquired on:


*  _/a/b_ - because it's the parent underneath which the data will be put 


*  _/c_ and _/c/e_ - because they're the nodes that are being moved 


*  _/a/b/c_ and _/a/b/c/e_ - because that's new target location for the nodes being moved 

[[sid-68355037_TreeAPIModule-Listenersfortreecacheevents]]


=== Listeners for tree cache events

 The current Infinispan listeners have been designed with key/value store notifications in mind, and hence they do not map to tree cache events correctly. Tree cache specific listeners that map directly to tree cache events (i.e. adding a child...etc) are desirable but these are not yet available. If you're interested in this type of listeners, please follow link:$$https://issues.jboss.org/browse/ISPN-1935$$[this issue] to find out about any progress in this area. 

